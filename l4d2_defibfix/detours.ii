
typedef int ptrdiff_t;
typedef unsigned int size_t;






typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;



__extension__
typedef long long int int64_t;




typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
typedef int intptr_t;


typedef unsigned int uintptr_t;
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;


typedef uint32_t ucell_t;
typedef int32_t cell_t;
typedef uint32_t funcid_t;








inline cell_t sp_ftoc(float val)
{
 return *(cell_t *)&val;
}







inline float sp_ctof(cell_t val)
{
 return *(float *)&val;
}
namespace SourcePawn
{
 class IPluginContext;
 class IVirtualMachine;
 class IProfiler;
};

struct sp_context_s;





typedef cell_t (*SPVM_NATIVE_FUNC)(SourcePawn::IPluginContext *, const cell_t *);





typedef cell_t (*SPVM_FAKENATIVE_FUNC)(SourcePawn::IPluginContext *, const cell_t *, void *);
typedef struct sp_public_s
{
 funcid_t funcid;
 uint32_t code_offs;
 const char *name;
} sp_public_t;






typedef struct sp_pubvar_s
{
 cell_t *offs;
 const char *name;
} sp_pubvar_t;
typedef struct sp_native_s
{
 SPVM_NATIVE_FUNC pfn;
 const char * name;
 uint32_t status;
 uint32_t flags;
 void * user;
} sp_native_t;




typedef struct sp_nativeinfo_s
{
 const char *name;
 SPVM_NATIVE_FUNC func;
} sp_nativeinfo_t;




typedef struct sp_debug_file_s
{
 uint32_t addr;
 const char * name;
} sp_debug_file_t;




typedef struct sp_debug_line_s
{
 uint32_t addr;
 uint32_t line;
} sp_debug_line_t;


typedef struct sp_debug_arraydim_s
{
  int16_t tagid;
  uint32_t size;
} sp_debug_arraydim_t;


typedef struct sp_debug_symbol_raw_s
{
  int32_t addr;
  int16_t tagid;
  uint32_t codestart;
  uint32_t codeend;
  uint8_t ident;
  uint8_t vclass;
  uint16_t dimcount;
  uint32_t name;
} sp_debug_symbol_raw_t;





typedef struct sp_debug_symbol_s
{
 uint32_t codestart;
 uint32_t codeend;
 const char * name;
 sp_debug_arraydim_t *dims;
 sp_debug_symbol_raw_t *sym;
} sp_debug_symbol_t;

extern "C" {






typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;


__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t;


__extension__ typedef long int __syscall_slong_t;

__extension__ typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
struct _IO_FILE;



typedef struct _IO_FILE FILE;





typedef struct _IO_FILE __FILE;




typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
}




typedef __gnuc_va_list va_list;
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char *__s) throw () __attribute__ ((__warn_unused_result__));





extern char *tmpnam_r (char *__s) throw () __attribute__ ((__warn_unused_result__));
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

extern int fflush_unlocked (FILE *__stream);
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, const char *__modes) throw () __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () __attribute__ ((__warn_unused_result__));




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () __attribute__ ((__warn_unused_result__));






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
extern char *gets (char *__s) __attribute__ ((__warn_unused_result__)) __attribute__ ((__deprecated__));


extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);

extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));








extern void perror (const char *__s);






extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];




extern int fileno (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));
extern FILE *popen (const char *__command, const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) throw ();
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}


extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) throw ();
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) throw ();


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...) throw ()
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) throw ();
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) throw ();


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...) throw ()

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}


extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}




extern int __asprintf_chk (char **__restrict __ptr, int __flag,
      const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
       const char *__restrict __fmt, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
     int __flag, const char *__restrict __format,
     ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
      int __flag,
      const char *__restrict __format,
      __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...) throw ()
{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) __asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...) throw ()

{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) obstack_printf (struct obstack *__restrict __obstack, const char *__restrict __fmt, ...) throw ()

{
  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
          __builtin_va_arg_pack ());
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) vasprintf (char **__restrict __ptr, const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) obstack_vprintf (struct obstack *__restrict __obstack, const char *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
    __ap);
}
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")

                                                 __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_unlocked_alias (__s, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = (__builtin_expect (((__stream)->_IO_read_ptr >= (__stream)->_IO_read_end), 0) ? __uflow (__stream) : *(unsigned char *) (__stream)->_IO_read_ptr++);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}





}

namespace SourceMod
{
 struct IdentityToken_t;
};


struct sp_context_s;
typedef struct sp_context_s sp_context_t;

namespace SourcePawn
{
 class IVirtualMachine;
 class IPluginRuntime;
 enum SP_NULL_TYPE
 {
  SP_NULL_VECTOR = 0,
  SP_NULL_STRING = 1,
 };





 class ICallable
 {
 public:






  virtual int PushCell(cell_t cell) =0;
  virtual int PushCellByRef(cell_t *cell, int flags=(1<<0)) =0;







  virtual int PushFloat(float number) =0;
  virtual int PushFloatByRef(float *number, int flags=(1<<0)) =0;
  virtual int PushArray(cell_t *inarray, unsigned int cells, int flags=0) =0;







  virtual int PushString(const char *string) =0;
  virtual int PushStringEx(char *buffer, size_t length, int sz_flags, int cp_flags) =0;





  virtual void Cancel() =0;
 };
 class IPluginFunction : public ICallable
 {
 public:







  virtual int Execute(cell_t *result) =0;
  virtual int CallFunction(const cell_t *params, unsigned int num_params, cell_t *result) =0;






  virtual IPluginContext *GetParentContext() =0;






  virtual bool IsRunnable() =0;
  virtual funcid_t GetFunctionID() =0;
  virtual int Execute2(IPluginContext *ctx, cell_t *result) =0;
  virtual int CallFunction2(IPluginContext *ctx,
   const cell_t *params,
   unsigned int num_params,
   cell_t *result) =0;






  virtual IPluginRuntime *GetParentRuntime() =0;
 };





 class IPluginDebugInfo
 {
 public:






  virtual int LookupFile(ucell_t addr, const char **filename) =0;







  virtual int LookupFunction(ucell_t addr, const char **name) =0;







  virtual int LookupLine(ucell_t addr, uint32_t *line) =0;
 };




 class ICompilation
 {
 public:







  virtual bool SetOption(const char *key, const char *val) =0;




  virtual void Abort() =0;
 };




 class IPluginRuntime
 {
 public:



  virtual ~IPluginRuntime()
  {
  }






  virtual IPluginDebugInfo *GetDebugInfo() =0;







  virtual int FindNativeByName(const char *name, uint32_t *index) =0;







  virtual int GetNativeByIndex(uint32_t index, sp_native_t **native) =0;






  virtual uint32_t GetNativesNum() =0;







  virtual int FindPublicByName(const char *name, uint32_t *index) =0;







  virtual int GetPublicByIndex(uint32_t index, sp_public_t **publicptr) =0;






  virtual uint32_t GetPublicsNum() =0;







  virtual int GetPubvarByIndex(uint32_t index, sp_pubvar_t **pubvar) =0;







  virtual int FindPubvarByName(const char *name, uint32_t *index) =0;
  virtual int GetPubvarAddrs(uint32_t index, cell_t *local_addr, cell_t **phys_addr) =0;






  virtual uint32_t GetPubVarsNum() =0;







  virtual IPluginFunction *GetFunctionByName(const char *public_name) =0;







  virtual IPluginFunction *GetFunctionById(funcid_t func_id) =0;







  virtual IPluginContext *GetDefaultContext() =0;






  virtual bool IsDebugging() =0;
  virtual int ApplyCompilationOptions(ICompilation *co) =0;






  virtual void SetPauseState(bool paused) =0;






  virtual bool IsPaused() =0;






  virtual size_t GetMemUsage() =0;






  virtual unsigned char *GetCodeHash() =0;






  virtual unsigned char *GetDataHash() =0;
 };




 class IPluginContext
 {
 public:

  virtual ~IPluginContext() { };
 public:





  virtual IVirtualMachine *GetVirtualMachine() =0;
  virtual sp_context_t *GetContext() =0;






  virtual bool IsDebugging() =0;







  virtual int SetDebugBreak(void *newpfn, void *oldpfn) =0;






  virtual IPluginDebugInfo *GetDebugInfo() =0;
  virtual int HeapAlloc(unsigned int cells, cell_t *local_addr, cell_t **phys_addr) =0;
  virtual int HeapPop(cell_t local_addr) =0;
  virtual int HeapRelease(cell_t local_addr) =0;







  virtual int FindNativeByName(const char *name, uint32_t *index) =0;







  virtual int GetNativeByIndex(uint32_t index, sp_native_t **native) =0;






  virtual uint32_t GetNativesNum() =0;







  virtual int FindPublicByName(const char *name, uint32_t *index) =0;







  virtual int GetPublicByIndex(uint32_t index, sp_public_t **publicptr) =0;






  virtual uint32_t GetPublicsNum() =0;







  virtual int GetPubvarByIndex(uint32_t index, sp_pubvar_t **pubvar) =0;







  virtual int FindPubvarByName(const char *name, uint32_t *index) =0;
  virtual int GetPubvarAddrs(uint32_t index, cell_t *local_addr, cell_t **phys_addr) =0;






  virtual uint32_t GetPubVarsNum() =0;







  virtual int LocalToPhysAddr(cell_t local_addr, cell_t **phys_addr) =0;







  virtual int LocalToString(cell_t local_addr, char **addr) =0;
  virtual int StringToLocal(cell_t local_addr, size_t bytes, const char *source) =0;
  virtual int StringToLocalUTF8(cell_t local_addr,
           size_t maxbytes,
           const char *source,
           size_t *wrtnbytes) =0;






  virtual int PushCell(cell_t value) =0;
  virtual int PushCellArray(cell_t *local_addr, cell_t **phys_addr, cell_t array[], unsigned int numcells) =0;
  virtual int PushString(cell_t *local_addr, char **phys_addr, const char *string) =0;







  virtual int PushCellsFromArray(cell_t array[], unsigned int numcells) =0;
  virtual int BindNatives(const sp_nativeinfo_t *natives, unsigned int num, int overwrite) =0;






  virtual int BindNative(const sp_nativeinfo_t *native) =0;






  virtual int BindNativeToAny(SPVM_NATIVE_FUNC native) =0;
  virtual int Execute(uint32_t code_addr, cell_t *result) =0;
  virtual cell_t ThrowNativeErrorEx(int error, const char *msg, ...) =0;
  virtual cell_t ThrowNativeError(const char *msg, ...) =0;







  virtual IPluginFunction *GetFunctionByName(const char *public_name) =0;







  virtual IPluginFunction *GetFunctionById(funcid_t func_id) =0;
  virtual SourceMod::IdentityToken_t *GetIdentity() =0;
  virtual cell_t *GetNullRef(SP_NULL_TYPE type) =0;
  virtual int LocalToStringNULL(cell_t local_addr, char **addr) =0;







  virtual int BindNativeToIndex(uint32_t index, SPVM_NATIVE_FUNC native) =0;






  virtual bool IsInExec() =0;






  virtual IPluginRuntime *GetRuntime() =0;
  virtual int Execute2(IPluginFunction *function,
   const cell_t *params,
   unsigned int num_params,
   cell_t *result) =0;







  virtual int GetLastNativeError() =0;
  virtual cell_t *GetLocalParams() =0;
  virtual void SetKey(int k, void *value) =0;
  virtual bool GetKey(int k, void **value) =0;




  virtual void ClearLastNativeError() =0;
 };





 struct CallStackInfo
 {
  const char *filename;
  unsigned int line;
  const char *function;
 };




 class IContextTrace
 {
 public:





  virtual int GetErrorCode() =0;






  virtual const char *GetErrorString() =0;






  virtual bool DebugInfoAvailable() =0;






  virtual const char *GetCustomErrorString() =0;
  virtual bool GetTraceInfo(CallStackInfo *trace) =0;




  virtual void ResetTrace() =0;
  virtual const char *GetLastNative(uint32_t *index) =0;
 };





 class IDebugListener
 {
 public:






  virtual void OnContextExecuteError(IPluginContext *ctx, IContextTrace *error) =0;







  virtual void OnDebugSpew(const char *msg, ...) =0;
 };




 class IProfiler;




 class IProfilingTool
 {
 public:





  virtual const char *Name() = 0;






  virtual const char *Description() = 0;






  virtual void RenderHelp(void (*render)(const char *fmt, ...)) = 0;
  virtual bool Start() = 0;






  virtual void Stop(void (*render)(const char *fmt, ...)) = 0;
  virtual void Dump() = 0;






  virtual bool IsActive() = 0;






  virtual bool IsAttached() = 0;
  virtual void EnterScope(const char *group, const char *name) = 0;





  virtual void LeaveScope() = 0;
 };

 struct sp_plugin_s;
 typedef struct sp_plugin_s sp_plugin_t;




 class ISourcePawnEngine
 {
 public:







  virtual sp_plugin_t *LoadFromFilePointer(FILE *fp, int *err) =0;
  virtual sp_plugin_t *LoadFromMemory(void *base, sp_plugin_t *plugin, int *err) =0;







  virtual int FreeFromMemory(sp_plugin_t *plugin) =0;







  virtual void *BaseAlloc(size_t size) =0;






  virtual void BaseFree(void *memory) =0;
  virtual void *ExecAlloc(size_t size) =0;







  virtual void ExecFree(void *address) =0;
  virtual IDebugListener *SetDebugListener(IDebugListener *listener) =0;






  virtual unsigned int GetContextCallCount() =0;






  virtual unsigned int GetEngineAPIVersion() =0;







  virtual void *AllocatePageMemory(size_t size) =0;






  virtual void SetReadWrite(void *ptr) =0;






  virtual void SetReadExecute(void *ptr) =0;






  virtual void FreePageMemory(void *ptr) =0;
 };




 class ISourcePawnEngine2
 {
 public:





  virtual unsigned int GetAPIVersion() =0;




  virtual const char *GetEngineName() =0;






  virtual const char *GetVersionString() =0;






  virtual ICompilation *StartCompilation() =0;
  virtual IPluginRuntime *LoadPlugin(ICompilation *co, const char *file, int *err) =0;
  virtual SPVM_NATIVE_FUNC CreateFakeNative(SPVM_FAKENATIVE_FUNC callback, void *pData) =0;






  virtual void DestroyFakeNative(SPVM_NATIVE_FUNC func) =0;
  virtual IDebugListener *SetDebugListener(IDebugListener *listener) =0;






  virtual void SetProfiler(IProfiler *profiler) =0;







  virtual const char *GetErrorString(int err) =0;






  virtual bool Initialize() =0;





  virtual void Shutdown() =0;
  virtual IPluginRuntime *CreateEmptyRuntime(const char *name, uint32_t memory) =0;
  virtual bool InstallWatchdogTimer(size_t timeout_ms) =0;







  virtual bool SetJitEnabled(bool enabled) =0;






  virtual bool IsJitEnabled() =0;
  virtual void EnableProfiling() = 0;




  virtual void DisableProfiling() = 0;






  virtual void SetProfilingTool(IProfilingTool *tool) =0;
 };
};

namespace SourceMod
{
 class IExtension;
 struct IdentityToken_t;


 typedef unsigned int HandleType_t;


 typedef HandleType_t IdentityType_t;




 enum FeatureType
 {
  FeatureType_Native,
  FeatureType_Capability
 };




 enum FeatureStatus
 {
  FeatureStatus_Available = 0,
  FeatureStatus_Unavailable,
  FeatureStatus_Unknown
 };




 class IFeatureProvider
 {
 public:







  virtual FeatureStatus GetFeatureStatus(FeatureType type, const char *name) = 0;
 };




 class SMInterface
 {
 public:



  virtual unsigned int GetInterfaceVersion() =0;




  virtual const char *GetInterfaceName() =0;
  virtual bool IsVersionCompatible(unsigned int version)
  {
   if (version > GetInterfaceVersion())
   {
    return false;
   }

   return true;
  }
 };




 class IShareSys
 {
 public:







  virtual bool AddInterface(IExtension *myself, SMInterface *iface) =0;
  virtual bool RequestInterface(const char *iface_name,
          unsigned int iface_vers,
          IExtension *myself,
          SMInterface **pIface) =0;
  virtual void AddNatives(IExtension *myself, const sp_nativeinfo_t *natives) =0;
  virtual IdentityType_t CreateIdentType(const char *name) =0;
  virtual IdentityType_t FindIdentType(const char *name) =0;
  virtual IdentityToken_t *CreateIdentity(IdentityType_t type, void *ptr) =0;







  virtual void DestroyIdentType(IdentityType_t type) =0;







  virtual void DestroyIdentity(IdentityToken_t *identity) =0;
  virtual void AddDependency(IExtension *myself, const char *filename, bool require, bool autoload) =0;







  virtual void RegisterLibrary(IExtension *myself, const char *name) =0;







  virtual void OverrideNatives(IExtension *myself, const sp_nativeinfo_t *natives) =0;
  virtual void AddCapabilityProvider(IExtension *myself,
                                     IFeatureProvider *provider,
                                     const char *name) =0;
  virtual void DropCapabilityProvider(IExtension *myself,
                                      IFeatureProvider *provider,
                                      const char *name) =0;
  virtual FeatureStatus TestFeature(SourcePawn::IPluginRuntime *rt,
            FeatureType type,
            const char *name) =0;

 };
}

extern "C" {










struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}


typedef __clock_t clock_t;





typedef __time_t time_t;



typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();





typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
extern int getdate_err;
extern struct tm *getdate (const char *__string);
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}


namespace SourceMod
{



 enum FileTimeType
 {
  FileTime_LastAccess = 0,
  FileTime_Created = 1,
  FileTime_LastChange = 2,
 };

 class ILibrary
 {
 public:

  virtual ~ILibrary()
  {
  };
 public:



  virtual void CloseLibrary() =0;







  virtual void *GetSymbolAddress(const char *symname) =0;
 };




 class IDirectory
 {
 public:

  virtual ~IDirectory()
  {
  }
 public:



  virtual bool MoreFiles() =0;




  virtual void NextEntry() =0;




  virtual const char *GetEntryName() =0;




  virtual bool IsEntryDirectory() =0;




  virtual bool IsEntryFile() =0;





  virtual bool IsEntryValid() =0;
 };




 class ILibrarySys : public SMInterface
 {
 public:
  virtual const char *GetInterfaceName()
  {
   return "ILibrarySys";
  }
  virtual unsigned int GetInterfaceVersion()
  {
   return 5;
  }
 public:
  virtual ILibrary *OpenLibrary(const char *path, char *error, size_t maxlength) =0;







  virtual IDirectory *OpenDirectory(const char *path) =0;






  virtual void CloseDirectory(IDirectory *dir) =0;




  virtual bool PathExists(const char *path) =0;




  virtual bool IsPathFile(const char *path) =0;




  virtual bool IsPathDirectory(const char *path) =0;
  virtual void GetPlatformError(char *error, size_t maxlength) =0;
  virtual size_t PathFormat(char *buffer, size_t maxlength, const char *pathfmt, ...) =0;







  virtual const char *GetFileExtension(const char *filename) =0;







  virtual bool CreateFolder(const char *path) =0;
  virtual bool FileTime(const char *path, FileTimeType type, time_t *pTime) =0;
  virtual size_t GetFileFromPath(char *buffer, size_t maxlength, const char *path) =0;
 };
}






struct edict_t;

namespace SourceMod
{
 class IExtensionInterface;
 typedef void * ITERATOR;




 class IExtension
 {
 public:



  virtual bool IsLoaded() =0;






  virtual IExtensionInterface *GetAPI() =0;
  virtual const char *GetFilename() =0;






  virtual IdentityToken_t *GetIdentity() =0;
  virtual ITERATOR *FindFirstDependency(IExtension **pOwner, SMInterface **pInterface) =0;
  virtual bool FindNextDependency(ITERATOR *iter, IExtension **pOwner, SMInterface **pInterface) =0;






  virtual void FreeDependencyIterator(ITERATOR *iter) =0;
  virtual bool IsRunning(char *error, size_t maxlength) =0;
  virtual bool IsExternal() =0;
 };
 class IExtensionInterface
 {
 public:

  virtual unsigned int GetExtensionVersion()
  {
   return 8;
  }
 public:
  virtual bool OnExtensionLoad(IExtension *me,
   IShareSys *sys,
   char *error,
   size_t maxlength,
   bool late) =0;




  virtual void OnExtensionUnload() =0;





  virtual void OnExtensionsAllLoaded() =0;






  virtual void OnExtensionPauseChange(bool pause) =0;
  virtual bool QueryInterfaceDrop(SMInterface *pInterface)
  {
   return false;
  }
  virtual void NotifyInterfaceDrop(SMInterface *pInterface)
  {
  }
  virtual bool QueryRunning(char *error, size_t maxlength)
  {
   return true;
  }
 public:
  virtual bool IsMetamodExtension() =0;






  virtual const char *GetExtensionName() =0;






  virtual const char *GetExtensionURL() =0;






  virtual const char *GetExtensionTag() =0;






  virtual const char *GetExtensionAuthor() =0;
  virtual const char *GetExtensionVerString() =0;
  virtual const char *GetExtensionDescription() =0;






  virtual const char *GetExtensionDateString() =0;
  virtual void OnCoreMapStart(edict_t *pEdictList, int edictCount, int clientMax)
  {
  }
  virtual void OnDependenciesDropped()
  {
  }






  virtual void OnCoreMapEnd()
  {
  }
 };
 class IExtensionManager : public SMInterface
 {
 public:
  virtual const char *GetInterfaceName()
  {
   return "IExtensionManager";
  }
  virtual unsigned int GetInterfaceVersion()
  {
   return 2;
  }
  virtual bool IsVersionCompatible(unsigned int version)
  {
   if (version < 2)
   {
    return false;
   }
   return SMInterface::IsVersionCompatible(version);
  }
 public:
  virtual IExtension *LoadExtension(const char *path,
   char *error,
   size_t maxlength) =0;
  virtual IExtension *LoadExternal(IExtensionInterface *pInterface,
   const char *filepath,
   const char *filename,
   char *error,
   size_t maxlength) =0;
  virtual bool UnloadExtension(IExtension *pExt) =0;
 };
}
namespace SourceMod
{



 typedef unsigned int HandleType_t;




 typedef unsigned int Handle_t;
 enum HandleError
 {
  HandleError_None = 0,
  HandleError_Changed,
  HandleError_Type,
  HandleError_Freed,
  HandleError_Index,
  HandleError_Access,
  HandleError_Limit,
  HandleError_Identity,
  HandleError_Owner,
  HandleError_Version,
  HandleError_Parameter,
  HandleError_NoInherit,
 };




 enum HTypeAccessRight
 {
  HTypeAccess_Create = 0,
  HTypeAccess_Inherit,

  HTypeAccess_TOTAL,
 };






 enum HandleAccessRight
 {
  HandleAccess_Read,
  HandleAccess_Delete,
  HandleAccess_Clone,

  HandleAccess_TOTAL,
 };
 struct TypeAccess
 {

  TypeAccess()
  {
   hsVersion = 5;
  }
  unsigned int hsVersion;
  IdentityToken_t *ident;
  bool access[HTypeAccess_TOTAL];
 };




 struct HandleAccess
 {

  HandleAccess()
  {
   hsVersion = 5;
  }
  unsigned int hsVersion;
  unsigned int access[HandleAccess_TOTAL];
 };




 struct HandleSecurity
 {
  HandleSecurity()
  {
  }
  HandleSecurity(IdentityToken_t *owner, IdentityToken_t *identity)
   : pOwner(owner), pIdentity(identity)
  {
  }
  IdentityToken_t *pOwner;
  IdentityToken_t *pIdentity;
 };




 class IHandleTypeDispatch
 {
 public:

  virtual unsigned int GetDispatchVersion()
  {
   return 5;
  }
 public:






  virtual void OnHandleDestroy(HandleType_t type, void *object) =0;
  virtual bool GetHandleApproxSize(HandleType_t type, void *object, unsigned int *pSize)
  {
   return false;
  }
 };




 class IHandleSys : public SMInterface
 {
 public:
  virtual unsigned int GetInterfaceVersion()
  {
   return 5;
  }
  virtual const char *GetInterfaceName()
  {
   return "IHandleSys";
  }
 public:
  virtual HandleType_t CreateType(const char *name,
            IHandleTypeDispatch *dispatch,
            HandleType_t parent,
            const TypeAccess *typeAccess,
            const HandleAccess *hndlAccess,
            IdentityToken_t *ident,
            HandleError *err) =0;
  virtual bool RemoveType(HandleType_t type, IdentityToken_t *ident) =0;
  virtual bool FindHandleType(const char *name, HandleType_t *type) =0;
  virtual Handle_t CreateHandle(HandleType_t type,
           void *object,
           IdentityToken_t *owner,
           IdentityToken_t *ident,
           HandleError *err) =0;
  virtual HandleError FreeHandle(Handle_t handle, const HandleSecurity *pSecurity) =0;
  virtual HandleError CloneHandle(Handle_t handle,
          Handle_t *newhandle,
          IdentityToken_t *newOwner,
          const HandleSecurity *pSecurity) =0;
  virtual HandleError ReadHandle(Handle_t handle,
            HandleType_t type,
            const HandleSecurity *pSecurity,
            void **object) =0;
  virtual bool InitAccessDefaults(TypeAccess *pTypeAccess, HandleAccess *pHandleAccess) =0;
  virtual Handle_t CreateHandleEx(HandleType_t type,
          void *object,
          const HandleSecurity *pSec,
          const HandleAccess *pAccess,
          HandleError *err) =0;






  virtual Handle_t FastCloneHandle(Handle_t hndl) =0;
  virtual bool TypeCheck(HandleType_t given, HandleType_t actual) = 0;
 };
}


extern "C" {






extern int *__errno_location (void) throw () __attribute__ ((__const__));
extern char *program_invocation_name, *program_invocation_short_name;



}
typedef int error_t;
extern "C" {








typedef __gid_t gid_t;




typedef __uid_t uid_t;
typedef __useconds_t useconds_t;
typedef __socklen_t socklen_t;
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__));





extern ssize_t write (int __fd, const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__));
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) __attribute__ ((__warn_unused_result__));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) __attribute__ ((__warn_unused_result__));
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) __attribute__ ((__warn_unused_result__));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) __attribute__ ((__warn_unused_result__));







extern int pipe (int __pipedes[2]) throw () __attribute__ ((__warn_unused_result__));




extern int pipe2 (int __pipedes[2], int __flags) throw () __attribute__ ((__warn_unused_result__));
extern unsigned int alarm (unsigned int __seconds) throw ();
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () __attribute__ ((__warn_unused_result__));




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) throw () __attribute__ ((__warn_unused_result__));
extern char *getcwd (char *__buf, size_t __size) throw () __attribute__ ((__warn_unused_result__));





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__));




extern int dup (int __fd) throw () __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));





enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () __attribute__ ((__warn_unused_result__));



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () __attribute__ ((__warn_unused_result__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () __attribute__ ((__warn_unused_result__));




extern int seteuid (__uid_t __uid) throw () __attribute__ ((__warn_unused_result__));






extern int setgid (__gid_t __gid) throw () __attribute__ ((__warn_unused_result__));




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () __attribute__ ((__warn_unused_result__));




extern int setegid (__gid_t __gid) throw () __attribute__ ((__warn_unused_result__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () __attribute__ ((__warn_unused_result__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () __attribute__ ((__warn_unused_result__));






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
extern "C" {
extern char *optarg;
extern int optind;




extern int opterr;



extern int optopt;
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
}







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int sethostid (long int __id) throw () __attribute__ ((__warn_unused_result__));





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () __attribute__ ((__warn_unused_result__));






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int ftruncate (int __fd, __off_t __length) throw () __attribute__ ((__warn_unused_result__));
extern int ftruncate64 (int __fd, __off64_t __length) throw () __attribute__ ((__warn_unused_result__));
extern int brk (void *__addr) throw () __attribute__ ((__warn_unused_result__));





extern void *sbrk (intptr_t __delta) throw ();
extern long int syscall (long int __sysno, ...) throw ();
extern int lockf (int __fd, int __cmd, __off_t __len) __attribute__ ((__warn_unused_result__));
extern int lockf64 (int __fd, int __cmd, __off64_t __len) __attribute__ ((__warn_unused_result__));
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen) __attribute__ ((__warn_unused_result__));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read")
                               __attribute__ ((__warn_unused_result__));
extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("read called with bigger length than size of " "the destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));

      if (__nbytes > __builtin_object_size (__buf, 0))
 return __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));
    }
  return __read_alias (__fd, __buf, __nbytes);
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread")

                                 __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")

                                     __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread called with bigger length than size of " "the destination buffer")))
                                  ;
extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread64 called with bigger length than size of " "the destination buffer")))
                                  ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread_chk_warn (__fd, __buf, __nbytes, __offset,
     __builtin_object_size (__buf, 0));
    }
  return __pread_alias (__fd, __buf, __nbytes, __offset);
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
       __builtin_object_size (__buf, 0));
    }

  return __pread64_alias (__fd, __buf, __nbytes, __offset);
}




extern ssize_t __readlink_chk (const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_alias (const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __asm__ ("" "readlink")


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_chk_warn (const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__readlink_chk")



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlink called with bigger length " "than size of destination buffer")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__leaf__)) readlink (const char *__restrict __path, char *__restrict __buf, size_t __len) throw ()

{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if ( __len > __builtin_object_size (__buf, 2 > 1))
 return __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1));
    }
  return __readlink_alias (__path, __buf, __len);
}



extern ssize_t __readlinkat_chk (int __fd, const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_alias (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) throw () __asm__ ("" "readlinkat")



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_chk_warn (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__readlinkat_chk")



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlinkat called with bigger " "length than size of destination " "buffer")))

                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__leaf__)) readlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) throw ()

{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if (__len > __builtin_object_size (__buf, 2 > 1))
 return __readlinkat_chk_warn (__fd, __path, __buf, __len,
          __builtin_object_size (__buf, 2 > 1));
    }
  return __readlinkat_alias (__fd, __path, __buf, __len);
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     throw () __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) throw () __asm__ ("" "getcwd")
                                              __attribute__ ((__warn_unused_result__));
extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) throw () __asm__ ("" "__getcwd_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getcwd caller with bigger length than size of " "destination buffer")))
                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__leaf__)) getcwd (char *__buf, size_t __size) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size))
 return __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 2 > 1));

      if (__size > __builtin_object_size (__buf, 2 > 1))
 return __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 2 > 1));
    }
  return __getcwd_alias (__buf, __size);
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *__getwd_warn (char *__buf) throw () __asm__ ("" "getwd")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use getcwd instead, as getwd " "doesn't specify buffer size")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__leaf__)) getwd (char *__buf) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 2 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) throw ();
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) throw () __asm__ ("" "confstr")
                             ;
extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) throw () __asm__ ("" "__confstr_chk")


     __attribute__((__warning__ ("confstr called with bigger length than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) confstr (int __name, char *__buf, size_t __len) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1));

      if (__builtin_object_size (__buf, 2 > 1) < __len)
 return __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1));
    }
  return __confstr_alias (__name, __buf, __len);
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
     throw () __attribute__ ((__warn_unused_result__));
extern int __getgroups_alias (int __size, __gid_t __list[]) throw () __asm__ ("" "getgroups")
                 __attribute__ ((__warn_unused_result__));
extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) throw () __asm__ ("" "__getgroups_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getgroups called with bigger group count than what " "can fit into destination buffer")))
                                           ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) getgroups (int __size, __gid_t __list[]) throw ()
{
  if (__builtin_object_size (__list, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size) || __size < 0)
 return __getgroups_chk (__size, __list, __builtin_object_size (__list, 2 > 1));

      if (__size * sizeof (__gid_t) > __builtin_object_size (__list, 2 > 1))
 return __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 2 > 1));
    }
  return __getgroups_alias (__size, __list);
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) throw () __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) throw () __asm__ ("" "ttyname_r")

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__ttyname_r_chk")


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ttyname_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) ttyname_r (int __fd, char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ttyname_r_alias (__fd, __buf, __buflen);
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r")
                     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("getlogin_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __getlogin_r_alias (__buf, __buflen);
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     throw () __attribute__ ((__nonnull__ (1)));
extern int __gethostname_alias (char *__buf, size_t __buflen) throw () __asm__ ("" "gethostname")
                   __attribute__ ((__nonnull__ (1)));
extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__gethostname_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("gethostname called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) gethostname (char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __gethostname_alias (__buf, __buflen);
}




extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int __getdomainname_alias (char *__buf, size_t __buflen) throw () __asm__ ("" "getdomainname")

                     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int __getdomainname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__getdomainname_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getdomainname called with bigger " "buflen than size of destination " "buffer")))

                    ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) getdomainname (char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getdomainname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));

      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __getdomainname_alias (__buf, __buflen);
}


}
extern "C" {






typedef __ino_t ino_t;






typedef __ino64_t ino64_t;
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern void rewinddir (DIR *__dirp) throw () __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) throw () __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) throw () __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) throw () __attribute__ ((__nonnull__ (1)));
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));
extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));




extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     throw () __attribute__ ((__nonnull__ (2, 4)));
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     throw () __attribute__ ((__nonnull__ (2, 4)));






extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



}


extern "C" {


extern void _dl_mcount_wrapper_check (void *__selfpc) throw ();

}
typedef long int Lmid_t;







extern "C" {



extern void *dlopen (const char *__file, int __mode) throw ();



extern int dlclose (void *__handle) throw () __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) throw () __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) throw ();



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) throw ();





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     throw () __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) throw () __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     throw () __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;
  Dl_serpath dls_serpath[1];
} Dl_serinfo;



}
typedef __dev_t dev_t;
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
typedef __blkcnt_t blkcnt_t;







typedef __blksize_t blksize_t;




extern "C" {

struct stat
  {
    __dev_t st_dev;

    unsigned short int __pad1;


    __ino_t st_ino;




    __mode_t st_mode;
    __nlink_t st_nlink;




    __uid_t st_uid;
    __gid_t st_gid;



    __dev_t st_rdev;

    unsigned short int __pad2;


    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    unsigned long int __glibc_reserved4;
    unsigned long int __glibc_reserved5;




  };



struct stat64
  {
    __dev_t st_dev;





    unsigned int __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;

    __uid_t st_uid;
    __gid_t st_gid;





    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;

    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;

  };
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) throw () __attribute__ ((__nonnull__ (2)));
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat (const char *__path, struct stat *__statbuf) throw ()
{
  return __xstat (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat (const char *__path, struct stat *__statbuf) throw ()
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag) throw ()

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknod (const char *__path, __mode_t __mode, __dev_t __dev) throw ()
{
  return __xmknod (1, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev) throw ()

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __xstat64 (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (3, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag) throw ()

{
  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
}






}

namespace SourceMod
{



 class IDataReader
 {
 public:



  virtual void Reset() const =0;






  virtual size_t GetPosition() const =0;







  virtual bool SetPosition(size_t pos) const =0;






  virtual cell_t ReadCell() const =0;






  virtual float ReadFloat() const =0;
  virtual bool IsReadable(size_t bytes) const =0;







  virtual const char *ReadString(size_t *len) const =0;






  virtual void *GetMemory() const =0;







  virtual void *ReadMemory(size_t *size) const =0;






  virtual cell_t ReadFunction() const =0;
 };




 class IDataPack : public IDataReader
 {
 public:



  virtual void ResetSize() =0;






  virtual void PackCell(cell_t cell) =0;






  virtual void PackFloat(float val) =0;







  virtual void PackString(const char *string) =0;
  virtual size_t CreateMemory(size_t size, void **addr) =0;






  virtual void PackFunction(cell_t function) =0;
 };
}
class KeyValues;

namespace SourceMod
{



 enum PathType
 {
  Path_None = 0,
  Path_Game,
  Path_SM,
  Path_SM_Rel,
 };






 typedef void (*GAME_FRAME_HOOK)(bool simulating);






 typedef void (*FRAMEACTION)(void *data);




 class ISourceMod : public SMInterface
 {
 public:
  virtual const char *GetInterfaceName()
  {
   return "ISourceMod";
  }
  virtual unsigned int GetInterfaceVersion()
  {
   return 13;
  }
 public:





  virtual const char *GetGamePath() const =0;






  virtual const char *GetSourceModPath() const =0;
  virtual size_t BuildPath(PathType type, char *buffer, size_t maxlength, const char *format, ...) =0;
  virtual void LogMessage(IExtension *pExt, const char *format, ...) =0;
  virtual void LogError(IExtension *pExt, const char *format, ...) =0;
  virtual size_t FormatString(char *buffer,
         size_t maxlength,
         SourcePawn::IPluginContext *pContext,
         const cell_t *params,
         unsigned int param) =0;






  virtual IDataPack *CreateDataPack() =0;






  virtual void FreeDataPack(IDataPack *pack) =0;







  virtual HandleType_t GetDataPackHandleType(bool readonly=false) =0;
  virtual KeyValues *ReadKeyValuesHandle(Handle_t hndl, HandleError *err=
                                                                        __null
                                                                            , bool root=false) =0;






  virtual const char *GetGameFolderName() const =0;






  virtual SourcePawn::ISourcePawnEngine *GetScriptingEngine() =0;






  virtual SourcePawn::IVirtualMachine *GetScriptingVM() =0;






  virtual time_t GetAdjustedTime() =0;
  virtual unsigned int SetGlobalTarget(unsigned int index) =0;
  virtual unsigned int GetGlobalTarget() const =0;






  virtual void AddGameFrameHook(GAME_FRAME_HOOK hook) =0;






  virtual void RemoveGameFrameHook(GAME_FRAME_HOOK hook) =0;
  virtual size_t Format(char *buffer, size_t maxlength, const char *fmt, ...) = 0;
  virtual size_t FormatArgs(char *buffer, size_t maxlength, const char *fmt, va_list ap) = 0;
  virtual void AddFrameAction(FRAMEACTION fn, void *data) = 0;
  virtual const char *GetCoreConfigValue(const char *key) = 0;






  virtual int GetPluginId() = 0;







  virtual int GetShApiVersion() = 0;






  virtual bool IsMapRunning() = 0;
 };
}




namespace SourceMod
{



 enum AdminFlag
 {
  Admin_Reservation = 0,
  Admin_Generic,
  Admin_Kick,
  Admin_Ban,
  Admin_Unban,
  Admin_Slay,
  Admin_Changemap,
  Admin_Convars,
  Admin_Config,
  Admin_Chat,
  Admin_Vote,
  Admin_Password,
  Admin_RCON,
  Admin_Cheats,
  Admin_Root,
  Admin_Custom1,
  Admin_Custom2,
  Admin_Custom3,
  Admin_Custom4,
  Admin_Custom5,
  Admin_Custom6,

  AdminFlags_TOTAL,
 };
 enum OverrideType
 {
  Override_Command = 1,
  Override_CommandGroup,
 };




 enum OverrideRule
 {
  Command_Deny = 0,
  Command_Allow = 1,
 };




 enum ImmunityType
 {
  Immunity_Default = 1,
  Immunity_Global,
 };




 enum AccessMode
 {
  Access_Real,
  Access_Effective,
 };




 typedef int GroupId;




 typedef int AdminId;
 enum AdminCachePart
 {
  AdminCache_Overrides = 0,
  AdminCache_Groups = 1,
  AdminCache_Admins = 2,
 };




 class IAdminListener
 {
 public:
  virtual unsigned int GetInterfaceVersion()
  {
   return 8;
  }
 public:





  virtual void OnRebuildAdminCache(bool auto_rebuild) =0;




  virtual void OnRebuildGroupCache() =0;




  virtual void OnRebuildOverrideCache() =0;
 };




 typedef unsigned int FlagBits;




 class IAdminSystem : public SMInterface
 {
 public:
  const char *GetInterfaceName()
  {
   return "IAdminSys";
  }
  unsigned int GetInterfaceVersion()
  {
   return 8;
  }
 public:
  virtual void AddCommandOverride(const char *cmd, OverrideType type, FlagBits flags) =0;
  virtual bool GetCommandOverride(const char *cmd, OverrideType type, FlagBits *pFlags) =0;







  virtual void UnsetCommandOverride(const char *cmd, OverrideType type) =0;







  virtual GroupId AddGroup(const char *group_name) =0;







  virtual GroupId FindGroupByName(const char *group_name) =0;
  virtual void SetGroupAddFlag(GroupId id, AdminFlag flag, bool enabled) =0;
  virtual bool GetGroupAddFlag(GroupId id, AdminFlag flag) =0;
  virtual FlagBits GetGroupAddFlags(GroupId id) =0;
  virtual void SetGroupGenericImmunity(GroupId id, ImmunityType type, bool enabled) =0;
  virtual bool GetGroupGenericImmunity(GroupId id, ImmunityType type) =0;







  virtual void AddGroupImmunity(GroupId id, GroupId other_id) =0;







  virtual unsigned int GetGroupImmunityCount(GroupId id) =0;
  virtual GroupId GetGroupImmunity(GroupId id, unsigned int number) =0;
  virtual void AddGroupCommandOverride(GroupId id,
            const char *name,
            OverrideType type,
            OverrideRule rule) =0;
  virtual bool GetGroupCommandOverride(GroupId id,
            const char *name,
            OverrideType type,
            OverrideRule *pRule) =0;
  virtual void DumpAdminCache(AdminCachePart part, bool rebuild) =0;






  virtual void AddAdminListener(IAdminListener *pListener) =0;






  virtual void RemoveAdminListener(IAdminListener *pListener) =0;







  virtual void RegisterAuthIdentType(const char *name) =0;
  virtual AdminId CreateAdmin(const char *name) =0;
  virtual const char *GetAdminName(AdminId id) =0;
  virtual bool BindAdminIdentity(AdminId id, const char *auth, const char *ident) =0;
  virtual void SetAdminFlag(AdminId id, AdminFlag flag, bool enabled) =0;
  virtual bool GetAdminFlag(AdminId id, AdminFlag flag, AccessMode mode) =0;
  virtual FlagBits GetAdminFlags(AdminId id, AccessMode mode) =0;
  virtual void SetAdminFlags(AdminId id, AccessMode mode, FlagBits bits) =0;
  virtual bool AdminInheritGroup(AdminId id, GroupId gid) =0;







  virtual unsigned int GetAdminGroupCount(AdminId id) =0;
  virtual GroupId GetAdminGroup(AdminId id, unsigned int index, const char **name) =0;







  virtual void SetAdminPassword(AdminId id, const char *password) =0;







  virtual const char *GetAdminPassword(AdminId id) =0;
  virtual AdminId FindAdminByIdentity(const char *auth, const char *identity) =0;







  virtual bool InvalidateAdmin(AdminId id) =0;
  virtual unsigned int FlagBitsToBitArray(FlagBits bits, bool array[], unsigned int maxSize) =0;
  virtual FlagBits FlagBitArrayToBits(const bool array[], unsigned int maxSize) =0;
  virtual FlagBits FlagArrayToBits(const AdminFlag array[], unsigned int numFlags) =0;
  virtual unsigned int FlagBitsToArray(FlagBits bits, AdminFlag array[], unsigned int maxSize) =0;
  virtual bool CheckAdminFlags(AdminId id, FlagBits bits) =0;
  virtual bool CanAdminTarget(AdminId id, AdminId target) =0;
  virtual bool FindFlag(const char *flagname, AdminFlag *pAdmFlag) =0;
  virtual bool FindFlag(char c, AdminFlag *pAdmFlag) =0;
  virtual FlagBits ReadFlagString(const char *flags, const char **end) =0;
  virtual unsigned int GetAdminSerialChange(AdminId id) =0;
  virtual bool CanAdminUseCommand(int client, const char *cmd) =0;







  virtual const char *GetGroupName(GroupId gid) =0;
  virtual unsigned int SetGroupImmunityLevel(GroupId gid, unsigned int level) =0;







  virtual unsigned int GetGroupImmunityLevel(GroupId gid) =0;
  virtual unsigned int SetAdminImmunityLevel(AdminId id, unsigned int level) =0;







  virtual unsigned int GetAdminImmunityLevel(AdminId id) =0;
  virtual bool CheckAccess(int client,
   const char *cmd,
   FlagBits flags,
   bool override_only) =0;
  virtual bool FindFlagChar(AdminFlag flag, char *c) =0;







  virtual bool IsValidAdmin(AdminId id) =0;
  virtual bool CheckClientCommandAccess(int client, const char *cmd, FlagBits cmdflags) =0;
 };
}




struct edict_t;
class IPlayerInfo;






namespace SourceMod
{



 class IGamePlayer
 {
 public:






  virtual const char *GetName() =0;







  virtual const char *GetIPAddress() =0;
  virtual const char *GetAuthString(bool validated = true) =0;






  virtual edict_t *GetEdict() =0;






  virtual bool IsInGame() =0;
  virtual bool IsConnected() =0;






  virtual bool IsFakeClient() =0;






  virtual AdminId GetAdminId() =0;







  virtual void SetAdminId(AdminId id, bool temp) =0;






  virtual int GetUserId() =0;






  virtual unsigned int GetLanguageId() =0;






  virtual IPlayerInfo *GetPlayerInfo() =0;
  virtual bool RunAdminCacheChecks() =0;
  virtual void NotifyPostAdminChecks() =0;






  virtual unsigned int GetSerial() =0;






  virtual bool IsAuthorized() =0;






  virtual void Kick(const char *message) =0;
  virtual bool IsInKickQueue() =0;






  virtual void MarkAsBeingKicked() =0;

  virtual void SetLanguageId(unsigned int id) =0;






  virtual bool IsSourceTV() const =0;






  virtual bool IsReplay() const =0;
  virtual unsigned int GetSteamAccountID(bool validated = true) =0;






  virtual int GetIndex() const =0;






  virtual void PrintToConsole(const char *pMsg) =0;




  virtual void ClearAdmin() =0;
  virtual uint64_t GetSteamId64(bool validated = true) =0;
  virtual const char *GetSteam2Id(bool validated = true) =0;
  virtual const char *GetSteam3Id(bool validated = true) =0;
 };




 class IClientListener
 {
 public:





  virtual unsigned int GetClientListenerVersion()
  {
   return 21;
  }
 public:
  virtual bool InterceptClientConnect(int client, char *error, size_t maxlength)
  {
   return true;
  }






  virtual void OnClientConnected(int client)
  {
  }






  virtual void OnClientPutInServer(int client)
  {
  }






  virtual void OnClientDisconnecting(int client)
  {
  }






  virtual void OnClientDisconnected(int client)
  {
  }







  virtual void OnClientAuthorized(int client, const char *authstring)
  {
  }




  virtual void OnServerActivated(int max_clients)
  {
  }
  virtual bool OnClientPreAdminCheck(int client)
  {
   return true;
  }
  virtual void OnClientPostAdminCheck(int client)
  {
  }






  virtual void OnMaxPlayersChanged(int newvalue)
  {
  }






  virtual void OnClientSettingsChanged(int client)
  {
  }
 };
 struct cmd_target_info_t
 {
  const char *pattern;
  int admin;
  cell_t *targets;
  cell_t max_targets;
  int flags;
  char *target_name;
  size_t target_name_maxlength;
  int target_name_style;
  int reason;
  unsigned int num_targets;
 };




 class ICommandTargetProcessor
 {
 public:
  virtual bool ProcessCommandTarget(cmd_target_info_t *info) =0;
 };

 class IPlayerManager : public SMInterface
 {
 public:
  const char *GetInterfaceName()
  {
   return "IPlayerManager";
  }
  unsigned int GetInterfaceVersion()
  {
   return 21;
  }
 public:





  virtual void AddClientListener(IClientListener *listener) =0;






  virtual void RemoveClientListener(IClientListener *listener) =0;
  virtual IGamePlayer *GetGamePlayer(int client) =0;







  virtual IGamePlayer *GetGamePlayer(edict_t *pEdict) =0;
  virtual int GetMaxClients() =0;






  virtual int GetNumPlayers() =0;







  virtual int GetClientOfUserId(int userid) =0;







  virtual bool IsServerActivated() =0;






  virtual unsigned int GetReplyTo() =0;







  virtual unsigned int SetReplyTo(unsigned int reply) =0;
  virtual int FilterCommandTarget(IGamePlayer *pAdmin, IGamePlayer *pTarget, int flags) =0;






  virtual void RegisterCommandTargetProcessor(ICommandTargetProcessor *pHandler) =0;






  virtual void UnregisterCommandTargetProcessor(ICommandTargetProcessor *pHandler) =0;






  virtual int GetClientFromSerial(unsigned int serial) =0;







  virtual void ProcessCommandTarget(cmd_target_info_t *info) =0;






  virtual void ClearAdminId(AdminId id) =0;




  virtual void RecheckAnyAdmins() =0;
 };
}





namespace SourceMod
{
 class ITextListener_INI
 {
 public:



  virtual unsigned int GetTextParserVersion1()
  {
   return 4;
  }
 public:
  virtual bool ReadINI_NewSection(const char *section,
          bool invalid_tokens,
          bool close_bracket,
          bool extra_tokens,
          unsigned int *curtok)
  {
   return true;
  }
  virtual bool ReadINI_KeyValue(const char *key,
           const char *value,
           bool invalid_tokens,
           bool equal_token,
           bool quotes,
           unsigned int *curtok)
  {
   return true;
  }
  virtual bool ReadINI_RawLine(const char *line, unsigned int *curtok)
  {
   return true;
  }
 };
 enum SMCResult
 {
  SMCResult_Continue,
  SMCResult_Halt,
  SMCResult_HaltFail
 };




 enum SMCError
 {
  SMCError_Okay = 0,
  SMCError_StreamOpen,
  SMCError_StreamError,
  SMCError_Custom,
  SMCError_InvalidSection1,
  SMCError_InvalidSection2,
  SMCError_InvalidSection3,
  SMCError_InvalidSection4,
  SMCError_InvalidSection5,
  SMCError_InvalidTokens,
  SMCError_TokenOverflow,
  SMCError_InvalidProperty1,
 };




 struct SMCStates
 {
  unsigned int line;
  unsigned int col;
 };




 class ITextListener_SMC
 {
 public:



  virtual unsigned int GetTextParserVersion2()
  {
   return 4;
  }
 public:



  virtual void ReadSMC_ParseStart()
  {
  };







  virtual void ReadSMC_ParseEnd(bool halted, bool failed)
  {
  }
  virtual SMCResult ReadSMC_NewSection(const SMCStates *states, const char *name)
  {
   return SMCResult_Continue;
  }
  virtual SMCResult ReadSMC_KeyValue(const SMCStates *states, const char *key, const char *value)
  {
   return SMCResult_Continue;
  }







  virtual SMCResult ReadSMC_LeavingSection(const SMCStates *states)
  {
   return SMCResult_Continue;
  }
  virtual SMCResult ReadSMC_RawLine(const SMCStates *states, const char *line)
  {
   return SMCResult_Continue;
  }
 };




 class ITextParsers : public SMInterface
 {
 public:
  virtual const char *GetInterfaceName()
  {
   return "ITextParsers";
  }
  virtual unsigned int GetInterfaceVersion()
  {
   return 4;
  }
  virtual bool IsVersionCompatible(unsigned int version)
  {
   if (version < 2)
   {
    return false;
   }
   return SMInterface::IsVersionCompatible(version);
  }
 public:
  virtual bool ParseFile_INI(const char *file,
         ITextListener_INI *ini_listener,
         unsigned int *line,
         unsigned int *col) =0;
  virtual SMCError ParseFile_SMC(const char *file,
         ITextListener_SMC *smc_listener,
         SMCStates *states) =0;







  virtual const char *GetSMCErrorString(SMCError err) =0;

 public:







  virtual unsigned int GetUTF8CharBytes(const char *stream) =0;
  virtual bool IsWhitespace(const char *stream) =0;
  virtual SMCError ParseSMCFile(const char *file,
   ITextListener_SMC *smc_listener,
   SMCStates *states,
   char *buffer,
   size_t maxsize) =0;
  virtual SMCError ParseSMCStream(const char *stream,
   size_t length,
   ITextListener_SMC *smc_listener,
   SMCStates *states,
   char *buffer,
   size_t maxsize) =0;
 };

 inline unsigned int _GetUTF8CharBytes(const char *stream)
 {
  unsigned char c = *(unsigned char *)stream;
  if (c & (1<<7))
  {
   if (c & (1<<5))
   {
    if (c & (1<<4))
    {
     return 4;
    }
    return 3;
   }
   return 2;
  }
  return 1;
 }
}

extern SourceMod::ITextParsers *textparsers;
class SendProp;

namespace SourceMod
{



 class IGameConfig
 {
 public:







  virtual bool GetOffset(const char *key, int *value) =0;







  virtual SendProp *GetSendProp(const char *key) =0;







  virtual const char *GetKeyValue(const char *key) =0;
  virtual bool GetMemSig(const char *key, void **addr) =0;
  virtual bool GetAddress(const char *key, void **addr) =0;
 };




 class IGameConfigManager : public SMInterface
 {
 public:
  const char *GetInterfaceName()
  {
   return "IGameConfigManager";
  }
  unsigned int GetInterfaceVersion()
  {
   return 6;
  }
 public:
  virtual bool LoadGameConfigFile(const char *file,
   IGameConfig **pConfig,
   char *error,
   size_t maxlength) =0;
  virtual void CloseGameConfigFile(IGameConfig *cfg) =0;
  virtual IGameConfig *ReadHandle(Handle_t hndl,
   IdentityToken_t *ident,
   HandleError *err) =0;
  virtual void AddUserConfigHook(const char *sectionname, ITextListener_SMC *listener) =0;
  virtual void RemoveUserConfigHook(const char *sectionname, ITextListener_SMC *listener) =0;




  virtual void AcquireLock() = 0;




  virtual void ReleaseLock() = 0;
 };
}





class CBaseEntity;
class CBaseHandle;
class SendProp;
class ServerClass;
class ICommandLine;
struct edict_t;
struct datamap_t;
struct typedescription_t;






namespace SourceMod
{



 struct sm_sendprop_info_t
 {
  SendProp *prop;
  unsigned int actual_offset;
 };

 struct sm_datatable_info_t
 {
  typedescription_t *prop;
  unsigned int actual_offset;
 };

 class IGameHelpers : public SMInterface
 {
 public:
  virtual const char *GetInterfaceName()
  {
   return "IGameHelpers";
  }
  virtual unsigned int GetInterfaceVersion()
  {
   return 11;
  }
 public:







  virtual SendProp *FindInSendTable(const char *classname, const char *offset) =0;






  virtual ServerClass *FindServerClass(const char *classname) =0;
  virtual typedescription_t *FindInDataMap(datamap_t *pMap, const char *offset) =0;







  virtual datamap_t *GetDataMap(CBaseEntity *pEntity) =0;







  virtual void SetEdictStateChanged(edict_t *pEdict, unsigned short offset) =0;
  virtual bool TextMsg(int client, int dest, const char *msg) =0;






  virtual bool IsLANServer() =0;
  virtual bool FindSendPropInfo(const char *classname,
   const char *offset,
   sm_sendprop_info_t *info) =0;







  virtual edict_t *EdictOfIndex(int index) =0;







  virtual int IndexOfEdict(edict_t *pEnt) =0;







  virtual edict_t *GetHandleEntity(CBaseHandle &hndl) =0;
  virtual void SetHandleEntity(CBaseHandle &hndl, edict_t *pEnt) =0;






  virtual const char *GetCurrentMap() =0;






  virtual void ServerCommand(const char *buffer) =0;
  virtual CBaseEntity *ReferenceToEntity(cell_t entRef) =0;







  virtual cell_t EntityToReference(CBaseEntity *pEntity) =0;







  virtual cell_t EntityToBCompatRef(CBaseEntity *pEntity) =0;







  virtual cell_t IndexToReference(int entIndex) =0;







  virtual int ReferenceToIndex(cell_t entRef) =0;







  virtual cell_t ReferenceToBCompatRef(cell_t entRef) =0;






  virtual void *GetGlobalEntityList() =0;
  virtual void AddDelayedKick(int client, int userid, const char *msg) =0;







  virtual int GetSendPropOffset(SendProp *prop) =0;
  virtual bool HintTextMsg(int client, const char *msg) =0;






  virtual ICommandLine *GetValveCommandLine() =0;







  virtual const char *GetEntityClassname(edict_t *pEdict) =0;







  virtual const char *GetEntityClassname(CBaseEntity *pEntity) =0;
  virtual bool IsMapValid(const char *map) =0;
  virtual bool FindDataMapInfo(datamap_t *pMap, const char *offset, sm_datatable_info_t *pDataTable) =0;
  virtual bool GetServerSteam3Id(char *pszOut, size_t len) const =0;






  virtual uint64_t GetServerSteamId64() const =0;
 };
}
namespace SourceHook
{
 template <class OutputClass, class InputClass>
 inline OutputClass implicit_cast(InputClass input){
  return input;
 }


 struct MemFuncInfo
 {
  bool isVirtual;
  int thisptroffs;

  int vtblindex;
  int vtbloffs;
 };




 template<int N> struct MFI_Impl
 {
  template<class MFP> static inline void GetFuncInfo(MFP *mfp, MemFuncInfo &out)
  {
   static char weird_memfunc_pointer_exclamation_mark_arrow_error[N-1000];
  }
 };



 template<> struct MFI_Impl<2*sizeof(void*)>
 {
  struct GCC_MemFunPtr
  {
   union
   {
    void *funcadr;
    intptr_t vtable_index_plus1;
   };
   intptr_t delta;
  };
  template<class MFP> static inline void GetFuncInfo(MFP mfp, MemFuncInfo &out)
  {
   GCC_MemFunPtr *mfp_detail = (GCC_MemFunPtr*)&mfp;
   out.thisptroffs = mfp_detail->delta;
   if (mfp_detail->vtable_index_plus1 & 1)
   {
    out.vtblindex = (mfp_detail->vtable_index_plus1 - 1) / sizeof(void*);
    out.vtbloffs = 0;
    out.isVirtual = true;
   }
   else
    out.isVirtual = false;
  }
 };
 template<class X> inline void GetFuncInfo(X mfp, MemFuncInfo &out)
 {
  MFI_Impl<sizeof(mfp)>::GetFuncInfo(mfp, out);
 }



 template<class X, class Y, class RetType>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)() = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)() const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)() const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }






 template<class X, class Y, class RetType>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }


 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
 inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...), MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...) = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }

 template<class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
  inline void GetFuncInfo(Y *ptr, RetType(X::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...) const, MemFuncInfo &out)
 {
  RetType(Y::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...) const = mfp;
  MFI_Impl<sizeof(mfp2)>::GetFuncInfo(mfp2, out);
 }




}

extern "C" {













extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__leaf__)) memmove (void *__dest, const void *__src, size_t __len) throw ()
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__leaf__)) mempcpy (void *__restrict __dest, const void *__restrict __src, size_t __len) throw ()

{
  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__leaf__)) memset (void *__dest, int __ch, size_t __len) throw ()
{
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__leaf__)) bcopy (const void *__src, void *__dest, size_t __len) throw ()
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__leaf__)) bzero (void *__dest, size_t __len) throw ()
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src) throw ()
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__leaf__)) stpcpy (char *__restrict __dest, const char *__restrict __src) throw ()
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len) throw ()

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) throw ();
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) throw () __asm__ ("" "stpncpy")
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__leaf__)) stpncpy (char *__dest, const char *__src, size_t __n) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__leaf__)) strcat (char *__restrict __dest, const char *__restrict __src) throw ()
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len) throw ()

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
__mempcpy_inline (void *__restrict __dest,
    const void *__restrict __src, size_t __n)
{
  return (char *) memcpy (__dest, __src, __n) + __n;
}




}

namespace fastdelegate {
namespace detail {







template <class OutputClass, class InputClass>
inline OutputClass implicit_cast(InputClass input){
 return input;
}
template <class OutputClass, class InputClass>
union horrible_union{
 OutputClass out;
 InputClass in;
};

template <class OutputClass, class InputClass>
inline OutputClass horrible_cast(const InputClass input){
 horrible_union<OutputClass, InputClass> u;



 typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u)
  && sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];
 u.in = input;
 return u.out;
}
typedef void DefaultVoid;




template <class T>
struct DefaultVoidToVoid { typedef T type; };

template <>
struct DefaultVoidToVoid<DefaultVoid> { typedef void type; };



template <class T>
struct VoidToDefaultVoid { typedef T type; };

template <>
struct VoidToDefaultVoid<void> { typedef DefaultVoid type; };
 class GenericClass;



const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());
template <int N>
struct SimplifyMemFunc {
 template <class X, class XFuncType, class GenericMemFuncType>
 inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
  GenericMemFuncType &bound_func) {


  typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];
  return 0;
 }
};



template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE> {
 template <class X, class XFuncType, class GenericMemFuncType>
 inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
   GenericMemFuncType &bound_func) {






        bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

        return reinterpret_cast<GenericClass *>(pthis);
 }
};
}
class DelegateMemento {
protected:


 typedef void (detail::GenericClass::*GenericMemFuncType)();
 detail::GenericClass *m_pthis;
 GenericMemFuncType m_pFunction;






public:






 DelegateMemento() : m_pthis(0), m_pFunction(0) {};
 void clear() { m_pthis=0; m_pFunction=0; }

public:
 inline bool IsEqual (const DelegateMemento &x) const{
  return m_pthis==x.m_pthis && m_pFunction==x.m_pFunction;
 }


 inline bool IsLess(const DelegateMemento &right) const {





  if (m_pthis !=right.m_pthis) return m_pthis < right.m_pthis;



  return memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;

 }



 inline bool operator ! () const
 { return m_pthis==0 && m_pFunction==0; }
 inline bool empty() const
 { return m_pthis==0 && m_pFunction==0; }
public:
 DelegateMemento & operator = (const DelegateMemento &right) {
  SetMementoFrom(right);
  return *this;
 }
 inline bool operator <(const DelegateMemento &right) {
  return IsLess(right);
 }
 inline bool operator >(const DelegateMemento &right) {
  return right.IsLess(*this);
 }
 DelegateMemento (const DelegateMemento &right) :
  m_pthis(right.m_pthis), m_pFunction(right.m_pFunction)



  {}
protected:
 void SetMementoFrom(const DelegateMemento &right) {
  m_pFunction = right.m_pFunction;
  m_pthis = right.m_pthis;



 }
};
namespace detail {

template < class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr>
class ClosurePtr : public DelegateMemento {
public:





 template < class X, class XMemFunc >
 inline void bindmemfunc(X *pthis, XMemFunc function_to_bind ) {
  m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
   ::Convert(pthis, function_to_bind, m_pFunction);



 }




 template < class X, class XMemFunc>
 inline void bindconstmemfunc(const X *pthis, XMemFunc function_to_bind) {
  m_pthis= SimplifyMemFunc< sizeof(function_to_bind) >
   ::Convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);



 }

 template < class X, class XMemFunc>
 inline void bindmemfunc(const X *pthis, XMemFunc function_to_bind) {
  bindconstmemfunc(pthis, function_to_bind);



 }


 inline GenericClass *GetClosureThis() const { return m_pthis; }
 inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }
 template< class DerivedClass >
 inline void CopyFrom (DerivedClass *pParent, const DelegateMemento &right) {
  SetMementoFrom(right);
 }




 template < class DerivedClass, class ParentInvokerSig>
 inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
    StaticFuncPtr function_to_bind) {
  if (function_to_bind==0) {
   m_pFunction=0;
  } else {


   bindmemfunc(pParent, static_function_invoker);
        }





  typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];
  m_pthis = horrible_cast<GenericClass *>(function_to_bind);




 }




 inline UnvoidStaticFuncPtr GetStaticFunction() const {



  typedef int ERROR_CantUseEvilMethod[sizeof(UnvoidStaticFuncPtr)==sizeof(this) ? 1 : -1];
  return horrible_cast<UnvoidStaticFuncPtr>(this);
 }



 inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr){
  if (funcptr==0) return empty();


  else return funcptr==reinterpret_cast<StaticFuncPtr>(GetStaticFunction());
 }
};


}
template<class RetType=detail::DefaultVoid>
class FastDelegate0 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)();
 typedef RetType (*UnvoidStaticFunctionPtr)();
 typedef RetType (detail::GenericClass::*GenericMemFn)();
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate0 type;


 FastDelegate0() { clear(); }
 FastDelegate0(const FastDelegate0 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate0 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate0 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate0 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate0 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate0 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate0(Y *pthis, DesiredRetType (X::* function_to_bind)() ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)()) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate0(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate0(DesiredRetType (*function_to_bind)() ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)() ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)()) {
  m_Closure.bindstaticfunc(this, &FastDelegate0::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() () const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction() const {
 return (*(m_Closure.GetStaticFunction()))(); }
};


template<class Param1, class RetType=detail::DefaultVoid>
class FastDelegate1 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate1 type;


 FastDelegate1() { clear(); }
 FastDelegate1(const FastDelegate1 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate1 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate1 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate1 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate1 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate1 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate1(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate1(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate1(DesiredRetType (*function_to_bind)(Param1 p1) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1)) {
  m_Closure.bindstaticfunc(this, &FastDelegate1::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1) const {
 return (*(m_Closure.GetStaticFunction()))(p1); }
};


template<class Param1, class Param2, class RetType=detail::DefaultVoid>
class FastDelegate2 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate2 type;


 FastDelegate2() { clear(); }
 FastDelegate2(const FastDelegate2 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate2 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate2 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate2 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate2 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate2 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate2(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate2(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate2(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2)) {
  m_Closure.bindstaticfunc(this, &FastDelegate2::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2); }
};


template<class Param1, class Param2, class Param3, class RetType=detail::DefaultVoid>
class FastDelegate3 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate3 type;


 FastDelegate3() { clear(); }
 FastDelegate3(const FastDelegate3 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate3 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate3 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate3 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate3 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate3 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate3(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate3(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate3(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
  m_Closure.bindstaticfunc(this, &FastDelegate3::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3); }
};


template<class Param1, class Param2, class Param3, class Param4, class RetType=detail::DefaultVoid>
class FastDelegate4 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate4 type;


 FastDelegate4() { clear(); }
 FastDelegate4(const FastDelegate4 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate4 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate4 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate4 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate4 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate4 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate4(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate4(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate4(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
  m_Closure.bindstaticfunc(this, &FastDelegate4::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class RetType=detail::DefaultVoid>
class FastDelegate5 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate5 type;


 FastDelegate5() { clear(); }
 FastDelegate5(const FastDelegate5 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate5 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate5 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate5 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate5 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate5 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate5(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate5(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate5(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
  m_Closure.bindstaticfunc(this, &FastDelegate5::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType=detail::DefaultVoid>
class FastDelegate6 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate6 type;


 FastDelegate6() { clear(); }
 FastDelegate6(const FastDelegate6 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate6 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate6 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate6 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate6 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate6 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate6(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate6(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate6(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
  m_Closure.bindstaticfunc(this, &FastDelegate6::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType=detail::DefaultVoid>
class FastDelegate7 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate7 type;


 FastDelegate7() { clear(); }
 FastDelegate7(const FastDelegate7 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate7 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate7 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate7 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate7 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate7 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate7(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate7(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate7(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
  m_Closure.bindstaticfunc(this, &FastDelegate7::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType=detail::DefaultVoid>
class FastDelegate8 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate8 type;


 FastDelegate8() { clear(); }
 FastDelegate8(const FastDelegate8 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate8 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate8 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate8 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate8 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate8 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate8(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate8(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate8(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
  m_Closure.bindstaticfunc(this, &FastDelegate8::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class RetType=detail::DefaultVoid>
class FastDelegate9 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate9 type;


 FastDelegate9() { clear(); }
 FastDelegate9(const FastDelegate9 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate9 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate9 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate9 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate9 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate9 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate9(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate9(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate9(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9)) {
  m_Closure.bindstaticfunc(this, &FastDelegate9::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class RetType=detail::DefaultVoid>
class FastDelegate10 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate10 type;


 FastDelegate10() { clear(); }
 FastDelegate10(const FastDelegate10 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate10 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate10 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate10 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate10 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate10 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate10(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate10(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate10(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10)) {
  m_Closure.bindstaticfunc(this, &FastDelegate10::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class RetType=detail::DefaultVoid>
class FastDelegate11 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate11 type;


 FastDelegate11() { clear(); }
 FastDelegate11(const FastDelegate11 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate11 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate11 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate11 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate11 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate11 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate11(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate11(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate11(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11)) {
  m_Closure.bindstaticfunc(this, &FastDelegate11::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class RetType=detail::DefaultVoid>
class FastDelegate12 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate12 type;


 FastDelegate12() { clear(); }
 FastDelegate12(const FastDelegate12 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate12 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate12 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate12 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate12 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate12 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate12(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate12(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate12(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12)) {
  m_Closure.bindstaticfunc(this, &FastDelegate12::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class RetType=detail::DefaultVoid>
class FastDelegate13 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate13 type;


 FastDelegate13() { clear(); }
 FastDelegate13(const FastDelegate13 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate13 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate13 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate13 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate13 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate13 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate13(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate13(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate13(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13)) {
  m_Closure.bindstaticfunc(this, &FastDelegate13::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class RetType=detail::DefaultVoid>
class FastDelegate14 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate14 type;


 FastDelegate14() { clear(); }
 FastDelegate14(const FastDelegate14 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate14 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate14 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate14 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate14 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate14 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate14(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate14(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate14(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14)) {
  m_Closure.bindstaticfunc(this, &FastDelegate14::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class RetType=detail::DefaultVoid>
class FastDelegate15 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate15 type;


 FastDelegate15() { clear(); }
 FastDelegate15(const FastDelegate15 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate15 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate15 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate15 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate15 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate15 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate15(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate15(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate15(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15)) {
  m_Closure.bindstaticfunc(this, &FastDelegate15::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class RetType=detail::DefaultVoid>
class FastDelegate16 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate16 type;


 FastDelegate16() { clear(); }
 FastDelegate16(const FastDelegate16 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate16 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate16 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate16 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate16 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate16 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate16(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate16(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate16(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16)) {
  m_Closure.bindstaticfunc(this, &FastDelegate16::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); }
};


template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17, class RetType=detail::DefaultVoid>
class FastDelegate17 {
private:
 typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
 typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17);
 typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17);
 typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17);
 typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
 ClosureType m_Closure;
public:

 typedef FastDelegate17 type;


 FastDelegate17() { clear(); }
 FastDelegate17(const FastDelegate17 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 void operator = (const FastDelegate17 &x) {
  m_Closure.CopyFrom(this, x.m_Closure); }
 bool operator ==(const FastDelegate17 &x) const {
  return m_Closure.IsEqual(x.m_Closure); }
 bool operator !=(const FastDelegate17 &x) const {
  return !m_Closure.IsEqual(x.m_Closure); }
 bool operator <(const FastDelegate17 &x) const {
  return m_Closure.IsLess(x.m_Closure); }
 bool operator >(const FastDelegate17 &x) const {
  return x.m_Closure.IsLess(m_Closure); }

 template < class X, class Y >
 FastDelegate17(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) ) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17)) {
  m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

 template < class X, class Y >
 FastDelegate17(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind); }
 template < class X, class Y >
 inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const) {
  m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind); }


 FastDelegate17(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) ) {
  bind(function_to_bind); }

 void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) ) {
  bind(function_to_bind); }
 inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17)) {
  m_Closure.bindstaticfunc(this, &FastDelegate17::InvokeStaticFunction,
   function_to_bind); }

 RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const {
 return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); }

private:
 typedef struct SafeBoolStruct {
  int a_data_pointer_to_this_is_0_on_buggy_compilers;
  StaticFunctionPtr m_nonzero;
 } UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
 operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }

 inline bool operator==(StaticFunctionPtr funcptr) {
  return m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator!=(StaticFunctionPtr funcptr) {
  return !m_Closure.IsEqualToStaticFuncPtr(funcptr); }
 inline bool operator ! () const {
   return !m_Closure; }
 inline bool empty() const {
   return !m_Closure; }
 void clear() { m_Closure.clear();}

 const DelegateMemento & GetMemento() { return m_Closure; }
 void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }

private:
 RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const {
 return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); }
};
template <typename Signature>
class FastDelegate;






template<typename R>
class FastDelegate< R ( ) >

  : public FastDelegate0 < R >
{
public:

  typedef FastDelegate0 < R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1>
class FastDelegate< R ( Param1 ) >

  : public FastDelegate1 < Param1, R >
{
public:

  typedef FastDelegate1 < Param1, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2>
class FastDelegate< R ( Param1, Param2 ) >

  : public FastDelegate2 < Param1, Param2, R >
{
public:

  typedef FastDelegate2 < Param1, Param2, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3>
class FastDelegate< R ( Param1, Param2, Param3 ) >

  : public FastDelegate3 < Param1, Param2, Param3, R >
{
public:

  typedef FastDelegate3 < Param1, Param2, Param3, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4>
class FastDelegate< R ( Param1, Param2, Param3, Param4 ) >

  : public FastDelegate4 < Param1, Param2, Param3, Param4, R >
{
public:

  typedef FastDelegate4 < Param1, Param2, Param3, Param4, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5 ) >

  : public FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
{
public:

  typedef FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >

  : public FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
{
public:

  typedef FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >

  : public FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
{
public:

  typedef FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >

  : public FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
{
public:

  typedef FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9 ) >

  : public FastDelegate9 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, R >
{
public:

  typedef FastDelegate9 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10 ) >

  : public FastDelegate10 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, R >
{
public:

  typedef FastDelegate10 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11 ) >

  : public FastDelegate11 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, R >
{
public:

  typedef FastDelegate11 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12 ) >

  : public FastDelegate12 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, R >
{
public:

  typedef FastDelegate12 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13 ) >

  : public FastDelegate13 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, R >
{
public:

  typedef FastDelegate13 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14 ) >

  : public FastDelegate14 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, R >
{
public:

  typedef FastDelegate14 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15 ) >

  : public FastDelegate15 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, R >
{
public:

  typedef FastDelegate15 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16 ) >

  : public FastDelegate16 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, R >
{
public:

  typedef FastDelegate16 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};






template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17 ) >

  : public FastDelegate17 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, R >
{
public:

  typedef FastDelegate17 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, R > BaseType;


  typedef FastDelegate SelfType;


  FastDelegate() : BaseType() { }

  template < class X, class Y >
  FastDelegate(Y * pthis,
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17 ))
    : BaseType(pthis, function_to_bind) { }

  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17 ) const)
    : BaseType(pthis, function_to_bind)
  { }

  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17 ))
    : BaseType(function_to_bind) { }
  void operator = (const BaseType &x) {
  *static_cast<BaseType*>(this) = x; }
};
template <class X, class Y, class RetType>
FastDelegate0<RetType> MakeDelegate(Y* x, RetType (X::*func)()) {
 return FastDelegate0<RetType>(x, func);
}

template <class X, class Y, class RetType>
FastDelegate0<RetType> MakeDelegate(Y* x, RetType (X::*func)() const) {
 return FastDelegate0<RetType>(x, func);
}

template <class RetType>
FastDelegate0<RetType> MakeDelegate(RetType (*func)()) {
 return FastDelegate0<RetType>(func);
}


template <class X, class Y, class Param1, class RetType>
FastDelegate1<Param1, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1)) {
 return FastDelegate1<Param1, RetType>(x, func);
}

template <class X, class Y, class Param1, class RetType>
FastDelegate1<Param1, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1) const) {
 return FastDelegate1<Param1, RetType>(x, func);
}

template <class Param1, class RetType>
FastDelegate1<Param1, RetType> MakeDelegate(RetType (*func)(Param1 p1)) {
 return FastDelegate1<Param1, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class RetType>
FastDelegate2<Param1, Param2, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) {
 return FastDelegate2<Param1, Param2, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class RetType>
FastDelegate2<Param1, Param2, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2) const) {
 return FastDelegate2<Param1, Param2, RetType>(x, func);
}

template <class Param1, class Param2, class RetType>
FastDelegate2<Param1, Param2, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2)) {
 return FastDelegate2<Param1, Param2, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
FastDelegate3<Param1, Param2, Param3, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3)) {
 return FastDelegate3<Param1, Param2, Param3, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
FastDelegate3<Param1, Param2, Param3, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3) const) {
 return FastDelegate3<Param1, Param2, Param3, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class RetType>
FastDelegate3<Param1, Param2, Param3, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3)) {
 return FastDelegate3<Param1, Param2, Param3, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
FastDelegate4<Param1, Param2, Param3, Param4, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
 return FastDelegate4<Param1, Param2, Param3, Param4, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
FastDelegate4<Param1, Param2, Param3, Param4, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
 return FastDelegate4<Param1, Param2, Param3, Param4, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class RetType>
FastDelegate4<Param1, Param2, Param3, Param4, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
 return FastDelegate4<Param1, Param2, Param3, Param4, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
FastDelegate5<Param1, Param2, Param3, Param4, Param5, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
 return FastDelegate5<Param1, Param2, Param3, Param4, Param5, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
FastDelegate5<Param1, Param2, Param3, Param4, Param5, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
 return FastDelegate5<Param1, Param2, Param3, Param4, Param5, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
FastDelegate5<Param1, Param2, Param3, Param4, Param5, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
 return FastDelegate5<Param1, Param2, Param3, Param4, Param5, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
 return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
 return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
 return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
 return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
 return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
 return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
 return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
 return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
 return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class RetType>
FastDelegate9<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9)) {
 return FastDelegate9<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class RetType>
FastDelegate9<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const) {
 return FastDelegate9<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class RetType>
FastDelegate9<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9)) {
 return FastDelegate9<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class RetType>
FastDelegate10<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10)) {
 return FastDelegate10<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class RetType>
FastDelegate10<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const) {
 return FastDelegate10<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class RetType>
FastDelegate10<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10)) {
 return FastDelegate10<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class RetType>
FastDelegate11<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11)) {
 return FastDelegate11<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class RetType>
FastDelegate11<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const) {
 return FastDelegate11<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class RetType>
FastDelegate11<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11)) {
 return FastDelegate11<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class RetType>
FastDelegate12<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12)) {
 return FastDelegate12<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class RetType>
FastDelegate12<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const) {
 return FastDelegate12<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class RetType>
FastDelegate12<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12)) {
 return FastDelegate12<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class RetType>
FastDelegate13<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13)) {
 return FastDelegate13<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class RetType>
FastDelegate13<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const) {
 return FastDelegate13<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class RetType>
FastDelegate13<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13)) {
 return FastDelegate13<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class RetType>
FastDelegate14<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14)) {
 return FastDelegate14<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class RetType>
FastDelegate14<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const) {
 return FastDelegate14<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class RetType>
FastDelegate14<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14)) {
 return FastDelegate14<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class RetType>
FastDelegate15<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15)) {
 return FastDelegate15<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class RetType>
FastDelegate15<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const) {
 return FastDelegate15<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class RetType>
FastDelegate15<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15)) {
 return FastDelegate15<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class RetType>
FastDelegate16<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16)) {
 return FastDelegate16<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class RetType>
FastDelegate16<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const) {
 return FastDelegate16<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class RetType>
FastDelegate16<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16)) {
 return FastDelegate16<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, RetType>(func);
}


template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17, class RetType>
FastDelegate17<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17)) {
 return FastDelegate17<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, RetType>(x, func);
}

template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17, class RetType>
FastDelegate17<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, RetType> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const) {
 return FastDelegate17<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, RetType>(x, func);
}

template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17, class RetType>
FastDelegate17<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, RetType> MakeDelegate(RetType (*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17)) {
 return FastDelegate17<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, RetType>(func);
}





}





enum META_RES
{
 MRES_IGNORED=0,
 MRES_HANDLED,
 MRES_OVERRIDE,
 MRES_SUPERCEDE
};


namespace SourceHook
{



 const int STRBUF_LEN=4096;




 class EmptyClass
 {
 };




 template <class In, class Out>
  inline Out implicit_cast(In input)
  {
   return input;
  }
 typedef int Plugin;


 template <class T> class CallClass : public T
 {
 };
 typedef void ManualCallClass;




 struct PassInfo
 {
  enum PassType
  {
   PassType_Unknown=0,
   PassType_Basic,
   PassType_Float,
   PassType_Object,
  };

  enum PassFlags
  {
   PassFlag_ByVal = (1<<0),
   PassFlag_ByRef = (1<<1),
   PassFlag_ODtor = (1<<2),
   PassFlag_OCtor = (1<<3),
   PassFlag_AssignOp = (1<<4),
   PassFlag_CCtor = (1<<5),




   PassFlag_RetMem = (1<<6),
   PassFlag_RetReg = (1<<7)
  };

  size_t size;



  int type;
  unsigned int flags;

  struct V2Info
  {
   void *pNormalCtor;
   void *pCopyCtor;
   void *pDtor;
   void *pAssignOperator;
  };
 };

 struct ProtoInfo
 {
  enum CallConvention
  {
   CallConv_Unknown,
   CallConv_ThisCall,
   CallConv_Cdecl,
   CallConv_StdCall,

   CallConv_HasVarArgs = (1<<16),
   CallConv_HasVafmt = CallConv_HasVarArgs | (1<<17)
  };

  int numOfParams;
  PassInfo retPassInfo;
  const PassInfo *paramsPassInfo;





  int convention;


  PassInfo::V2Info retPassInfo2;
  const PassInfo::V2Info *paramsPassInfo2;
 };

 struct IHookManagerInfo;
 typedef int (*HookManagerPubFunc)(bool store, IHookManagerInfo *hi);

 class ISHDelegate
 {
 public:
  virtual bool IsEqual(ISHDelegate *pOtherDeleg) = 0;
  virtual void DeleteThis() = 0;
 };

 struct IHookManagerInfo
 {
  virtual void SetInfo(int hookman_version, int vtbloffs, int vtblidx,
   ProtoInfo *proto, void *hookfunc_vfnptr) = 0;
 };
 template <class T> struct ReferenceCarrier
 {
  typedef T type;
 };

 template <class T> struct ReferenceCarrier<T&>
 {
  class type
  {
   T *m_StoredRef;
  public:
   type() : m_StoredRef(
                       __null
                           )
   {
   }
   type(T& ref) : m_StoredRef(&ref)
   {
   }

   T& operator= (T& ref)
   {
    m_StoredRef = &ref;
    return ref;
   }

   operator T& () const
   {
    return *m_StoredRef;
   }
  };
 };

 template <class T> struct ReferenceUtil
 {
  typedef T plain_type;
  typedef T* pointer_type;
  typedef T& reference_type;
 };

 template <class T> struct ReferenceUtil<T&>
 {
  typedef T plain_type;
  typedef T* pointer_type;
  typedef T& reference_type;
 };

 struct IHookContext
 {
  virtual ISHDelegate *GetNext() = 0;
  virtual void *GetOverrideRetPtr() = 0;
  virtual const void *GetOrigRetPtr() = 0;
  virtual bool ShouldCallOrig() = 0;
 };




 class ISourceHook
 {
 public:



  virtual int GetIfaceVersion() = 0;




  virtual int GetImplVersion() = 0;




  enum AddHookMode
  {
   Hook_Normal,
   Hook_VP,
   Hook_DVP
  };
  virtual int AddHook(Plugin plug, AddHookMode mode, void *iface, int thisptr_offs, HookManagerPubFunc myHookMan,
   ISHDelegate *handler, bool post) = 0;


  virtual bool RemoveHook(Plugin plug, void *iface, int thisptr_offs, HookManagerPubFunc myHookMan,
   ISHDelegate *handler, bool post) = 0;
  virtual bool RemoveHookByID(int hookid) = 0;
  virtual bool PauseHookByID(int hookid) = 0;
  virtual bool UnpauseHookByID(int hookid) = 0;







  virtual void SetRes(META_RES res) = 0;
  virtual META_RES GetPrevRes() = 0;

  virtual META_RES GetStatus() = 0;
  virtual const void *GetOrigRet() = 0;

  virtual const void *GetOverrideRet() = 0;

  virtual void *GetIfacePtr() = 0;

  virtual void *GetOverrideRetPtr() = 0;







  virtual void RemoveHookManager(Plugin plug, HookManagerPubFunc pubFunc) = 0;
  virtual void SetIgnoreHooks(void *vfnptr) = 0;







  virtual void ResetIgnoreHooks(void *vfnptr) = 0;







  virtual void *GetOrigVfnPtrEntry(void *vfnptr) = 0;






  virtual void DoRecall() = 0;
  virtual IHookContext *SetupHookLoop(IHookManagerInfo *hi, void *vfnptr, void *thisptr, void **origCallAddr,
   META_RES *statusPtr, META_RES *prevResPtr, META_RES *curResPtr,
   const void *origRetPtr, void *overrideRetPtr) = 0;

  virtual void EndContext(IHookContext *pCtx) = 0;
 };


 class IHookManagerAutoGen
 {
 public:
  virtual int GetIfaceVersion() = 0;
  virtual int GetImplVersion() = 0;

  virtual HookManagerPubFunc MakeHookMan(const ProtoInfo *proto, int vtbl_offs, int vtbl_idx) = 0;
  virtual void ReleaseHookMan(HookManagerPubFunc pubFunc) = 0;
 };




 template <class T> struct MacroRefHelpers
 {
  inline static const T* GetOrigRet(ISourceHook *shptr)
  {
   return reinterpret_cast<const T*>(shptr->GetOrigRet());
  }
  inline static const T* GetOverrideRet(ISourceHook *shptr)
  {
   return reinterpret_cast<const T*>(shptr->GetOverrideRet());
  }
 };

 template <class T> struct MacroRefHelpers<T&>
 {
  inline static T* GetOrigRet(ISourceHook *shptr)
  {
   T &ref = *reinterpret_cast<const typename ReferenceCarrier<T&>::type *>(shptr->GetOrigRet());
   return &ref;
  }
  inline static T* GetOverrideRet(ISourceHook *shptr)
  {
   T &ref = *reinterpret_cast<const typename ReferenceCarrier<T&>::type *>(shptr->GetOverrideRet());
   return &ref;
  }
 };

 template <class X, class MFP>
  void *GetOrigVfnPtrEntry(X *pInstance, MFP mfp, ISourceHook *pSH)
 {
  SourceHook::MemFuncInfo info = {true, -1, 0, 0};
  SourceHook::GetFuncInfo(pInstance, mfp, info);

  void *vfnptr = reinterpret_cast<void*>(
   *reinterpret_cast<void***>(reinterpret_cast<char*>(pInstance) + info.thisptroffs + info.vtbloffs) + info.vtblindex);

  void *origentry = pSH->GetOrigVfnPtrEntry(vfnptr);

  return origentry ? origentry : *reinterpret_cast<void**>(vfnptr);
 }

 template <class T> struct GetPassInfo
 {
  static const int type = 0;
  static const unsigned int flags = PassInfo::PassFlag_ByVal;
 };

 template <class T> struct GetPassInfo<T&>
 {
  static const int type = 0;
  static const unsigned int flags = PassInfo::PassFlag_ByRef;
 };
}
template<class T>
SourceHook::CallClass<T> *SH_GET_CALLCLASS(T *p)
{
 return static_cast< SourceHook::CallClass<T> *>(p);
}
namespace SourceHook
{


 template<class ObjType, class MFPType, class RetType> class ExecutableClass0
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass0(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()() const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param1> RetType operator()(Param1 p1) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2> RetType operator()(Param1 p1, Param2 p2) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3> RetType operator()(Param1 p1, Param2 p2, Param3 p3) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType> class ExecutableClass0<ObjType, MFPType, void>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass0(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()() const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param1> void operator()(Param1 p1) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2> void operator()(Param1 p1, Param2 p2) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3> void operator()(Param1 p1, Param2 p2, Param3 p3) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1> class ExecutableClass1
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass1(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param2> RetType operator()(Param1 p1, Param2 p2) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3> RetType operator()(Param1 p1, Param2 p2, Param3 p3) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1> class ExecutableClass1<ObjType, MFPType, void, Param1>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass1(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param2> void operator()(Param1 p1, Param2 p2) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3> void operator()(Param1 p1, Param2 p2, Param3 p3) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2> class ExecutableClass2
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass2(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param3> RetType operator()(Param1 p1, Param2 p2, Param3 p3) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2> class ExecutableClass2<ObjType, MFPType, void, Param1, Param2>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass2(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param3> void operator()(Param1 p1, Param2 p2, Param3 p3) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3> class ExecutableClass3
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass3(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param4> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3> class ExecutableClass3<ObjType, MFPType, void, Param1, Param2, Param3>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass3(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param4> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4> class ExecutableClass4
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass4(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param5> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4> class ExecutableClass4<ObjType, MFPType, void, Param1, Param2, Param3, Param4>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass4(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param5> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5> class ExecutableClass5
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass5(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param6> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5> class ExecutableClass5<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass5(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param6> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6> class ExecutableClass6
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass6(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param7> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6> class ExecutableClass6<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass6(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param7> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7> class ExecutableClass7
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass7(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param8> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7> class ExecutableClass7<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass7(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param8> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> class ExecutableClass8
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass8(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param9> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8> class ExecutableClass8<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass8(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param9> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> class ExecutableClass9
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass9(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param10> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9> class ExecutableClass9<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass9(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param10> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> class ExecutableClass10
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass10(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param11> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param11, class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param11, class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param11, class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param11, class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10> class ExecutableClass10<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass10(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param11> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param11, class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param11, class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param11, class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param11, class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> class ExecutableClass11
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass11(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param12> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param12, class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param12, class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param12, class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param12, class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11> class ExecutableClass11<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass11(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param12> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param12, class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param12, class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param12, class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param12, class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> class ExecutableClass12
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass12(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param13> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param13, class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param13, class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param13, class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param13, class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12> class ExecutableClass12<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass12(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param13> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param13, class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param13, class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param13, class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param13, class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> class ExecutableClass13
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass13(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param14> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param14, class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param14, class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param14, class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13> class ExecutableClass13<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass13(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param14> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param14, class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param14, class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param14, class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> class ExecutableClass14
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass14(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param15> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param15, class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param15, class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14> class ExecutableClass14<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass14(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param15> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param15, class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param15, class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> class ExecutableClass15
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass15(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }


  template <class Param16> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param16, class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15> class ExecutableClass15<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass15(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


    template <class Param16> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param16, class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> class ExecutableClass16
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass16(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

  template <class Param17> RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }

 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16> class ExecutableClass16<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass16(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16); m_pSH->ResetIgnoreHooks(m_VfnPtr); }

    template <class Param17> void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }


 };


 template<class ObjType, class MFPType, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> class ExecutableClass17
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass17(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

  RetType operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
   { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); RetType tmpret = (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); return tmpret; }
 };

 template<class ObjType, class MFPType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17> class ExecutableClass17<ObjType, MFPType, void, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>
 {
  ObjType *m_ThisPtr;
  void *m_VfnPtr;
  MFPType m_MFP;
  ISourceHook *m_pSH;
 public:
  ExecutableClass17(ObjType *tp, MFPType mfp, void *vp, ISourceHook *pSH) : m_ThisPtr(tp),
   m_VfnPtr(vp), m_MFP(mfp), m_pSH(pSH) { }

    void operator()(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8, Param9 p9, Param10 p10, Param11 p11, Param12 p12, Param13 p13, Param14 p14, Param15 p15, Param16 p16, Param17 p17) const
       { using namespace ::SourceHook; m_pSH->SetIgnoreHooks(m_VfnPtr); (m_ThisPtr->*m_MFP)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17); m_pSH->ResetIgnoreHooks(m_VfnPtr); }
 };
}
template <class X, class Y, class MFP, class RetType>
SourceHook::ExecutableClass0<Y, MFP, RetType>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass0<Y, MFP, RetType>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType>
SourceHook::ExecutableClass0<Y, MFP, RetType>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)()const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass0<Y, MFP, RetType>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType>
SourceHook::ExecutableClass0<SourceHook::EmptyClass, MFP, RetType>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass0<EmptyClass, MFP, RetType>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1>
SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1>
SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1>
SourceHook::ExecutableClass1<SourceHook::EmptyClass, MFP, RetType, Param1>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass1<EmptyClass, MFP, RetType, Param1>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2>
SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2>
SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2>
SourceHook::ExecutableClass2<SourceHook::EmptyClass, MFP, RetType, Param1, Param2>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass2<EmptyClass, MFP, RetType, Param1, Param2>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3>
SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3>
SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3>
SourceHook::ExecutableClass3<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass3<EmptyClass, MFP, RetType, Param1, Param2, Param3>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4>
SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4>
SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4>
SourceHook::ExecutableClass4<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass4<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
SourceHook::ExecutableClass5<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass5<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
SourceHook::ExecutableClass6<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass6<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
SourceHook::ExecutableClass7<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass7<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
SourceHook::ExecutableClass8<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass8<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
SourceHook::ExecutableClass9<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass9<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
SourceHook::ExecutableClass10<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass10<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
SourceHook::ExecutableClass11<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass11<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
SourceHook::ExecutableClass12<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass12<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
SourceHook::ExecutableClass13<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass13<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
SourceHook::ExecutableClass14<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass14<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
SourceHook::ExecutableClass15<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass15<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
SourceHook::ExecutableClass16<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass16<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
SourceHook::ExecutableClass17<SourceHook::EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>
SH_MCALL3(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17), int vtblidx, int vtbloffs, int thisptroffs, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>( (reinterpret_cast<char*>(ptr) + thisptroffs + vtbloffs) ) + vtblidx); *reinterpret_cast<void**>(&mfp) = *reinterpret_cast<void**>(vfnptr);
 return SourceHook::ExecutableClass17<EmptyClass, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>(
  reinterpret_cast<SourceHook::EmptyClass*>(ptr), mfp, vfnptr, shptr);
}







template <class X, class Y, class MFP, class RetType>
SourceHook::ExecutableClass0<Y, MFP, RetType>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass0<Y, MFP, RetType>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType>
SourceHook::ExecutableClass0<Y, MFP, RetType>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass0<Y, MFP, RetType>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1>
SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1>
SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass1<Y, MFP, RetType, Param1>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2>
SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2>
SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass2<Y, MFP, RetType, Param1, Param2>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3>
SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3>
SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass3<Y, MFP, RetType, Param1, Param2, Param3>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4>
SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4>
SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass4<Y, MFP, RetType, Param1, Param2, Param3, Param4>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass5<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass6<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass7<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass8<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass9<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass10<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass11<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass12<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass13<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass14<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass15<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15>(ptr, mfp, vfnptr, shptr);
}



template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass16<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16>(ptr, mfp, vfnptr, shptr);
}


template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...), SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>(ptr, mfp, vfnptr, shptr);
}

template <class X, class Y, class MFP, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>
SH_CALL2(Y *ptr, MFP mfp, RetType(X::*mfp2)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...)const, SourceHook::ISourceHook *shptr)
{
 using namespace ::SourceHook; MemFuncInfo mfi = {true, -1, 0, 0}; GetFuncInfo(ptr, mfp, mfi); void *vfnptr = reinterpret_cast<void*>( *reinterpret_cast<void***>(reinterpret_cast<char*>(ptr) + mfi.thisptroffs + mfi.vtbloffs) + mfi.vtblindex);
 return SourceHook::ExecutableClass17<Y, MFP, RetType, Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17>(ptr, mfp, vfnptr, shptr);
}
namespace SourceHook
{
 template <class T> struct OverrideFunctor
 {
  void operator()(ISourceHook *shptr, T res)
  {
   *reinterpret_cast<T*>(shptr->GetOverrideRetPtr()) = res;
  }
 };
 template <class T> struct OverrideFunctor<T&>
 {
  void operator()(ISourceHook *shptr, T &res)
  {

   *reinterpret_cast<typename ReferenceCarrier<T&>::type *>(shptr->GetOverrideRetPtr()) = res;
  }
 };



 template <class RetType>
 OverrideFunctor<RetType> SetOverrideResult()
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)())
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)())
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
 OverrideFunctor<RetType> SetOverrideResult(RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...))
 {
  return OverrideFunctor<RetType>();
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

 template <class Iface, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class Param9, class Param10, class Param11, class Param12, class Param13, class Param14, class Param15, class Param16, class Param17>
 Iface *RecallGetIface(ISourceHook *shptr, RetType (Iface::*mfp)(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, Param9, Param10, Param11, Param12, Param13, Param14, Param15, Param16, Param17, ...))
 {
  return reinterpret_cast<Iface*>(shptr->GetIfacePtr());
 }

}
namespace SourceMM
{
 class ISmmPlugin;
 class ISmmAPI;




 typedef int PluginId;
 class ISmmFailPlugin
 {
 public:




  virtual int GetApiVersion() = 0;




  virtual ~ISmmFailPlugin()
  {
  }
  virtual bool Load(PluginId id, ISmmAPI *ismm, char *error, size_t maxlength, bool late) =0;
 };
}

typedef SourceMM::ISmmPlugin METAMOD_PLUGIN;




struct MetamodVersionInfo
{
 int api_major;
 int api_minor;
 int sh_iface;
 int sh_impl;
 int pl_min;
 int pl_max;
 int source_engine;
 const char *game_dir;







 inline const char *GetGameDir() const
 {
  if (pl_max < 15)
   return 
         __null
             ;
  return game_dir;
 }
};




struct MetamodLoaderInfo
{
 const char *pl_file;
 const char *pl_path;
};
typedef METAMOD_PLUGIN *(*METAMOD_FN_LOAD)(const MetamodVersionInfo *mvi,
             const MetamodLoaderInfo *mli);
typedef void (*METAMOD_FN_UNLOAD)();






typedef void *(*METAMOD_FN_ORIG_LOAD)(const char *, int *);

namespace SourceMM
{



 enum
 {
  Pl_BadLoad=0,
  Pl_Console=-1,
  Pl_File=-2,
  Pl_MinId=1,
 };




 enum Pl_Status
 {
  Pl_NotFound=-4,
  Pl_Error=-3,
  Pl_Refused=-2,
  Pl_Paused=-1,
  Pl_Running=0,
 };




 class ISmmPluginManager
 {
 public:
  virtual PluginId Load(const char *file, PluginId source, bool &already, char *error, size_t maxlen) =0;
  virtual bool Unload(PluginId id, bool force, char *error, size_t maxlen) =0;
  virtual bool Pause(PluginId id, char *error, size_t maxlen) =0;
  virtual bool Unpause(PluginId id, char *error, size_t maxlen) =0;






  virtual bool UnloadAll() =0;
  virtual bool Query(PluginId id, const char **file, Pl_Status *status, PluginId *source) =0;
  virtual bool QueryRunning(PluginId id, char *error, size_t maxlength) =0;
  virtual bool QueryHandle(PluginId id, void **handle) =0;
 };
}


using namespace SourceMM;
typedef char char8;




typedef unsigned char uint8;
typedef unsigned char BYTE;
typedef unsigned char byte;




typedef wchar_t wchar;
typedef char tchar;


extern "C" {





extern void *alloca (size_t __size) throw ();





}





extern "C" {


extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));


extern void *calloc (size_t __nmemb, size_t __size)
throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
throw () __attribute__ ((__warn_unused_result__));


extern void free (void *__ptr) throw ();


extern void cfree (void *__ptr) throw ();


extern void *memalign (size_t __alignment, size_t __size)
throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));


extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));



extern void *pvalloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));



extern void *(*__morecore) (ptrdiff_t __size);


extern void *__default_morecore (ptrdiff_t __size)
throw () __attribute__ ((__malloc__));



struct mallinfo
{
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};


extern struct mallinfo mallinfo (void) throw ();
extern int mallopt (int __param, int __val) throw ();



extern int malloc_trim (size_t __pad) throw ();



extern size_t malloc_usable_size (void *__ptr) throw ();


extern void malloc_stats (void) throw ();


extern int malloc_info (int __options, FILE *__fp) throw ();


extern void *malloc_get_state (void) throw ();



extern int malloc_set_state (void *__ptr) throw ();




extern void (*volatile __malloc_initialize_hook) (void)
__attribute__ ((__deprecated__));

extern void (*volatile __free_hook) (void *__ptr,
                                                   const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __malloc_hook)(size_t __size,
                                                     const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __realloc_hook)(void *__ptr,
                                                      size_t __size,
                                                      const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __memalign_hook)(size_t __alignment,
                                                       size_t __size,
                                                       const void *)
__attribute__ ((__deprecated__));
extern void (*volatile __after_morecore_hook) (void);


extern void __malloc_check_init (void) throw () __attribute__ ((__deprecated__));


}




       

namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;




}
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}


       

#pragma GCC visibility push(default)


       

extern "C++" {

namespace std
{
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();
  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();
  void unexpected() __attribute__ ((__noreturn__));
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };
  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();





}
void* operator new(std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void operator delete(void*) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*) throw()
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) throw()
{ return __p; }
inline void* operator new[](std::size_t, void* __p) throw()
{ return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop

typedef unsigned char uint8;
typedef signed char int8;
typedef short int16;
typedef unsigned short uint16;
typedef int int32;
typedef unsigned int uint32;
typedef long long int64;
typedef unsigned long long uint64;




typedef int intp;
typedef unsigned int uintp;





typedef float float32;
typedef double float64;


typedef unsigned int uint;







typedef unsigned int DWORD;
typedef unsigned short WORD;
typedef void * HINSTANCE;
static inline float fsel(float fComparand, float fValGE, float fLT)
{
 return fComparand >= 0 ? fValGE : fLT;
}
static inline double fsel(double fComparand, double fValGE, double fLT)
{
 return fComparand >= 0 ? fValGE : fLT;
}
inline void SetupFPUControlWord()
{
 __volatile unsigned short int __cw;
 __asm __volatile ("fnstcw %0" : "=m" (__cw));
 __cw = __cw & 0x0FCC0;
 __cw = __cw | 0x023F;
 __asm __volatile ("fldcw %0" : : "m" (__cw));
}
template <typename T>
inline T WordSwapC( T w )
{
   uint16 temp;

   temp = ((*((uint16 *)&w) & 0xff00) >> 8);
   temp |= ((*((uint16 *)&w) & 0x00ff) << 8);

   return *((T*)&temp);
}

template <typename T>
inline T DWordSwapC( T dw )
{
   uint32 temp;

   temp = *((uint32 *)&dw) >> 24;
   temp |= ((*((uint32 *)&dw) & 0x00FF0000) >> 8);
   temp |= ((*((uint32 *)&dw) & 0x0000FF00) << 8);
   temp |= ((*((uint32 *)&dw) & 0x000000FF) << 24);

   return *((T*)&temp);
}
inline unsigned long LoadLittleDWord( unsigned long *base, unsigned int dwordIndex )
{
 return ( base[dwordIndex] );
}

inline void StoreLittleDWord( unsigned long *base, unsigned int dwordIndex, unsigned long dword )
{
 base[dwordIndex] = ( dword );
}
extern "C" void Plat_SetBenchmarkMode( bool bBenchmarkMode );
extern "C" bool Plat_IsInBenchmarkMode();


extern "C" double Plat_FloatTime();
extern "C" unsigned long Plat_MSTime();






struct CPUInformation
{
 int m_Size;

 bool m_bRDTSC : 1,
   m_bCMOV : 1,
   m_bFCMOV : 1,
   m_bSSE : 1,
   m_bSSE2 : 1,
   m_b3DNow : 1,
   m_bMMX : 1,
   m_bHT : 1;

 uint8 m_nLogicalProcessors;
 uint8 m_nPhysicalProcessors;

 int64 m_Speed;

 tchar* m_szProcessorID;
};







extern "C" const CPUInformation& GetCPUInformation();





extern "C" void GetCurrentDate( int *pDay, int *pMonth, int *pYear );




extern "C" void InitPME();
extern "C" void ShutdownPME();






extern "C" unsigned long Plat_RegisterThread( const tchar *pName = "Source Thread");


extern "C" unsigned long Plat_RegisterPrimaryThread();



extern "C" void Plat_SetThreadName( unsigned long dwThreadID, const tchar *pName );




extern "C" unsigned long Plat_PrimaryThreadID;


extern "C" unsigned long Plat_GetCurrentThreadID();


inline unsigned long Plat_GetPrimaryThreadID()
{
 return Plat_PrimaryThreadID;
}


inline bool Plat_IsPrimaryThread()
{

 return (Plat_GetPrimaryThreadID() == Plat_GetCurrentThreadID() );
}




extern "C" const tchar *Plat_GetCommandLine();


extern "C" void Plat_SetCommandLine( const char *cmdLine );

extern "C" const char *Plat_GetCommandLineA();





extern "C" bool Plat_VerifyHardwareKeyDriver();




extern "C" bool Plat_VerifyHardwareKey();



extern "C" bool Plat_VerifyHardwareKeyPrompt();





extern "C" bool Plat_FastVerifyHardwareKey();




extern "C" void* Plat_SimpleLog( const tchar* file, int line );
inline const char *GetPlatformExt( void )
{
 return false ? ".360" : "";
}

extern "C" int64 g_ClockSpeed;
extern "C" unsigned long g_dwClockSpeed;




extern "C" double g_ClockSpeedMicrosecondsMultiplier;
extern "C" double g_ClockSpeedMillisecondsMultiplier;
extern "C" double g_ClockSpeedSecondsMultiplier;

class CCycleCount
{
friend class CFastTimer;

public:
     CCycleCount();
     CCycleCount( int64 cycles );

 void Sample();

 void Init();
 void Init( float initTimeMsec );
 void Init( double initTimeMsec ) { Init( (float)initTimeMsec ); }
 void Init( int64 cycles );
 bool IsLessThan( CCycleCount const &other ) const;



 unsigned long GetCycles() const;
 int64 GetLongCycles() const;

 unsigned long GetMicroseconds() const;
 uint64 GetUlMicroseconds() const;
 double GetMicrosecondsF() const;
 void SetMicroseconds( unsigned long nMicroseconds );

 unsigned long GetMilliseconds() const;
 double GetMillisecondsF() const;

 double GetSeconds() const;

 CCycleCount& operator+=( CCycleCount const &other );


 static void Add( CCycleCount const &rSrc1, CCycleCount const &rSrc2, CCycleCount &dest );


 static void Sub( CCycleCount const &rSrc1, CCycleCount const &rSrc2, CCycleCount &dest );

 static int64 GetTimestamp();

 int64 m_Int64;
};

class CClockSpeedInit
{
public:
 CClockSpeedInit()
 {
  Init();
 }

 static void Init()
 {




  const CPUInformation& pi = GetCPUInformation();

  g_ClockSpeed = pi.m_Speed;
  g_dwClockSpeed = (unsigned long)g_ClockSpeed;

  g_ClockSpeedMicrosecondsMultiplier = 1000000.0 / (double)g_ClockSpeed;
  g_ClockSpeedMillisecondsMultiplier = 1000.0 / (double)g_ClockSpeed;
  g_ClockSpeedSecondsMultiplier = 1.0f / (double)g_ClockSpeed;
 }
};

class CFastTimer
{
public:

 void Start();
 void End();

 const CCycleCount & GetDuration() const;
 CCycleCount GetDurationInProgress() const;


 static inline unsigned long GetClockSpeed();

private:
 CCycleCount m_Duration;



};



class CTimeScope
{
public:
    CTimeScope( CFastTimer *pTimer );
    ~CTimeScope();

private:
 CFastTimer *m_pTimer;
};

inline CTimeScope::CTimeScope( CFastTimer *pTotal )
{
 m_pTimer = pTotal;
 m_pTimer->Start();
}

inline CTimeScope::~CTimeScope()
{
 m_pTimer->End();
}



class CTimeAdder
{
public:
    CTimeAdder( CCycleCount *pTotal );
    ~CTimeAdder();

 void End();

private:
 CCycleCount *m_pTotal;
 CFastTimer m_Timer;
};

inline CTimeAdder::CTimeAdder( CCycleCount *pTotal )
{
 m_pTotal = pTotal;
 m_Timer.Start();
}

inline CTimeAdder::~CTimeAdder()
{
 End();
}

inline void CTimeAdder::End()
{
 if( m_pTotal )
 {
  m_Timer.End();
  *m_pTotal += m_Timer.GetDuration();
  m_pTotal = 0;
 }
}
class CAverageCycleCounter
{
public:
 CAverageCycleCounter();

 void Init();
 void MarkIter( const CCycleCount &duration );

 unsigned GetIters() const;

 double GetAverageMilliseconds() const;
 double GetTotalMilliseconds() const;
 double GetPeakMilliseconds() const;

private:
 unsigned m_nIters;
 CCycleCount m_Total;
 CCycleCount m_Peak;


};



class CAverageTimeMarker
{
public:
 CAverageTimeMarker( CAverageCycleCounter *pCounter );
 ~CAverageTimeMarker();

private:
 CAverageCycleCounter *m_pCounter;
 CFastTimer m_Timer;
};






inline CCycleCount::CCycleCount()
{
 Init( (int64)0 );
}

inline CCycleCount::CCycleCount( int64 cycles )
{
 Init( cycles );
}

inline void CCycleCount::Init()
{
 Init( (int64)0 );
}

inline void CCycleCount::Init( float initTimeMsec )
{
 if ( g_ClockSpeedMillisecondsMultiplier > 0 )
  Init( (int64)(initTimeMsec / g_ClockSpeedMillisecondsMultiplier) );
 else
  Init( (int64)0 );
}

inline void CCycleCount::Init( int64 cycles )
{
 m_Int64 = cycles;
}






inline void CCycleCount::Sample()
{
 unsigned long* pSample = (unsigned long *)&m_Int64;
    __asm__ __volatile__ (
  "rdtsc\n\t"
  "movl %%eax,  (%0)\n\t"
  "movl %%edx, 4(%0)\n\t"
  :
  : "D" (pSample)
  : "%eax", "%edx" );

}





inline CCycleCount& CCycleCount::operator+=( CCycleCount const &other )
{
 m_Int64 += other.m_Int64;
 return *this;
}


inline void CCycleCount::Add( CCycleCount const &rSrc1, CCycleCount const &rSrc2, CCycleCount &dest )
{
 dest.m_Int64 = rSrc1.m_Int64 + rSrc2.m_Int64;
}

inline void CCycleCount::Sub( CCycleCount const &rSrc1, CCycleCount const &rSrc2, CCycleCount &dest )
{
 dest.m_Int64 = rSrc1.m_Int64 - rSrc2.m_Int64;
}

inline int64 CCycleCount::GetTimestamp()
{
 CCycleCount c;
 c.Sample();
 return c.GetLongCycles();
}

inline bool CCycleCount::IsLessThan(CCycleCount const &other) const
{
 return m_Int64 < other.m_Int64;
}


inline unsigned long CCycleCount::GetCycles() const
{
 return (unsigned long)m_Int64;
}

inline int64 CCycleCount::GetLongCycles() const
{
 return m_Int64;
}

inline unsigned long CCycleCount::GetMicroseconds() const
{
 return (unsigned long)((m_Int64 * 1000000) / g_ClockSpeed);
}

inline uint64 CCycleCount::GetUlMicroseconds() const
{
 return ((m_Int64 * 1000000) / g_ClockSpeed);
}


inline double CCycleCount::GetMicrosecondsF() const
{
 return (double)( m_Int64 * g_ClockSpeedMicrosecondsMultiplier );
}


inline void CCycleCount::SetMicroseconds( unsigned long nMicroseconds )
{
 m_Int64 = ((int64)nMicroseconds * g_ClockSpeed) / 1000000;
}


inline unsigned long CCycleCount::GetMilliseconds() const
{
 return (unsigned long)((m_Int64 * 1000) / g_ClockSpeed);
}


inline double CCycleCount::GetMillisecondsF() const
{
 return (double)( m_Int64 * g_ClockSpeedMillisecondsMultiplier );
}


inline double CCycleCount::GetSeconds() const
{
 return (double)( m_Int64 * g_ClockSpeedSecondsMultiplier );
}





inline void CFastTimer::Start()
{
 m_Duration.Sample();



}


inline void CFastTimer::End()
{
 CCycleCount cnt;
 cnt.Sample();
 if ( false )
 {


  if ( (uint64)cnt.m_Int64 <= (uint64)m_Duration.m_Int64 )
  {

   cnt.m_Int64 += 0x100000000LL;
  }
 }

 m_Duration.m_Int64 = cnt.m_Int64 - m_Duration.m_Int64;




}

inline CCycleCount CFastTimer::GetDurationInProgress() const
{
 CCycleCount cnt;
 cnt.Sample();
 if ( false )
 {


  if ( (uint64)cnt.m_Int64 <= (uint64)m_Duration.m_Int64 )
  {

   cnt.m_Int64 += 0x100000000LL;
  }
 }

 CCycleCount result;
 result.m_Int64 = cnt.m_Int64 - m_Duration.m_Int64;

 return result;
}


inline unsigned long CFastTimer::GetClockSpeed()
{
 return g_dwClockSpeed;
}


inline CCycleCount const& CFastTimer::GetDuration() const
{



 return m_Duration;
}





inline CAverageCycleCounter::CAverageCycleCounter()
 : m_nIters( 0 )
{
}

inline void CAverageCycleCounter::Init()
{
 m_Total.Init();
 m_Peak.Init();
 m_nIters = 0;
}

inline void CAverageCycleCounter::MarkIter( const CCycleCount &duration )
{
 ++m_nIters;
 m_Total += duration;
 if ( m_Peak.IsLessThan( duration ) )
  m_Peak = duration;
}

inline unsigned CAverageCycleCounter::GetIters() const
{
 return m_nIters;
}

inline double CAverageCycleCounter::GetAverageMilliseconds() const
{
 if ( m_nIters )
  return (m_Total.GetMillisecondsF() / (double)m_nIters);
 else
  return 0;
}

inline double CAverageCycleCounter::GetTotalMilliseconds() const
{
 return m_Total.GetMillisecondsF();
}

inline double CAverageCycleCounter::GetPeakMilliseconds() const
{
 return m_Peak.GetMillisecondsF();
}



inline CAverageTimeMarker::CAverageTimeMarker( CAverageCycleCounter *pCounter )
{
 m_pCounter = pCounter;
 m_Timer.Start();
}

inline CAverageTimeMarker::~CAverageTimeMarker()
{
 m_Timer.End();
 m_pCounter->MarkIter( m_Timer.GetDuration() );
}





class CLimitTimer
{
public:
 void SetLimit( uint64 m_cMicroSecDuration );
 bool BLimitReached( void );

private:
 int64 m_lCycleLimit;
};






inline void CLimitTimer::SetLimit( uint64 m_cMicroSecDuration )
{
 int64 dlCycles = ( ( uint64 ) m_cMicroSecDuration * ( int64 ) g_dwClockSpeed ) / ( int64 ) 1000000L;
 CCycleCount cycleCount;
 cycleCount.Sample( );
 m_lCycleLimit = cycleCount.GetLongCycles( ) + dlCycles;
}






inline bool CLimitTimer::BLimitReached( )
{
 CCycleCount cycleCount;
 cycleCount.Sample( );
 return ( cycleCount.GetLongCycles( ) >= m_lCycleLimit );
}
template <class T>
inline void Construct( T* pMemory )
{
 ::new( pMemory ) T;
}

template <class T>
inline void CopyConstruct( T* pMemory, T const& src )
{
 ::new( pMemory ) T(src);
}

template <class T>
inline void Destruct( T* pMemory )
{
 pMemory->~T();




}
extern "C" bool vtune( bool resume );
inline bool IsPowerOfTwo( int value )
{
 return (value & ( value - 1 )) == 0;
}












typedef unsigned int uintptr_t;
template <typename T>
inline T AlignValue( T val, unsigned alignment )
{
 return (T)( ( (uintptr_t)val + alignment - 1 ) & ~( alignment - 1 ) );
}
inline float fpmin( float a, float b )
{
 return ( a < b ) ? a : b;
}

inline float fpmax( float a, float b )
{
 return ( a > b ) ? a : b;
}



 template< class T >
 inline T clamp( T const &val, T const &minVal, T const &maxVal )
 {
  if( val < minVal )
   return minVal;
  else if( val > maxVal )
   return maxVal;
  else
   return val;
 }
typedef int BOOL;
typedef int qboolean;
typedef unsigned long ULONG;
typedef unsigned char BYTE;
typedef unsigned char byte;
typedef unsigned short word;


typedef unsigned int uintptr_t;



enum ThreeState_t
{
 TRS_FALSE,
 TRS_TRUE,
 TRS_NONE,
};

typedef float vec_t;
inline unsigned long& FloatBits( vec_t& f )
{
 return *reinterpret_cast<unsigned long*>(&f);
}

inline unsigned long const& FloatBits( vec_t const& f )
{
 return *reinterpret_cast<unsigned long const*>(&f);
}

inline vec_t BitsToFloat( unsigned long i )
{
 return *reinterpret_cast<vec_t*>(&i);
}

inline bool IsFinite( vec_t f )
{
 return ((FloatBits(f) & 0x7F800000) != 0x7F800000);
}

inline unsigned long FloatAbsBits( vec_t f )
{
 return FloatBits(f) & 0x7FFFFFFF;
}

inline float FloatMakeNegative( vec_t f )
{
 return BitsToFloat( FloatBits(f) | 0x80000000 );
}
inline float FloatMakePositive( vec_t f )
{
 return BitsToFloat( FloatBits(f) & 0x7FFFFFFF );
}


inline float FloatNegate( vec_t f )
{
 return BitsToFloat( FloatBits(f) ^ 0x80000000 );
}
struct color24
{
 byte r, g, b;
};

typedef struct color32_s
{
 bool operator!=( const struct color32_s &other ) const;

 byte r, g, b, a;
} color32;

inline bool color32::operator!=( const color32 &other ) const
{
 return r != other.r || g != other.g || b != other.b || a != other.a;
}

struct colorVec
{
 unsigned r, g, b, a;
};







struct vrect_t
{
 int x,y,width,height;
 vrect_t *pnext;
};







struct Rect_t
{
    int x, y;
 int width, height;
};





struct interval_t
{
 float start;
 float range;
};
template< class HandleType >
class CBaseIntHandle
{
public:

 inline bool operator==( const CBaseIntHandle &other ) { return m_Handle == other.m_Handle; }
 inline bool operator!=( const CBaseIntHandle &other ) { return m_Handle != other.m_Handle; }



 inline HandleType GetHandleValue() { return m_Handle; }
 inline void SetHandleValue( HandleType val ) { m_Handle = val; }

 typedef HandleType HANDLE_TYPE;

protected:

 HandleType m_Handle;
};

template< class DummyType >
class CIntHandle16 : public CBaseIntHandle< unsigned short >
{
public:
 inline CIntHandle16() {}

 static inline CIntHandle16<DummyType> MakeHandle( HANDLE_TYPE val )
 {
  return CIntHandle16<DummyType>( val );
 }

protected:
 inline CIntHandle16( HANDLE_TYPE val )
 {
  m_Handle = val;
 }
};


template< class DummyType >
class CIntHandle32 : public CBaseIntHandle< unsigned long >
{
public:
 inline CIntHandle32() {}

 static inline CIntHandle32<DummyType> MakeHandle( HANDLE_TYPE val )
 {
  return CIntHandle32<DummyType>( val );
 }

protected:
 inline CIntHandle32( HANDLE_TYPE val )
 {
  m_Handle = val;
 }
};
class Color
{
public:

 Color()
 {
  *((int *)this) = 0;
 }
 Color(int r,int g,int b)
 {
  SetColor(r, g, b, 0);
 }
 Color(int r,int g,int b,int a)
 {
  SetColor(r, g, b, a);
 }






 void SetColor(int r, int g, int b, int a = 0)
 {
  _color[0] = (unsigned char)r;
  _color[1] = (unsigned char)g;
  _color[2] = (unsigned char)b;
  _color[3] = (unsigned char)a;
 }

 void GetColor(int &r, int &g, int &b, int &a) const
 {
  r = _color[0];
  g = _color[1];
  b = _color[2];
  a = _color[3];
 }

 void SetRawColor( int color32 )
 {
  *((int *)this) = color32;
 }

 int GetRawColor() const
 {
  return *((int *)this);
 }

 inline int r() const { return _color[0]; }
 inline int g() const { return _color[1]; }
 inline int b() const { return _color[2]; }
 inline int a() const { return _color[3]; }

 unsigned char &operator[](int index)
 {
  return _color[index];
 }

 const unsigned char &operator[](int index) const
 {
  return _color[index];
 }

 bool operator == (const Color &rhs) const
 {
  return ( *((int *)this) == *((int *)&rhs) );
 }

 bool operator != (const Color &rhs) const
 {
  return !(operator==(rhs));
 }

 Color &operator=( const Color &rhs )
 {
  SetRawColor( rhs.GetRawColor() );
  return *this;
 }

private:
 unsigned char _color[4];
};
class ICommandLine
{
public:
 virtual void CreateCmdLine( const char *commandline ) = 0;
 virtual void CreateCmdLine( int argc, char **argv ) = 0;
 virtual const char *GetCmdLine( void ) const = 0;


 virtual const char *CheckParm( const char *psz, const char **ppszValue = 0 ) const = 0;
 virtual void RemoveParm( const char *parm ) = 0;
 virtual void AppendParm( const char *pszParm, const char *pszValues ) = 0;


 virtual const char *ParmValue( const char *psz, const char *pDefaultVal = 0 ) const = 0;
 virtual int ParmValue( const char *psz, int nDefaultVal ) const = 0;
 virtual float ParmValue( const char *psz, float flDefaultVal ) const = 0;


 virtual int ParmCount() const = 0;
 virtual int FindParm( const char *psz ) const = 0;
 virtual const char* GetParm( int nIndex ) const = 0;
};






extern "C" ICommandLine *CommandLine_Tier0();
class CLoggingSystem;




class CThreadMutex;
typedef CThreadMutex CThreadFastMutex;





const int MAX_LOGGING_MESSAGE_LENGTH = 2048;




const int MAX_LOGGING_IDENTIFIER_LENGTH = 32;




const int MAX_LOGGING_CHANNEL_COUNT = 256;




const int MAX_LOGGING_TAG_COUNT = 1024;




const int MAX_LOGGING_TAG_CHARACTER_COUNT = 8192;




const int MAX_LOGGING_LISTENER_COUNT = 16;





const Color UNSPECIFIED_LOGGING_COLOR( 0, 0, 0, 0 );




typedef int LoggingChannelID_t;




const LoggingChannelID_t INVALID_LOGGING_CHANNEL_ID = -1;




enum LoggingSeverity_t
{



 LS_MESSAGE = 0,




 LS_WARNING = 1,




 LS_ASSERT = 2,




 LS_ERROR = 3,





 LS_HIGHEST_SEVERITY = 4,
};
enum LoggingResponse_t
{
 LR_CONTINUE,
 LR_DEBUGGER,
 LR_ABORT,
};




enum LoggingChannelFlags_t
{



 LCF_CONSOLE_ONLY = 0x00000001,






 LCF_DO_NOT_ECHO = 0x00000002,
};





typedef void ( *RegisterTagsFunc )();




struct LoggingContext_t
{

 LoggingChannelID_t m_ChannelID;

 LoggingChannelFlags_t m_Flags;

 LoggingSeverity_t m_Severity;




 Color m_Color;
};
class ILoggingListener
{
public:
 virtual void Log( const LoggingContext_t *pContext, const tchar *pMessage ) = 0;
};
class ILoggingResponsePolicy
{
public:
 virtual LoggingResponse_t OnLog( const LoggingContext_t *pContext ) = 0;
};
class CSimpleLoggingListener : public ILoggingListener
{
public:
 CSimpleLoggingListener( bool bQuietPrintf = false, bool bQuietDebugger = false ) :
   m_bQuietPrintf( bQuietPrintf ),
    m_bQuietDebugger( bQuietDebugger )
   {
   }

   virtual void Log( const LoggingContext_t *pContext, const tchar *pMessage )
   {
    {

     if ( !m_bQuietPrintf )
     {
      printf( "%s", pMessage );
     }
    }
   }


   bool m_bQuietPrintf;

   bool m_bQuietDebugger;
};




class CSimpleWindowsLoggingListener : public ILoggingListener
{
public:
 virtual void Log( const LoggingContext_t *pContext, const tchar *pMessage )
 {
  if ( (false) )
  {
   ((void)0);

   if ( pContext->m_Severity == LS_ERROR )
   {
    {};
   }
  }
 }
};




class CDefaultLoggingResponsePolicy : public ILoggingResponsePolicy
{
public:
 virtual LoggingResponse_t OnLog( const LoggingContext_t *pContext )
 {
  if ( pContext->m_Severity == LS_ASSERT && !CommandLine_Tier0()->FindParm( "-noassert" ) )
  {
   return LR_DEBUGGER;
  }
  else if ( pContext->m_Severity == LS_ERROR )
  {
   return LR_ABORT;
  }
  else
  {
   return LR_CONTINUE;
  }
 }
};




class CNonFatalLoggingResponsePolicy : public ILoggingResponsePolicy
{
public:
 virtual LoggingResponse_t OnLog( const LoggingContext_t *pContext )
 {
  if ( ( pContext->m_Severity == LS_ASSERT && !CommandLine_Tier0()->FindParm( "-noassert" ) ) || pContext->m_Severity == LS_ERROR )
  {
   return LR_DEBUGGER;
  }
  else
  {
   return LR_CONTINUE;
  }
 }
};
class CLoggingSystem
{
public:
 struct LoggingChannel_t;

 CLoggingSystem();
 ~CLoggingSystem();
 LoggingChannelID_t RegisterLoggingChannel( const char *pChannelName, RegisterTagsFunc registerTagsFunc, int flags = 0, LoggingSeverity_t minimumSeverity = LS_MESSAGE, Color spewColor = UNSPECIFIED_LOGGING_COLOR );






 LoggingChannelID_t FindChannel( const char *pChannelName ) const;

 int GetChannelCount() const { return m_nChannelCount; }




 LoggingChannel_t *GetChannel( LoggingChannelID_t channelID );
 const LoggingChannel_t *GetChannel( LoggingChannelID_t channelID ) const;




 bool HasTag( LoggingChannelID_t channelID, const char *pTag ) const { return GetChannel( channelID )->HasTag( pTag ); }




 bool IsChannelEnabled( LoggingChannelID_t channelID, LoggingSeverity_t severity ) const { return GetChannel( channelID )->IsEnabled( severity ); }
 void SetChannelSpewLevel( LoggingChannelID_t channelID, LoggingSeverity_t minimumSeverity );
 void SetChannelSpewLevelByName( const char *pName, LoggingSeverity_t minimumSeverity );
 void SetChannelSpewLevelByTag( const char *pTag, LoggingSeverity_t minimumSeverity );






 Color GetChannelColor( LoggingChannelID_t channelID ) const { return GetChannel( channelID )->m_SpewColor; }







 LoggingChannelFlags_t GetChannelFlags( LoggingChannelID_t channelID ) const { return GetChannel( channelID )->m_Flags; }
 void SetChannelFlags( LoggingChannelID_t channelID, LoggingChannelFlags_t flags ) { GetChannel( channelID )->m_Flags = flags; }







 void AddTagToCurrentChannel( const char *pTagName );
 void PushLoggingState( bool bThreadLocal = false );
 void PopLoggingState( bool bThreadLocal = false );




 void RegisterLoggingListener( ILoggingListener *pListener );




 bool IsListenerRegistered( ILoggingListener *pListener ) const;





 void ResetCurrentLoggingState();







 void SetLoggingResponsePolicy( ILoggingResponsePolicy *pLoggingResponse );






 LoggingResponse_t LogDirect( LoggingChannelID_t channelID, LoggingSeverity_t severity, Color color, const tchar *pMessage );


 struct LoggingTag_t
 {
  const char *m_pTagName;
  LoggingTag_t *m_pNextTag;
 };


 struct LoggingChannel_t
 {
  bool HasTag( const char *pTag ) const
  {
   LoggingTag_t *pCurrentTag = m_pFirstTag;
   while( pCurrentTag != 
                        __null 
                             )
   {
    if ( strcasecmp( pCurrentTag->m_pTagName, pTag ) == 0 )
    {
     return true;
    }
    pCurrentTag = pCurrentTag->m_pNextTag;
   }
   return false;
  }
  bool IsEnabled( LoggingSeverity_t severity ) const { return severity >= m_MinimumSeverity; }
  void SetSpewLevel( LoggingSeverity_t severity ) { m_MinimumSeverity = severity; }

  LoggingChannelFlags_t m_Flags;
  LoggingSeverity_t m_MinimumSeverity;
  Color m_SpewColor;
  char m_Name[MAX_LOGGING_IDENTIFIER_LENGTH];
  LoggingTag_t *m_pFirstTag;
 };

private:


 struct LoggingState_t
 {

  int m_nPreviousStackEntry;



  int m_nListenerCount;

  ILoggingListener *m_RegisteredListeners[MAX_LOGGING_LISTENER_COUNT];


  ILoggingResponsePolicy *m_pLoggingResponse;
 };


 LoggingState_t *GetCurrentState();
 const LoggingState_t *GetCurrentState() const;

 int FindUnusedStateIndex();
 LoggingTag_t *AllocTag( const char *pTagName );

 int m_nChannelCount;
 LoggingChannel_t m_RegisteredChannels[MAX_LOGGING_CHANNEL_COUNT];

 int m_nChannelTagCount;
 LoggingTag_t m_ChannelTags[MAX_LOGGING_TAG_COUNT];


 int m_nTagNamePoolIndex;

 char m_TagNamePool[MAX_LOGGING_TAG_CHARACTER_COUNT];




 CThreadFastMutex *m_pStateMutex;





 int m_nGlobalStateIndex;


 static const int MAX_LOGGING_STATE_COUNT = 16;
 LoggingState_t m_LoggingStates[MAX_LOGGING_STATE_COUNT];


 CDefaultLoggingResponsePolicy m_DefaultLoggingResponse;


 CSimpleLoggingListener m_DefaultLoggingListener;

};
extern "C" LoggingChannelID_t LoggingSystem_RegisterLoggingChannel( const char *pName, RegisterTagsFunc registerTagsFunc, int flags = 0, LoggingSeverity_t severity = LS_MESSAGE, Color color = UNSPECIFIED_LOGGING_COLOR );

extern "C" void LoggingSystem_RegisterLoggingListener( ILoggingListener *pListener );
extern "C" void LoggingSystem_ResetCurrentLoggingState();
extern "C" void LoggingSystem_SetLoggingResponsePolicy( ILoggingResponsePolicy *pResponsePolicy );


extern "C" void LoggingSystem_PushLoggingState( bool bThreadLocal = false );
extern "C" void LoggingSystem_PopLoggingState( bool bThreadLocal = false );

extern "C" void LoggingSystem_AddTagToCurrentChannel( const char *pTagName );


extern "C" LoggingChannelID_t LoggingSystem_FindChannel( const char *pChannelName );
extern "C" int LoggingSystem_GetChannelCount();
extern "C" const CLoggingSystem::LoggingChannel_t *LoggingSystem_GetChannel( LoggingChannelID_t channelID );

extern "C" bool LoggingSystem_HasTag( LoggingChannelID_t channelID, const char *pTag );

extern "C" bool LoggingSystem_IsChannelEnabled( LoggingChannelID_t channelID, LoggingSeverity_t severity );
extern "C" void LoggingSystem_SetChannelSpewLevel( LoggingChannelID_t channelID, LoggingSeverity_t minimumSeverity );
extern "C" void LoggingSystem_SetChannelSpewLevelByName( const char *pName, LoggingSeverity_t minimumSeverity );
extern "C" void LoggingSystem_SetChannelSpewLevelByTag( const char *pTag, LoggingSeverity_t minimumSeverity );
extern "C" LoggingResponse_t LoggingSystem_Log( LoggingChannelID_t channelID, LoggingSeverity_t severity, const char *pMessageFormat, ... ) ;
extern LoggingResponse_t LoggingSystem_Log( LoggingChannelID_t channelID, LoggingSeverity_t severity, Color spewColor, const char *pMessageFormat, ... ) ;

extern "C" LoggingResponse_t LoggingSystem_LogDirect( LoggingChannelID_t channelID, LoggingSeverity_t severity, Color spewColor, const char *pMessage );
extern "C" LoggingResponse_t LoggingSystem_LogAssert( const char *pMessageFormat, ... ) ;

extern "C" {













typedef float float_t;
typedef double double_t;


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));








extern int isinf (double __value) throw () __attribute__ ((__const__));



extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));






extern int isnan (double __value) throw () __attribute__ ((__const__));





extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));






extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));








extern int isinff (float __value) throw () __attribute__ ((__const__));



extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));






extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));






extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));








extern int isinfl (long double __value) throw () __attribute__ ((__const__));



extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));






extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));






extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
extern int signgam;
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbitf (float __x) throw ()
{





  __extension__ union { float __f; int __i; } __u = { __f: __x };
  return __u.__i < 0;

}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbit (double __x) throw ()
{





  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
  return __u.__i[1] < 0;

}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbitl (long double __x) throw ()
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__leaf__)) __atan2l (long double __y, long double __x) throw () { return __builtin_atan2l (__y, __x); }
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) double __attribute__ ((__leaf__)) fabs (double __x) throw () { return __builtin_fabs (__x); }

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) float __attribute__ ((__leaf__)) fabsf (float __x) throw () { return __builtin_fabsf (__x); }
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__leaf__)) fabsl (long double __x) throw () { return __builtin_fabsl (__x); }

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__leaf__)) __fabsl (long double __x) throw () { return __builtin_fabsl (__x); }
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __sgn1l (long double) throw (); extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__leaf__)) __sgn1l (long double __x) throw () { __extension__ union { long double __xld; unsigned int __xi[3]; } __n = { __xld: __x }; __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff; __n.__xi[1] = 0x80000000; __n.__xi[0] = 0; return __n.__xld; }
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) double __attribute__ ((__leaf__)) floor (double __x) throw () { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0400, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) float __attribute__ ((__leaf__)) floorf (float __x) throw () { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0400, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__leaf__)) floorl (long double __x) throw () { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0400, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; }
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) double __attribute__ ((__leaf__)) ceil (double __x) throw () { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0800, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) float __attribute__ ((__leaf__)) ceilf (float __x) throw () { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0800, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__leaf__)) ceill (long double __x) throw () { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0800, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; }
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) lrintf (float __x) throw ()
{
  long int __lrintres; __asm__ __volatile__ ("fistpl %0" : "=m" (__lrintres) : "t" (__x) : "st"); return __lrintres;
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) lrint (double __x) throw ()
{
  long int __lrintres; __asm__ __volatile__ ("fistpl %0" : "=m" (__lrintres) : "t" (__x) : "st"); return __lrintres;
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) lrintl (long double __x) throw ()
{
  long int __lrintres; __asm__ __volatile__ ("fistpl %0" : "=m" (__lrintres) : "t" (__x) : "st"); return __lrintres;
}
__extension__
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) llrintf (float __x) throw ()
{
  long long int __llrintres; __asm__ __volatile__ ("fistpll %0" : "=m" (__llrintres) : "t" (__x) : "st"); return __llrintres;
}
__extension__
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) llrint (double __x) throw ()
{
  long long int __llrintres; __asm__ __volatile__ ("fistpll %0" : "=m" (__llrintres) : "t" (__x) : "st"); return __llrintres;
}
__extension__
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) llrintl (long double __x) throw ()
{
  long long int __llrintres; __asm__ __volatile__ ("fistpll %0" : "=m" (__llrintres) : "t" (__x) : "st"); return __llrintres;
}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __finite (double __x) throw ()
{
  return (__extension__
   (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
      | 0x800fffffu) + 1) >> 31));
}
}

class Color;
extern "C" void _ExitOnFatalAssert( const tchar* pFile, int line );
extern "C" bool ShouldUseNewAssertDialog();

extern "C" bool SetupWin32ConsoleIO();


extern "C" bool DoNewAssertDialog( const tchar *pFile, int line, const tchar *pExpression );
extern LoggingChannelID_t LOG_GENERAL;

extern LoggingChannelID_t LOG_ASSERT;

extern LoggingChannelID_t LOG_CONSOLE;

extern LoggingChannelID_t LOG_DEVELOPER;

extern LoggingChannelID_t LOG_DEVELOPER_CONSOLE;

extern LoggingChannelID_t LOG_DEVELOPER_VERBOSE;



extern "C" void Msg( const tchar* pMsg, ... );
extern "C" void Warning( const tchar *pMsg, ... ) ;
extern "C" void Error( const tchar *pMsg, ... ) ;


extern "C" void _Warning_AlwaysSpewCallStack_Enable( bool bEnable );
extern "C" void _Warning_AlwaysSpewCallStack_Length( int iMaxCallStackLength );

extern "C" void _Error_AlwaysSpewCallStack_Enable( bool bEnable );
extern "C" void _Error_AlwaysSpewCallStack_Length( int iMaxCallStackLength );

extern "C" void DevMsg( int level, const tchar* pMsg, ... ) ;
extern "C" void DevWarning( int level, const tchar *pMsg, ... ) ;

extern "C" void ConDMsg( const tchar* pMsg, ... ) ;
extern "C" void DevMsg( int level, const tchar* pMsg, ... );
extern "C" void DevWarning( int level, const tchar *pMsg, ... );


extern void DevMsg( const tchar* pMsg, ... );
extern void DevWarning( const tchar *pMsg, ... );


extern void ConColorMsg( const Color& clr, const tchar* pMsg, ... );
extern void ConMsg( const tchar* pMsg, ... );


extern "C" void ConDMsg( const tchar* pMsg, ... );
extern "C" void COM_TimestampedLog( char const *fmt, ... ) ;
class CScopeMsg
{
public:
 CScopeMsg( const char *pszScope )
 {
  m_pszScope = pszScope;
  Msg( "%s { ", pszScope );
 }
 ~CScopeMsg()
 {
  Msg( "} %s", m_pszScope );
 }
 const char *m_pszScope;
};
extern "C" void _AssertValidReadPtr( void* ptr, int count = 1 );
extern "C" void _AssertValidWritePtr( void* ptr, int count = 1 );
extern "C" void _AssertValidReadWritePtr( void* ptr, int count = 1 );

extern "C" void AssertValidStringPtr( const tchar* ptr, int maxchar = 0xFFFFFF );
template<class T> inline void AssertValidReadPtr( T* ptr, int count = 1 ) { _AssertValidReadPtr( (void*)ptr, count ); }
template<class T> inline void AssertValidWritePtr( T* ptr, int count = 1 ) { _AssertValidWritePtr( (void*)ptr, count ); }
template<class T> inline void AssertValidReadWritePtr( T* ptr, int count = 1 ) { _AssertValidReadWritePtr( (void*)ptr, count ); }
class CDbgFmtMsg
{
public:
 CDbgFmtMsg(const tchar *pszFormat, ...)
 {
  va_list arg_ptr;

  
 __builtin_va_start(
 arg_ptr
 ,
 pszFormat
 )
                             ;
  vsnprintf(m_szBuf, sizeof(m_szBuf)-1, pszFormat, arg_ptr);
  
 __builtin_va_end(
 arg_ptr
 )
                ;

  m_szBuf[sizeof(m_szBuf)-1] = 0;
 }

 operator const tchar *() const
 {
  return m_szBuf;
 }

private:
 tchar m_szBuf[256];
};
template< class Type >
class CDataWatcher
{
private:
 CDataWatcher();
};

extern "C" {






static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
}
typedef unsigned int wint_t;


typedef __mbstate_t mbstate_t;






extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__leaf__)) btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__leaf__)) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
          const wchar_t *__restrict __s2, size_t __n,
          size_t __ns1) throw ();
extern wchar_t *__wmemcpy_alias (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw () __asm__ ("" "wmemcpy")


            ;
extern wchar_t *__wmemcpy_chk_warn (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n, size_t __ns1) throw () __asm__ ("" "__wmemcpy_chk")



     __attribute__((__warning__ ("wmemcpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wmemcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw ()

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemcpy_chk (__s1, __s2, __n,
         __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemcpy_chk_warn (__s1, __s2, __n,
       __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemcpy_alias (__s1, __s2, __n);
}


extern wchar_t *__wmemmove_chk (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, size_t __ns1) throw ();
extern wchar_t *__wmemmove_alias (wchar_t *__s1, const wchar_t *__s2, size_t __n) throw () __asm__ ("" "wmemmove")

                               ;
extern wchar_t *__wmemmove_chk_warn (wchar_t *__s1, const wchar_t *__s2, size_t __n, size_t __ns1) throw () __asm__ ("" "__wmemmove_chk")


     __attribute__((__warning__ ("wmemmove called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n) throw ()
{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemmove_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemmove_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemmove_alias (__s1, __s2, __n);
}



extern wchar_t *__wmempcpy_chk (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n,
    size_t __ns1) throw ();
extern wchar_t *__wmempcpy_alias (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw () __asm__ ("" "wmempcpy")


                           ;
extern wchar_t *__wmempcpy_chk_warn (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n, size_t __ns1) throw () __asm__ ("" "__wmempcpy_chk")



     __attribute__((__warning__ ("wmempcpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wmempcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw ()

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmempcpy_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmempcpy_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmempcpy_alias (__s1, __s2, __n);
}



extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
          size_t __ns) throw ();
extern wchar_t *__wmemset_alias (wchar_t *__s, wchar_t __c, size_t __n) throw () __asm__ ("" "wmemset")
                             ;
extern wchar_t *__wmemset_chk_warn (wchar_t *__s, wchar_t __c, size_t __n, size_t __ns) throw () __asm__ ("" "__wmemset_chk")


     __attribute__((__warning__ ("wmemset called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ()
{
  if (__builtin_object_size (__s, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemset_chk (__s, __c, __n, __builtin_object_size (__s, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s, 0) / sizeof (wchar_t))
 return __wmemset_chk_warn (__s, __c, __n,
       __builtin_object_size (__s, 0) / sizeof (wchar_t));
    }
  return __wmemset_alias (__s, __c, __n);
}


extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src,
         size_t __n) throw ();
extern wchar_t *__wcscpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw () __asm__ ("" "wcscpy")

                                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wcscpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcscpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcscpy_alias (__dest, __src);
}


extern wchar_t *__wcpcpy_chk (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src,
         size_t __destlen) throw ();
extern wchar_t *__wcpcpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw () __asm__ ("" "wcpcpy")

                                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wcpcpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcpcpy_alias (__dest, __src);
}


extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
          const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) throw ();
extern wchar_t *__wcsncpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw () __asm__ ("" "wcsncpy")


                          ;
extern wchar_t *__wcsncpy_chk_warn (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n, size_t __destlen) throw () __asm__ ("" "__wcsncpy_chk")



     __attribute__((__warning__ ("wcsncpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wcsncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw ()

{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcsncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t))
 return __wcsncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
    }
  return __wcsncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
          const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) throw ();
extern wchar_t *__wcpncpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw () __asm__ ("" "wcpncpy")


                          ;
extern wchar_t *__wcpncpy_chk_warn (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n, size_t __destlen) throw () __asm__ ("" "__wcpncpy_chk")



     __attribute__((__warning__ ("wcpncpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wcpncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw ()

{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcpncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t))
 return __wcpncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
    }
  return __wcpncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src,
         size_t __destlen) throw ();
extern wchar_t *__wcscat_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw () __asm__ ("" "wcscat")

                                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wcscat (wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw ()
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcscat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcscat_alias (__dest, __src);
}


extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
          const wchar_t *__restrict __src,
          size_t __n, size_t __destlen) throw ();
extern wchar_t *__wcsncat_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw () __asm__ ("" "wcsncat")


                          ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__leaf__)) wcsncat (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw ()

{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcsncat_chk (__dest, __src, __n,
     __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcsncat_alias (__dest, __src, __n);
}


extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
      int __flag, size_t __s_len,
      const wchar_t *__restrict __format, ...)
     throw () ;

extern int __swprintf_alias (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, ...) throw () __asm__ ("" "swprintf")


             ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) swprintf (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, ...) throw ()

{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 || 2 > 1)
    return __swprintf_chk (__s, __n, 2 - 1,
      __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
      __fmt, __builtin_va_arg_pack ());
  return __swprintf_alias (__s, __n, __fmt, __builtin_va_arg_pack ());
}
extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
       int __flag, size_t __s_len,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;

extern int __vswprintf_alias (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, __gnuc_va_list __ap) throw () __asm__ ("" "vswprintf")


                                     ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) vswprintf (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, __gnuc_va_list __ap) throw ()

{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 || 2 > 1)
    return __vswprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t), __fmt, __ap);
  return __vswprintf_alias (__s, __n, __fmt, __ap);
}




extern int __fwprintf_chk (__FILE *__restrict __stream, int __flag,
      const wchar_t *__restrict __format, ...);
extern int __wprintf_chk (int __flag, const wchar_t *__restrict __format,
     ...);
extern int __vfwprintf_chk (__FILE *__restrict __stream, int __flag,
       const wchar_t *__restrict __format,
       __gnuc_va_list __ap);
extern int __vwprintf_chk (int __flag, const wchar_t *__restrict __format,
      __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
wprintf (const wchar_t *__restrict __fmt, ...)
{
  return __wprintf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fwprintf (__FILE *__restrict __stream, const wchar_t *__restrict __fmt, ...)
{
  return __fwprintf_chk (__stream, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vwprintf (const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vwprintf_chk (2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfwprintf (__FILE *__restrict __stream,
    const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfwprintf_chk (__stream, 2 - 1, __fmt, __ap);
}



extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
         __FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws")

                                              __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgetws called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_chk (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
        __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t))
 return __fgetws_chk_warn (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
      __n, __stream);
    }
  return __fgetws_alias (__s, __n, __stream);
}


extern wchar_t *__fgetws_unlocked_chk (wchar_t *__restrict __s, size_t __size,
           int __n, __FILE *__restrict __stream)
  __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_unlocked_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws_unlocked")


  __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_unlocked_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_unlocked_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgetws_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws_unlocked (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
          __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t))
 return __fgetws_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
        __n, __stream);
    }
  return __fgetws_unlocked_alias (__s, __n, __stream);
}



extern size_t __wcrtomb_chk (char *__restrict __s, wchar_t __wchar,
        mbstate_t *__restrict __p,
        size_t __buflen) throw () __attribute__ ((__warn_unused_result__));
extern size_t __wcrtomb_alias (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps) throw () __asm__ ("" "wcrtomb")

                                                __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
__attribute__ ((__leaf__)) wcrtomb (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps) throw ()

{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wcrtomb_chk (__s, __wchar, __ps, __builtin_object_size (__s, 2 > 1));
  return __wcrtomb_alias (__s, __wchar, __ps);
}


extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
          const char **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) throw ();
extern size_t __mbsrtowcs_alias (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "mbsrtowcs")



                   ;
extern size_t __mbsrtowcs_chk_warn (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__mbsrtowcs_chk")




     __attribute__((__warning__ ("mbsrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) mbsrtowcs (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsrtowcs_chk (__dst, __src, __len, __ps,
    __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbsrtowcs_chk_warn (__dst, __src, __len, __ps,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbsrtowcs_alias (__dst, __src, __len, __ps);
}


extern size_t __wcsrtombs_chk (char *__restrict __dst,
          const wchar_t **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) throw ();
extern size_t __wcsrtombs_alias (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "wcsrtombs")



                   ;
extern size_t __wcsrtombs_chk_warn (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__wcsrtombs_chk")




    __attribute__((__warning__ ("wcsrtombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) wcsrtombs (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsrtombs_chk (__dst, __src, __len, __ps, __builtin_object_size (__dst, 2 > 1));

      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcsrtombs_chk_warn (__dst, __src, __len, __ps, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcsrtombs_alias (__dst, __src, __len, __ps);
}



extern size_t __mbsnrtowcs_chk (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __nmc,
    size_t __len, mbstate_t *__restrict __ps,
    size_t __dstlen) throw ();
extern size_t __mbsnrtowcs_alias (wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "mbsnrtowcs")



                    ;
extern size_t __mbsnrtowcs_chk_warn (wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__mbsnrtowcs_chk")




     __attribute__((__warning__ ("mbsnrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) mbsnrtowcs (wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsnrtowcs_chk (__dst, __src, __nmc, __len, __ps,
     __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbsnrtowcs_chk_warn (__dst, __src, __nmc, __len, __ps,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbsnrtowcs_alias (__dst, __src, __nmc, __len, __ps);
}


extern size_t __wcsnrtombs_chk (char *__restrict __dst,
    const wchar_t **__restrict __src,
    size_t __nwc, size_t __len,
    mbstate_t *__restrict __ps, size_t __dstlen)
     throw ();
extern size_t __wcsnrtombs_alias (char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw () __asm__ ("" "wcsnrtombs")



                                                  ;
extern size_t __wcsnrtombs_chk_warn (char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) throw () __asm__ ("" "__wcsnrtombs_chk")





     __attribute__((__warning__ ("wcsnrtombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) wcsnrtombs (char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsnrtombs_chk (__dst, __src, __nwc, __len, __ps,
     __builtin_object_size (__dst, 2 > 1));

      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcsnrtombs_chk_warn (__dst, __src, __nwc, __len, __ps,
          __builtin_object_size (__dst, 2 > 1));
    }
  return __wcsnrtombs_alias (__dst, __src, __nwc, __len, __ps);
}






}





extern "C" {






typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


extern size_t __ctype_get_mb_cur_max (void) throw () __attribute__ ((__warn_unused_result__));




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

extern char *l64a (long int __n) throw () __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;
typedef __id_t id_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
typedef __suseconds_t suseconds_t;








typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;



typedef __sigset_t sigset_t;







typedef long int __fd_mask;
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
extern "C" {
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);





extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));


}


extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__leaf__)) gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__leaf__)) gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}

}
typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;





typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;





    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      struct
      {
 short __espins;
 short __elision;



      } __elision_data;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    signed char __rwelision;

    unsigned char __pad2;
    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;


}






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();
extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));









extern int system (const char *__command) __attribute__ ((__warn_unused_result__));






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));

extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));



extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}




extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) throw () __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) throw () __asm__ ("" "realpath")

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) throw () __asm__ ("" "__realpath_chk")


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved) throw ()
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) throw () __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) throw () __asm__ ("" "ptsname_r")

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) throw () __asm__ ("" "__ptsname_r_chk")


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen) throw ()
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  throw () __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) throw () __asm__ ("" "wctomb")
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__leaf__)) wctomb (char *__s, wchar_t __wchar) throw ()
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) throw ();
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) throw () __asm__ ("" "mbstowcs")


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) throw () __asm__ ("" "__mbstowcs_chk")



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) throw ();
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) throw () __asm__ ("" "wcstombs")


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) throw () __asm__ ("" "__wcstombs_chk")



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) throw ()

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
}


template< class T, class I > class CUtlMemory;
template< class T, class A > class CUtlVector;


inline char *strupr( char *start )
{
      char *str = start;
      while( str && *str )
      {
              *str = (char)toupper(*str);
              str++;
      }
      return start;
}

inline char *strlwr( char *start )
{
      char *str = start;
      while( str && *str )
      {
              *str = (char)tolower(*str);
              str++;
      }
      return start;
}






void _V_memset ( const char* file, int line, void *dest, int fill, int count );
void _V_memcpy ( const char* file, int line, void *dest, const void *src, int count );
void _V_memmove ( const char* file, int line, void *dest, const void *src, int count );
int _V_memcmp ( const char* file, int line, const void *m1, const void *m2, int count );
int _V_strlen ( const char* file, int line, const char *str );
void _V_strcpy ( const char* file, int line, char *dest, const char *src );
char* _V_strrchr ( const char* file, int line, const char *s, char c );
int _V_strcmp ( const char* file, int line, const char *s1, const char *s2 );
int _V_wcscmp ( const char* file, int line, const wchar_t *s1, const wchar_t *s2 );
int _V_stricmp ( const char* file, int line, const char *s1, const char *s2 );
char* _V_strstr ( const char* file, int line, const char *s1, const char *search );
char* _V_strupr ( const char* file, int line, char *start );
char* _V_strlower ( const char* file, int line, char *start );
int _V_wcslen ( const char* file, int line, const wchar_t *pwch );
inline void V_memset (void *dest, int fill, int count) { memset( dest, fill, count ); }
inline void V_memcpy (void *dest, const void *src, int count) { memcpy( dest, src, count ); }
inline void V_memmove (void *dest, const void *src, int count) { memmove( dest, src, count ); }
inline int V_memcmp (const void *m1, const void *m2, int count){ return memcmp( m1, m2, count ); }
inline int V_strlen (const char *str) { return (int) strlen ( str ); }
inline void V_strcpy (char *dest, const char *src) { strcpy( dest, src ); }
inline int V_wcslen(const wchar_t *pwch) { return (int)wcslen(pwch); }
inline char* V_strrchr (const char *s, char c) { return (char*)strrchr( s, c ); }
inline int V_strcmp (const char *s1, const char *s2) { return strcmp( s1, s2 ); }
inline int V_wcscmp (const wchar_t *s1, const wchar_t *s2) { return wcscmp( s1, s2 ); }
inline int V_stricmp( const char *s1, const char *s2 ) { return strcasecmp( s1, s2 ); }
inline char* V_strstr( const char *s1, const char *search ) { return (char*)strstr( s1, search ); }
inline char* V_strupr (char *start) { return strupr( start ); }
inline char* V_strlower (char *start) { return strlwr( start ); }



int V_strncmp (const char *s1, const char *s2, int count);
int V_strcasecmp (const char *s1, const char *s2);
int V_strncasecmp (const char *s1, const char *s2, int n);
int V_strnicmp (const char *s1, const char *s2, int n);
int V_atoi (const char *str);
float V_atof (const char *str);
char* V_stristr( char* pStr, const char* pSearch );
const char* V_stristr( const char* pStr, const char* pSearch );
const char* V_strnistr( const char* pStr, const char* pSearch, int n );
const char* V_strnchr( const char* pStr, char c, int n );


const char *StringAfterPrefix ( const char *str, const char *prefix );
const char *StringAfterPrefixCaseSensitive( const char *str, const char *prefix );
inline bool StringHasPrefix ( const char *str, const char *prefix ) { return StringAfterPrefix ( str, prefix ) != 
                                                                                                                                         __null
                                                                                                                                             ; }
inline bool StringHasPrefixCaseSensitive( const char *str, const char *prefix ) { return StringAfterPrefixCaseSensitive( str, prefix ) != 
                                                                                                                                         __null
                                                                                                                                             ; }




void V_normalizeFloatString( char* pFloat );
void V_strncpy( char *pDest, const char *pSrc, int maxLen );
int V_snprintf( char *pDest, int destLen, const char *pFormat, ... );
void V_wcsncpy( wchar_t *pDest, wchar_t const *pSrc, int maxLenInBytes );
int V_snwprintf( wchar_t *pDest, int destLen, const wchar_t *pFormat, ... );


char *V_strncat(char *, const char *, size_t destBufferSize, int max_chars_to_copy=-1 );
char *V_strnlwr(char *, size_t);
int V_vsnprintf( char *pDest, int maxLen, const char *pFormat, va_list params );


char *V_pretifymem( float value, int digitsafterdecimal = 2, bool usebinaryonek = false );


char *V_pretifynum( int64 value );


int V_UTF8ToUnicode( const char *pUTF8, wchar_t *pwchDest, int cubDestSizeInBytes );
int V_UnicodeToUTF8( const wchar_t *pUnicode, char *pUTF8, int cubDestSizeInBytes );
void V_hextobinary( char const *in, int numchars, byte *out, int maxoutputbytes );
void V_binarytohex( const byte *in, int inputbytes, char *out, int outsize );



void V_FileBase( const char *in, char *out,int maxlen );

void V_StripTrailingSlash( char *ppath );

void V_StripExtension( const char *in, char *out, int outLen );

void V_DefaultExtension( char *path, const char *extension, int pathStringLength );

void V_SetExtension( char *path, const char *extension, int pathStringLength );

void V_StripFilename( char *path );

bool V_StripLastDir( char *dirName, int maxlen );

const char * V_UnqualifiedFileName( const char * in );

void V_ComposeFileName( const char *path, const char *filename, char *dest, int destSize );


bool V_ExtractFilePath( const char *path, char *dest, int destSize );

void V_ExtractFileExtension( const char *path, char *dest, int destSize );

const char *V_GetFileExtension( const char * path );




bool V_RemoveDotSlashes( char *pFilename, char separator = '/' );




void V_MakeAbsolutePath( char *pOut, int outLen, const char *pPath, const char *pStartingDir = 
                                                                                              __null 
                                                                                                   );





bool V_MakeRelativePath( const char *pFullPath, const char *pDirectory, char *pRelativePath, int nBufLen );


void V_FixupPathName( char *pOut, size_t nOutLen, const char *pPath );


void V_AppendSlash( char *pStr, int strSize );


bool V_IsAbsolutePath( const char *pPath );





bool V_StrSubst( const char *pIn, const char *pMatch, const char *pReplaceWith,
 char *pOut, int outLen, bool bCaseSensitive=false );




void V_SplitString( const char *pString, const char *pSeparator, CUtlVector<char*, CUtlMemory<char*, int> > &outStrings );


void V_SplitString2( const char *pString, const char **pSeparators, int nSeparators, CUtlVector<char*, CUtlMemory<char*, int> > &outStrings );


bool V_GetCurrentDirectory( char *pOut, int maxLen );


bool V_SetCurrentDirectory( const char *pDirName );






void V_StrSlice( const char *pStr, int firstChar, int lastCharNonInclusive, char *pOut, int outSize );


void V_StrLeft( const char *pStr, int nChars, char *pOut, int outSize );


void V_StrRight( const char *pStr, int nChars, char *pOut, int outSize );



char *V_AddBackSlashesToSpecialChars( char const *pSrc );


void V_FixSlashes( char *pname, char separator = '/' );


void V_FixDoubleSlashes( char *pStr );



void V_strtowcs( const char *pString, int nInSize, wchar_t *pWString, int nOutSize );
void V_wcstostr( const wchar_t *pWString, int nInSize, char *pString, int nOutSize );


inline void V_strcat( char *dest, const char *src, int cchDest )
{
 V_strncat( dest, src, cchDest, -1 );
}







template < class NameArray >
int V_GenerateUniqueNameIndex( const char *prefix, const NameArray &nameArray, int startindex = 0 )
{
 if ( prefix == 
               __null 
                    )
  return 0;

 int freeindex = startindex;

 int nNames = nameArray.Count();
 for ( int i = 0; i < nNames; ++i )
 {
  const char *pName = nameArray[ i ];
  if ( !pName )
   continue;

  const char *pIndexStr = StringAfterPrefix( pName, prefix );
  if ( pIndexStr )
  {
   int index = *pIndexStr ? atoi( pIndexStr ) : 1;
   if ( index >= freeindex )
   {

    freeindex = index + 1;
   }
  }
 }

 return freeindex;
}

template < class NameArray >
bool V_GenerateUniqueName( char *name, int memsize, const char *prefix, const NameArray &nameArray )
{
 if ( name == 
             __null 
                  || memsize == 0 )
  return false;

 if ( prefix == 
               __null 
                    )
 {
  name[ 0 ] = '\0';
  return false;
 }

 int prefixLength = V_strlen( prefix );
 if ( prefixLength + 1 > memsize )
 {
  name[ 0 ] = '\0';
  return false;
 }

 int i = V_GenerateUniqueNameIndex( prefix, nameArray );
 if ( i <= 0 )
 {
  V_strncpy( name, prefix, memsize );
  return true;
 }

 int newlen = prefixLength + ( int )log10( ( float )i ) + 1;
 if ( newlen + 1 > memsize )
 {
  V_strncpy( name, prefix, memsize );
  return false;
 }

 V_snprintf( name, memsize, "%s%d", prefix, i );
 return true;
}






class IConVar;
class CCommand;
typedef void ( *FnChangeCallback_t )( IConVar *var, const char *pOldValue, float flOldValue );





class IConVar
{
public:

 virtual void SetValue( const char *pValue ) = 0;
 virtual void SetValue( float flValue ) = 0;
 virtual void SetValue( int nValue ) = 0;
 virtual void SetValue( Color value ) = 0;


 virtual const char *GetName( void ) const = 0;


 virtual const char *GetBaseName( void ) const = 0;



 virtual bool IsFlagSet( int nFlag ) const = 0;

 virtual int GetSplitScreenPlayerSlot() const = 0;
};












typedef enum
{
 VCREvent_Sys_FloatTime=0,
 VCREvent_recvfrom,
 VCREvent_SyncToken,
 VCREvent_GetCursorPos,
 VCREvent_SetCursorPos,
 VCREvent_ScreenToClient,
 VCREvent_Cmd_Exec,
 VCREvent_CmdLine,
 VCREvent_RegOpenKeyEx,
 VCREvent_RegSetValueEx,
 VCREvent_RegQueryValueEx,
 VCREvent_RegCreateKeyEx,
 VCREvent_RegCloseKey,
 VCREvent_PeekMessage,
 VCREvent_GameMsg,
 VCREvent_GetNumberOfConsoleInputEvents,
 VCREvent_ReadConsoleInput,
 VCREvent_GetKeyState,
 VCREvent_recv,
 VCREvent_send,
 VCREvent_Generic,
 VCREvent_CreateThread,
 VCREvent_WaitForSingleObject,
 VCREvent_EnterCriticalSection,
 VCREvent_Time,
 VCREvent_LocalTime,
 VCREvent_GenericString,
 VCREvent_NUMEVENTS
} VCREvent;



extern "C" void BuildCmdLine( int argc, tchar **argv );
tchar *GetCommandLine();
struct InputEvent_t;





enum VCRMode_t
{
 VCR_Invalid=-1,
 VCR_Disabled=0,
 VCR_Record,
 VCR_Playback
};





class IVCRHelpers
{
public:
 virtual void ErrorMessage( const tchar *pMsg ) = 0;
 virtual void* GetMainWindow() = 0;
};



class IVCRTrace
{
public:
 virtual VCREvent ReadEvent() = 0;
 virtual void Read( void *pDest, int size ) = 0;
};

typedef struct VCR_s
{

 int (*Start)( tchar const *pFilename, bool bRecord, IVCRHelpers *pHelpers );
 void (*End)();


 IVCRTrace* (*GetVCRTraceInterface)();


 VCRMode_t (*GetMode)();





 void (*SetEnabled)(int bEnabled);


 void (*SyncToken)(tchar const *pToken);


 double (*Hook_Sys_FloatTime)(double time);



 int (*Hook_PeekMessage)(
  struct tagMSG *msg,
  void *hWnd,
  unsigned int wMsgFilterMin,
  unsigned int wMsgFilterMax,
  unsigned int wRemoveMsg
  );


 void (*Hook_RecordGameMsg)( const InputEvent_t &event );
 void (*Hook_RecordEndGameMsg)();


 bool (*Hook_PlaybackGameMsg)( InputEvent_t *pEvent );


 int (*Hook_recvfrom)(int s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen);

 void (*Hook_GetCursorPos)(struct tagPOINT *pt);
 void (*Hook_ScreenToClient)(void *hWnd, struct tagPOINT *pt);

 void (*Hook_Cmd_Exec)(tchar **f);

 tchar* (*Hook_GetCommandLine)();


 long (*Hook_RegOpenKeyEx)( void *hKey, const tchar *lpSubKey, unsigned long ulOptions, unsigned long samDesired, void *pHKey );
 long (*Hook_RegSetValueEx)(void *hKey, tchar const *lpValueName, unsigned long Reserved, unsigned long dwType, uint8 const *lpData, unsigned long cbData);
 long (*Hook_RegQueryValueEx)(void *hKey, tchar const *lpValueName, unsigned long *lpReserved, unsigned long *lpType, uint8 *lpData, unsigned long *lpcbData);
 long (*Hook_RegCreateKeyEx)(void *hKey, tchar const *lpSubKey, unsigned long Reserved, tchar *lpClass, unsigned long dwOptions, unsigned long samDesired, void *lpSecurityAttributes, void *phkResult, unsigned long *lpdwDisposition);
 void (*Hook_RegCloseKey)(void *hKey);


 int (*Hook_GetNumberOfConsoleInputEvents)( void *hInput, unsigned long *pNumEvents );



 int (*Hook_ReadConsoleInput)( void *hInput, void *pRecs, int nMaxRecs, unsigned long *pNumRead );



 void (*Hook_LocalTime)( struct tm *today );

 short (*Hook_GetKeyState)( int nVirtKey );


 int (*Hook_recv)( int s, char *buf, int len, int flags );
 int (*Hook_send)( int s, const char *buf, int len, int flags );




 void (*GenericRecord)( const tchar *pEventName, const void *pData, int len );




 int (*GenericPlayback)( const tchar *pEventName, void *pOutData, int maxLen, bool bForceLenSame );






 void (*GenericValue)( const tchar *pEventName, void *pData, int maxLen );


 double (*GetPercentCompleted)();



 void* (*Hook_CreateThread)(
  void *lpThreadAttributes,
  unsigned long dwStackSize,
  void *lpStartAddress,
  void *lpParameter,
  unsigned long dwCreationFlags,
  unsigned long *lpThreadID );

 unsigned long (*Hook_WaitForSingleObject)(
  void *handle,
  unsigned long dwMilliseconds );

 void (*Hook_EnterCriticalSection)( void *pCS );

 void (*Hook_Time)( long *pTime );


 void (*GenericString)( const char *pEventName, const char *pString );


 void (*GenericValueVerify)( const tchar *pEventName, const void *pData, int maxLen );

 unsigned long (*Hook_WaitForMultipleObjects)( uint32 nHandles, const void **pHandles, int bWaitAll, uint32 timeout );

} VCR_t;





extern "C" VCR_t *g_pVCR;



struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () __attribute__ ((__warn_unused_result__));
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}



typedef int __jmp_buf[6];



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__regparm__ (1)));
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  __attribute__ ((__regparm__ (1)));
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__regparm__ (1)));
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  __attribute__ ((__regparm__ (1)));



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__regparm__ (1))) __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}

const unsigned TT_INFINITE = 0xffffffff;
typedef unsigned long ThreadId_t;







typedef struct ThreadHandle_t__ *ThreadHandle_t;
typedef unsigned (*ThreadFunc_t)( void *pParam );

extern ThreadHandle_t CreateSimpleThread( ThreadFunc_t, void *pParam, ThreadId_t *pID, unsigned stackSize = 0 );
extern "C" ThreadHandle_t CreateSimpleThread( ThreadFunc_t, void *pParam, unsigned stackSize = 0 );
extern "C" bool ReleaseThreadHandle( ThreadHandle_t );




extern "C" void ThreadSleep(unsigned duration = 0);
extern "C" uint ThreadGetCurrentId();
extern "C" ThreadHandle_t ThreadGetCurrentHandle();
extern "C" int ThreadGetPriority( ThreadHandle_t hThread = 
                                                            __null 
                                                                 );
extern "C" bool ThreadSetPriority( ThreadHandle_t hThread, int priority );
inline bool ThreadSetPriority( int priority ) { return ThreadSetPriority( 
                                                                           __null
                                                                               , priority ); }
extern "C" bool ThreadInMainThread();
extern "C" void DeclareCurrentThreadIsMainThread();


typedef int (*ThreadedLoadLibraryFunc_t)();
extern "C" void SetThreadedLoadLibraryFunc( ThreadedLoadLibraryFunc_t func );
extern "C" ThreadedLoadLibraryFunc_t GetThreadedLoadLibraryFunc();






inline void ThreadPause()
{



 __asm __volatile("pause");




}

extern "C" bool ThreadJoin( ThreadHandle_t, unsigned timeout = TT_INFINITE );

extern "C" void ThreadSetDebugName( ThreadId_t id, const char *pszName );
inline void ThreadSetDebugName( const char *pszName ) { ThreadSetDebugName( (ThreadId_t)-1, pszName ); }

extern "C" void ThreadSetAffinity( ThreadHandle_t hThread, int nAffinityMask );



enum ThreadWaitResult_t
{
 TW_FAILED = 0xffffffff,
 TW_TIMEOUT = 0x00000102,
};
extern "C" long ThreadInterlockedIncrement( long volatile * );
extern "C" long ThreadInterlockedDecrement( long volatile * );
extern "C" long ThreadInterlockedExchange( long volatile *, long value );
extern "C" long ThreadInterlockedExchangeAdd( long volatile *, long value );
extern "C" long ThreadInterlockedCompareExchange( long volatile *, long value, long comperand );
extern "C" bool ThreadInterlockedAssignIf( long volatile *, long value, long comperand );


inline unsigned ThreadInterlockedExchangeSubtract( long volatile *p, long value ) { return ThreadInterlockedExchangeAdd( (long volatile *)p, -value ); }







extern "C" void *ThreadInterlockedExchangePointer( void * volatile *, void *value );
extern "C" void *ThreadInterlockedCompareExchangePointer( void * volatile *, void *value, void *comperand );
extern "C" bool ThreadInterlockedAssignPointerIf( void * volatile *, void *value, void *comperand );


inline void const *ThreadInterlockedExchangePointerToConst( void const * volatile *p, void const *value ) { return ThreadInterlockedExchangePointer( const_cast < void * volatile * > ( p ), const_cast < void * > ( value ) ); }
inline void const *ThreadInterlockedCompareExchangePointerToConst( void const * volatile *p, void const *value, void const *comperand ) { return ThreadInterlockedCompareExchangePointer( const_cast < void * volatile * > ( p ), const_cast < void * > ( value ), const_cast < void * > ( comperand ) ); }
inline bool ThreadInterlockedAssignPointerToConstIf( void const * volatile *p, void const *value, void const *comperand ) { return ThreadInterlockedAssignPointerIf( const_cast < void * volatile * > ( p ), const_cast < void * > ( value ), const_cast < void * > ( comperand ) ); }

extern "C" int64 ThreadInterlockedIncrement64( int64 volatile * );
extern "C" int64 ThreadInterlockedDecrement64( int64 volatile * );
extern "C" int64 ThreadInterlockedCompareExchange64( int64 volatile *, int64 value, int64 comperand );
extern "C" int64 ThreadInterlockedExchange64( int64 volatile *, int64 value );
extern "C" int64 ThreadInterlockedExchangeAdd64( int64 volatile *, int64 value );
extern "C" bool ThreadInterlockedAssignIf64(volatile int64 *pDest, int64 value, int64 comperand );

inline unsigned ThreadInterlockedExchangeSubtract( unsigned volatile *p, unsigned value ) { return ThreadInterlockedExchangeAdd( (long volatile *)p, value ); }
inline unsigned ThreadInterlockedIncrement( unsigned volatile *p ) { return ThreadInterlockedIncrement( (long volatile *)p ); }
inline unsigned ThreadInterlockedDecrement( unsigned volatile *p ) { return ThreadInterlockedDecrement( (long volatile *)p ); }
inline unsigned ThreadInterlockedExchange( unsigned volatile *p, unsigned value ) { return ThreadInterlockedExchange( (long volatile *)p, value ); }
inline unsigned ThreadInterlockedExchangeAdd( unsigned volatile *p, unsigned value ) { return ThreadInterlockedExchangeAdd( (long volatile *)p, value ); }
inline unsigned ThreadInterlockedCompareExchange( unsigned volatile *p, unsigned value, unsigned comperand ) { return ThreadInterlockedCompareExchange( (long volatile *)p, value, comperand ); }
inline bool ThreadInterlockedAssignIf( unsigned volatile *p, unsigned value, unsigned comperand ) { return ThreadInterlockedAssignIf( (long volatile *)p, value, comperand ); }

inline int ThreadInterlockedExchangeSubtract( int volatile *p, int value ) { return ThreadInterlockedExchangeAdd( (long volatile *)p, value ); }
inline int ThreadInterlockedIncrement( int volatile *p ) { return ThreadInterlockedIncrement( (long volatile *)p ); }
inline int ThreadInterlockedDecrement( int volatile *p ) { return ThreadInterlockedDecrement( (long volatile *)p ); }
inline int ThreadInterlockedExchange( int volatile *p, int value ) { return ThreadInterlockedExchange( (long volatile *)p, value ); }
inline int ThreadInterlockedExchangeAdd( int volatile *p, int value ) { return ThreadInterlockedExchangeAdd( (long volatile *)p, value ); }
inline int ThreadInterlockedCompareExchange( int volatile *p, int value, int comperand ) { return ThreadInterlockedCompareExchange( (long volatile *)p, value, comperand ); }
inline bool ThreadInterlockedAssignIf( int volatile *p, int value, int comperand ) { return ThreadInterlockedAssignIf( (long volatile *)p, value, comperand ); }
class CThreadLocalBase
{
public:
 CThreadLocalBase();
 ~CThreadLocalBase();

 void * Get() const;
 void Set(void *);

private:



 pthread_key_t m_index;

};





template <class T>
class CThreadLocal : public CThreadLocalBase
{
public:
 CThreadLocal()
 {
  ;
 }

 T Get() const
 {
  return reinterpret_cast<T>(CThreadLocalBase::Get());
 }

 void Set(T val)
 {
  CThreadLocalBase::Set(reinterpret_cast<void *>(val));
 }
};





template <class T = int>
class CThreadLocalInt : public CThreadLocal<T>
{
public:
 operator const T() const { return CThreadLocal<T>::Get(); }
 int operator=( T i ) { Set( i ); return i; }

 T operator++() { T i = CThreadLocal<T>::Get(); Set( ++i ); return i; }
 T operator++(int) { T i = CThreadLocal<T>::Get(); Set( i + 1 ); return i; }

 T operator--() { T i = CThreadLocal<T>::Get(); Set( --i ); return i; }
 T operator--(int) { T i = CThreadLocal<T>::Get(); Set( i - 1 ); return i; }
};



template <class T>
class CThreadLocalPtr : private CThreadLocalBase
{
public:
 CThreadLocalPtr() {}

 operator const void *() const { return (T *)Get(); }
 operator void *() { return (T *)Get(); }

 operator const T *() const { return (T *)Get(); }
 operator const T *() { return (T *)Get(); }
 operator T *() { return (T *)Get(); }

 int operator=( int i ) { ((void)0); Set( 
                                                                                                  __null 
                                                                                                       ); return 0; }
 T * operator=( T *p ) { Set( p ); return p; }

 bool operator !() const { return (!Get()); }
 bool operator!=( int i ) const { ((void)0); return (Get() != 
                                                                                                                          __null
                                                                                                                              ); }
 bool operator==( int i ) const { ((void)0); return (Get() == 
                                                                                                                          __null
                                                                                                                              ); }
 bool operator==( const void *p ) const { return (Get() == p); }
 bool operator!=( const void *p ) const { return (Get() != p); }
 bool operator==( const T *p ) const { return operator==((void*)p); }
 bool operator!=( const T *p ) const { return operator!=((void*)p); }

 T * operator->() { return (T *)Get(); }
 T & operator *() { return *((T *)Get()); }

 const T * operator->() const { return (T *)Get(); }
 const T & operator *() const { return *((T *)Get()); }

 const T & operator[]( int i ) const { return *((T *)Get() + i); }
 T & operator[]( int i ) { return *((T *)Get() + i); }

private:

 CThreadLocalPtr( T *pFrom );
 CThreadLocalPtr( const CThreadLocalPtr<T> &from );
 T **operator &();
 T * const *operator &() const;
 void operator=( const CThreadLocalPtr<T> &from );
 bool operator==( const CThreadLocalPtr<T> &p ) const;
 bool operator!=( const CThreadLocalPtr<T> &p ) const;
};
template <typename T>
class CInterlockedIntT
{
public:
 CInterlockedIntT() : m_value( 0 ) { ; }
 CInterlockedIntT( T value ) : m_value( value ) {}

 operator T() const { return m_value; }

 bool operator!() const { return ( m_value == 0 ); }
 bool operator==( T rhs ) const { return ( m_value == rhs ); }
 bool operator!=( T rhs ) const { return ( m_value != rhs ); }

 T operator++() { return (T)ThreadInterlockedIncrement( (long *)&m_value ); }
 T operator++(int) { return operator++() - 1; }

 T operator--() { return (T)ThreadInterlockedDecrement( (long *)&m_value ); }
 T operator--(int) { return operator--() + 1; }

 bool AssignIf( T conditionValue, T newValue ) { return ThreadInterlockedAssignIf( (long *)&m_value, (long)newValue, (long)conditionValue ); }

 T operator=( T newValue ) { ThreadInterlockedExchange((long *)&m_value, newValue); return m_value; }

 void operator+=( T add ) { ThreadInterlockedExchangeAdd( (long *)&m_value, (long)add ); }
 void operator-=( T subtract ) { operator+=( -subtract ); }
 void operator*=( T multiplier ) {
  T original, result;
  do
  {
   original = m_value;
   result = original * multiplier;
  } while ( !AssignIf( original, result ) );
 }
 void operator/=( T divisor ) {
  T original, result;
  do
  {
   original = m_value;
   result = original / divisor;
  } while ( !AssignIf( original, result ) );
 }

 T operator+( T rhs ) const { return m_value + rhs; }
 T operator-( T rhs ) const { return m_value - rhs; }

private:
 volatile T m_value;
};

typedef CInterlockedIntT<int> CInterlockedInt;
typedef CInterlockedIntT<unsigned> CInterlockedUInt;



template <typename T>
class CInterlockedPtr
{
public:
 CInterlockedPtr() : m_value( 0 ) { ; }
 CInterlockedPtr( T *value ) : m_value( value ) {}

 operator T *() const { return m_value; }

 bool operator!() const { return ( m_value == 0 ); }
 bool operator==( T *rhs ) const { return ( m_value == rhs ); }
 bool operator!=( T *rhs ) const { return ( m_value != rhs ); }

 T *operator++() { return ((T *)ThreadInterlockedExchangeAdd( (long *)&m_value, sizeof(T) )) + 1; }
 T *operator++(int) { return (T *)ThreadInterlockedExchangeAdd( (long *)&m_value, sizeof(T) ); }

 T *operator--() { return ((T *)ThreadInterlockedExchangeAdd( (long *)&m_value, -sizeof(T) )) - 1; }
 T *operator--(int) { return (T *)ThreadInterlockedExchangeAdd( (long *)&m_value, -sizeof(T) ); }

 bool AssignIf( T *conditionValue, T *newValue ) { return ThreadInterlockedAssignPointerToConstIf( (void const **) &m_value, (void const *) newValue, (void const *) conditionValue ); }

 T *operator=( T *newValue ) { ThreadInterlockedExchangePointerToConst( (void const **) &m_value, (void const *) newValue ); return newValue; }

 void operator+=( int add ) { ThreadInterlockedExchangeAdd( (long *)&m_value, add * sizeof(T) ); }
 void operator-=( int subtract ) { operator+=( -subtract ); }

 T *operator+( int rhs ) const { return m_value + rhs; }
 T *operator-( int rhs ) const { return m_value - rhs; }
 T *operator+( unsigned rhs ) const { return m_value + rhs; }
 T *operator-( unsigned rhs ) const { return m_value - rhs; }
 size_t operator-( T *p ) const { return m_value - p; }
 size_t operator-( const CInterlockedPtr<T> &p ) const { return m_value - p.m_value; }

private:
 T * volatile m_value;
};
class CThreadMutex
{
public:
 CThreadMutex();
 ~CThreadMutex();




 void Lock();
 void Lock() const { (const_cast<CThreadMutex *>(this))->Lock(); }
 void Unlock();
 void Unlock() const { (const_cast<CThreadMutex *>(this))->Unlock(); }

 bool TryLock();
 bool TryLock() const { return (const_cast<CThreadMutex *>(this))->TryLock(); }





 bool AssertOwnedByCurrentThread();




 void SetTrace( bool );

private:

 CThreadMutex( const CThreadMutex & );
 CThreadMutex &operator=( const CThreadMutex & );
 pthread_mutex_t m_Mutex;
 pthread_mutexattr_t m_Attr;






 uint m_currentOwnerID;
 uint16 m_lockCount;
 bool m_bTrace;

};
typedef CThreadMutex CThreadFastMutex;






class CThreadNullMutex
{
public:
 static void Lock() {}
 static void Unlock() {}

 static bool TryLock() { return true; }
 static bool AssertOwnedByCurrentThread() { return true; }
 static void SetTrace( bool b ) {}

 static uint32 GetOwnerId() { return 0; }
 static int GetDepth() { return 0; }
};
template <class BaseClass, bool *pCondition>
class CThreadConditionalMutex : public BaseClass
{
public:
 void Lock() { if ( *pCondition ) BaseClass::Lock(); }
 void Lock() const { if ( *pCondition ) BaseClass::Lock(); }
 void Unlock() { if ( *pCondition ) BaseClass::Unlock(); }
 void Unlock() const { if ( *pCondition ) BaseClass::Unlock(); }

 bool TryLock() { if ( *pCondition ) return BaseClass::TryLock(); else return true; }
 bool TryLock() const { if ( *pCondition ) return BaseClass::TryLock(); else return true; }
 bool AssertOwnedByCurrentThread() { if ( *pCondition ) return BaseClass::AssertOwnedByCurrentThread(); else return true; }
 void SetTrace( bool b ) { if ( *pCondition ) BaseClass::SetTrace( b ); }
};





template <class BaseClass>
class CThreadTerminalMutex : public BaseClass
{
public:
 bool TryLock() { if ( !BaseClass::TryLock() ) { {}; return false; } return true; }
 bool TryLock() const { if ( !BaseClass::TryLock() ) { {}; return false; } return true; }
 void Lock() { if ( !TryLock() ) BaseClass::Lock(); }
 void Lock() const { if ( !TryLock() ) BaseClass::Lock(); }

};
template <class MUTEX_TYPE = CThreadMutex>
class CAutoLockT
{
public:
 inline CAutoLockT( MUTEX_TYPE &lock)
  : m_lock(lock)
 {
  m_lock.Lock();
 }

 inline CAutoLockT(const MUTEX_TYPE &lock)
  : m_lock(const_cast<MUTEX_TYPE &>(lock))
 {
  m_lock.Lock();
 }

 inline ~CAutoLockT()
 {
  m_lock.Unlock();
 }


private:
 MUTEX_TYPE &m_lock;


 CAutoLockT<MUTEX_TYPE>( const CAutoLockT<MUTEX_TYPE> & );
 CAutoLockT<MUTEX_TYPE> &operator=( const CAutoLockT<MUTEX_TYPE> & );
};

typedef CAutoLockT<CThreadMutex> CAutoLock;



template <int size> struct CAutoLockTypeDeducer {};
template <> struct CAutoLockTypeDeducer<sizeof(CThreadMutex)> { typedef CThreadMutex Type_t; };
template <> struct CAutoLockTypeDeducer<sizeof(CThreadNullMutex)> { typedef CThreadNullMutex Type_t; };
class CThreadSyncObject
{
public:
 ~CThreadSyncObject();




 bool operator!() const;
 bool Wait( uint32 dwTimeout = TT_INFINITE );

protected:
 CThreadSyncObject();
 void AssertUseable();




 pthread_mutex_t m_Mutex;
 pthread_cond_t m_Condition;
 bool m_bInitalized;
 int m_cSet;
 bool m_bManualReset;




private:
 CThreadSyncObject( const CThreadSyncObject & );
 CThreadSyncObject &operator=( const CThreadSyncObject & );
};
class CThreadEvent : public CThreadSyncObject
{
public:
 CThreadEvent( bool fManualReset = false );




 bool Set();




 bool Reset();




 bool Check();

 bool Wait( uint32 dwTimeout = TT_INFINITE );

private:
 CThreadEvent( const CThreadEvent & );
 CThreadEvent &operator=( const CThreadEvent & );

 CInterlockedInt m_cSet;

};


class CThreadManualEvent : public CThreadEvent
{
public:
 CThreadManualEvent()
  : CThreadEvent( true )
 {
 }
};

inline int ThreadWaitForEvents( int nEvents, const CThreadEvent *pEvents, bool bWaitAll = true, unsigned timeout = TT_INFINITE )
{

  ((void)0);
  return 0;



}







class CThreadRWLock
{
public:
 CThreadRWLock();

 void LockForRead();
 void UnlockRead();
 void LockForWrite();
 void UnlockWrite();

 void LockForRead() const { const_cast<CThreadRWLock *>(this)->LockForRead(); }
 void UnlockRead() const { const_cast<CThreadRWLock *>(this)->UnlockRead(); }
 void LockForWrite() const { const_cast<CThreadRWLock *>(this)->LockForWrite(); }
 void UnlockWrite() const { const_cast<CThreadRWLock *>(this)->UnlockWrite(); }

private:
 void WaitForRead();

 CThreadFastMutex m_mutex;
 CThreadEvent m_CanWrite;
 CThreadEvent m_CanRead;

 int m_nWriters;
 int m_nActiveReaders;
 int m_nPendingReaders;
};
class __attribute__((aligned(8))) CThreadSpinRWLock
{
public:
 CThreadSpinRWLock() { ; ((void)0); memset( this, 0, sizeof( *this ) ); }

 bool TryLockForWrite();
 bool TryLockForRead();

 void LockForRead();
 void UnlockRead();
 void LockForWrite();
 void UnlockWrite();

 bool TryLockForWrite() const { return const_cast<CThreadSpinRWLock *>(this)->TryLockForWrite(); }
 bool TryLockForRead() const { return const_cast<CThreadSpinRWLock *>(this)->TryLockForRead(); }
 void LockForRead() const { const_cast<CThreadSpinRWLock *>(this)->LockForRead(); }
 void UnlockRead() const { const_cast<CThreadSpinRWLock *>(this)->UnlockRead(); }
 void LockForWrite() const { const_cast<CThreadSpinRWLock *>(this)->LockForWrite(); }
 void UnlockWrite() const { const_cast<CThreadSpinRWLock *>(this)->UnlockWrite(); }

private:
 struct LockInfo_t
 {
  uint32 m_writerId;
  int m_nReaders;
 };

 bool AssignIf( const LockInfo_t &newValue, const LockInfo_t &comperand );
 bool TryLockForWrite( const uint32 threadId );
 void SpinLockForWrite( const uint32 threadId );

 volatile LockInfo_t m_lockInfo;
 CInterlockedInt m_nWriters;
};







class CThread
{
public:
 CThread();
 virtual ~CThread();



 const char *GetName();
 void SetName( const char * );

 size_t CalcStackDepth( void *pStackVariable ) { return ((byte *)m_pStackBase - (byte *)pStackVariable); }






 virtual bool Start( unsigned nBytesStack = 0 );


 bool IsAlive();



 bool Join( unsigned timeout = TT_INFINITE );
 int GetResult();






 void Stop( int exitCode = 0 );


 int GetPriority() const;


 bool SetPriority( int );


 unsigned Suspend();


 unsigned Resume();


 bool Terminate( int exitCode = 0 );
 static CThread *GetCurrentCThread();





 static void Yield();




 static void Sleep( unsigned duration );

protected:



 virtual bool Init();



 virtual int Run() = 0;


 virtual void OnExit();







 typedef unsigned (__attribute__ ((__stdcall__)) *ThreadProc_t)( void * );
 virtual ThreadProc_t GetThreadProc();

 CThreadMutex m_Lock;

private:
 enum Flags
 {
  SUPPORT_STOP_PROTOCOL = 1 << 0
 };



 struct ThreadInit_t
 {
  CThread * pThread;



  bool * pfInitSuccess;
 };

 static unsigned __attribute__ ((__stdcall__)) ThreadProc( void * pv );


 CThread( const CThread & );
 CThread &operator=( const CThread & );





 pthread_t m_threadId;

 int m_result;
 char m_szName[32];
 void * m_pStackBase;
 unsigned m_flags;
};
typedef CThread CWorkerThread;






template<class T> class CMessageQueue
{
 CThreadEvent SignalEvent;
 CThreadMutex QueueAccessMutex;


 struct MsgNode
 {
  MsgNode *Next;
  T Data;
 };

 MsgNode *Head;
 MsgNode *Tail;

public:
 CMessageQueue( void )
 {
  Head = Tail = 
               __null
                   ;
 }


 bool MessageWaiting( void )
 {
  return ( Head != 
                  __null 
                       );
 }

 void WaitMessage( T *pMsg )
 {
  for(;;)
  {
   while( ! MessageWaiting() )
    SignalEvent.Wait();
   QueueAccessMutex.Lock();
   if (! Head )
   {

    QueueAccessMutex.Unlock();
    continue;
   }
   *( pMsg ) = Head->Data;
   MsgNode *remove_this = Head;
   Head = Head->Next;
   if (! Head)
    Tail = 
          __null
              ;
   QueueAccessMutex.Unlock();
   delete remove_this;
   break;
  }
 }

 void QueueMessage( T const &Msg)
 {
  MsgNode *new1=new MsgNode;
  new1->Data=Msg;
  new1->Next=
            __null
                ;
  QueueAccessMutex.Lock();
  if ( Tail )
  {
   Tail->Next=new1;
   Tail = new1;
  }
  else
  {
   Head = new1;
   Tail = new1;
  }
  SignalEvent.Set();
  QueueAccessMutex.Unlock();
 }
};
inline CThreadMutex::CThreadMutex()
{

 pthread_mutexattr_init( &m_Attr );



 pthread_mutexattr_settype( &m_Attr, PTHREAD_MUTEX_RECURSIVE_NP );
 pthread_mutex_init( &m_Mutex, &m_Attr );
}



inline CThreadMutex::~CThreadMutex()
{
 pthread_mutex_destroy( &m_Mutex );
}



inline void CThreadMutex::Lock()
{
 pthread_mutex_lock( &m_Mutex );
}



inline void CThreadMutex::Unlock()
{
 pthread_mutex_unlock( &m_Mutex );
}



inline bool CThreadMutex::AssertOwnedByCurrentThread()
{
 return true;
}



inline void CThreadMutex::SetTrace(bool fTrace)
{
}
inline CThreadRWLock::CThreadRWLock()
: m_CanRead( true ),
 m_nWriters( 0 ),
 m_nActiveReaders( 0 ),
 m_nPendingReaders( 0 )
{
}

inline void CThreadRWLock::LockForRead()
{
 m_mutex.Lock();
 if ( m_nWriters)
 {
  WaitForRead();
 }
 m_nActiveReaders++;
 m_mutex.Unlock();
}

inline void CThreadRWLock::UnlockRead()
{
 m_mutex.Lock();
 m_nActiveReaders--;
 if ( m_nActiveReaders == 0 && m_nWriters != 0 )
 {
  m_CanWrite.Set();
 }
 m_mutex.Unlock();
}
inline bool CThreadSpinRWLock::AssignIf( const LockInfo_t &newValue, const LockInfo_t &comperand )
{
 return ThreadInterlockedAssignIf64( (int64 *)&m_lockInfo, *((int64 *)&newValue), *((int64 *)&comperand) );
}

inline bool CThreadSpinRWLock::TryLockForWrite( const uint32 threadId )
{

 if ( m_lockInfo.m_nReaders > 0 || ( m_lockInfo.m_writerId && m_lockInfo.m_writerId != threadId ) )
 {
  return false;
 }

 static const LockInfo_t oldValue = { 0, 0 };
 LockInfo_t newValue = { threadId, 0 };
 const bool bSuccess = AssignIf( newValue, oldValue );






 return bSuccess;
}

inline bool CThreadSpinRWLock::TryLockForWrite()
{
 m_nWriters++;
 if ( !TryLockForWrite( ThreadGetCurrentId() ) )
 {
  m_nWriters--;
  return false;
 }
 return true;
}

inline bool CThreadSpinRWLock::TryLockForRead()
{
 if ( m_nWriters != 0 )
 {
  return false;
 }

 LockInfo_t oldValue;
 LockInfo_t newValue;

 oldValue.m_nReaders = m_lockInfo.m_nReaders;
 oldValue.m_writerId = 0;
 newValue.m_nReaders = oldValue.m_nReaders + 1;
 newValue.m_writerId = 0;

 const bool bSuccess = AssignIf( newValue, oldValue );






 return bSuccess;
}

inline void CThreadSpinRWLock::LockForWrite()
{
 const uint32 threadId = ThreadGetCurrentId();

 m_nWriters++;

 if ( !TryLockForWrite( threadId ) )
 {
  ThreadPause();
  SpinLockForWrite( threadId );
 }
}




extern "C" void *MemAllocScratch( int nMemSize );
extern "C" void MemFreeScratch();


extern "C" void ZeroMemory( void *mem, size_t length );
inline void *_aligned_malloc( size_t nSize, size_t align ) { return memalign( align, nSize ); }
inline void _aligned_free( void *ptr ) { free( ptr ); }

inline void *MemAlloc_Alloc( size_t nSize, const char *pFileName = 
                                                                  __null
                                                                      , int nLine = 0 ) { return malloc( nSize ); }
inline void MemAlloc_Free( void *ptr, const char *pFileName = 
                                                             __null
                                                                 , int nLine = 0 ) { free( ptr ); }

inline void *MemAlloc_AllocAligned( size_t size, size_t align, const char *pszFile = 
                                                                                    __null
                                                                                        , int nLine = 0 ) { return memalign( align, size ); }
inline void *MemAlloc_AllocAlignedFileLine( size_t size, size_t align, const char *pszFile = 
                                                                                            __null
                                                                                                , int nLine = 0 ) { return memalign( align, size ); }
inline void MemAlloc_FreeAligned( void *pMemBlock, const char *pszFile = 
                                                                        __null
                                                                            , int nLine = 0 ) { free( pMemBlock ); }




inline size_t _msize( void *ptr ) { return malloc_usable_size( ptr ); }


inline void *MemAlloc_ReallocAligned( void *ptr, size_t size, size_t align )
{
 void *ptr_new_aligned = memalign( align, size );

 if( ptr_new_aligned )
 {
  size_t old_size = _msize( ptr );
  size_t copy_size = ( size < old_size ) ? size : old_size;

  memcpy( ptr_new_aligned, ptr, copy_size );
  free( ptr );
 }

 return ptr_new_aligned;
}
template< class T, class I = int >
class CUtlMemory
{
public:

 CUtlMemory( int nGrowSize = 0, int nInitSize = 0 );
 CUtlMemory( T* pMemory, int numElements );
 CUtlMemory( const T* pMemory, int numElements );
 ~CUtlMemory();


 void Init( int nGrowSize = 0, int nInitSize = 0 );

 class Iterator_t
 {
 public:
  Iterator_t( I i ) : index( i ) {}
  I index;

  bool operator==( const Iterator_t it ) const { return index == it.index; }
  bool operator!=( const Iterator_t it ) const { return index != it.index; }
 };
 Iterator_t First() const { return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex() ); }
 Iterator_t Next( const Iterator_t &it ) const { return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex() ); }
 I GetIndex( const Iterator_t &it ) const { return it.index; }
 bool IsIdxAfter( I i, const Iterator_t &it ) const { return i > it.index; }
 bool IsValidIterator( const Iterator_t &it ) const { return IsIdxValid( it.index ); }
 Iterator_t InvalidIterator() const { return Iterator_t( InvalidIndex() ); }


 T& operator[]( I i );
 const T& operator[]( I i ) const;
 T& Element( I i );
 const T& Element( I i ) const;


 bool IsIdxValid( I i ) const;
 static I InvalidIndex() { return ( I )-1; }


 T* Base();
 const T* Base() const;


 void SetExternalBuffer( T* pMemory, int numElements );
 void SetExternalBuffer( const T* pMemory, int numElements );
 void AssumeMemory( T *pMemory, int nSize );


 void Swap( CUtlMemory< T, I > &mem );



 void ConvertToGrowableMemory( int nGrowSize );


 int NumAllocated() const;
 int Count() const;


 void Grow( int num = 1 );


 void EnsureCapacity( int num );


 void Purge();


 void Purge( int numElements );


 bool IsExternallyAllocated() const;


 bool IsReadOnly() const;


 void SetGrowSize( int size );

protected:
 void ValidateGrowSize()
 {
 }

 enum
 {
  EXTERNAL_BUFFER_MARKER = -1,
  EXTERNAL_CONST_BUFFER_MARKER = -2,
 };

 T* m_pMemory;
 int m_nAllocationCount;
 int m_nGrowSize;
};






template< class T, size_t SIZE, class I = int >
class CUtlMemoryFixedGrowable : public CUtlMemory< T, I >
{
 typedef CUtlMemory< T, I > BaseClass;

public:
 CUtlMemoryFixedGrowable( int nGrowSize = 0, int nInitSize = SIZE ) : BaseClass( m_pFixedMemory, SIZE )
 {
  ((void)0);
  m_nMallocGrowSize = nGrowSize;
 }

 void Grow( int nCount = 1 )
 {
  if ( CUtlMemory<T, I>::IsExternallyAllocated() )
  {
   CUtlMemory<T, I>::ConvertToGrowableMemory( m_nMallocGrowSize );
  }
  BaseClass::Grow( nCount );
 }

 void EnsureCapacity( int num )
 {
  if ( CUtlMemory<T>::m_nAllocationCount >= num )
   return;

  if ( CUtlMemory<T, I>::IsExternallyAllocated() )
  {

   CUtlMemory<T, I>::ConvertToGrowableMemory( m_nMallocGrowSize );
  }

  BaseClass::EnsureCapacity( num );
 }

private:
 int m_nMallocGrowSize;
 T m_pFixedMemory[ SIZE ];
};





template< typename T, size_t SIZE, int nAlignment = 0 >
class CUtlMemoryFixed
{
public:

 CUtlMemoryFixed( int nGrowSize = 0, int nInitSize = 0 ) { ((void)0); }
 CUtlMemoryFixed( T* pMemory, int numElements ) { ((void)0); }


 bool IsIdxValid( int i ) const { return (i >= 0) && (i < (int)SIZE); }
 static int InvalidIndex() { return -1; }


 T* Base() { if ( nAlignment == 0 ) return (T*)(&m_Memory[0]); else return (T*)AlignValue( &m_Memory[0], nAlignment ); }
 const T* Base() const { if ( nAlignment == 0 ) return (T*)(&m_Memory[0]); else return (T*)AlignValue( &m_Memory[0], nAlignment ); }


 T& operator[]( int i ) { ((void)0); return Base()[i]; }
 const T& operator[]( int i ) const { ((void)0); return Base()[i]; }
 T& Element( int i ) { ((void)0); return Base()[i]; }
 const T& Element( int i ) const { ((void)0); return Base()[i]; }


 void SetExternalBuffer( T* pMemory, int numElements ) { ((void)0); }


 int NumAllocated() const { return SIZE; }
 int Count() const { return SIZE; }


 void Grow( int num = 1 ) { ((void)0); }


 void EnsureCapacity( int num ) { ((void)0); }


 void Purge() {}


 void Purge( int numElements ) { ((void)0); }


 bool IsExternallyAllocated() const { return false; }


 void SetGrowSize( int size ) {}

 class Iterator_t
 {
 public:
  Iterator_t( int i ) : index( i ) {}
  int index;
  bool operator==( const Iterator_t it ) const { return index == it.index; }
  bool operator!=( const Iterator_t it ) const { return index != it.index; }
 };
 Iterator_t First() const { return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex() ); }
 Iterator_t Next( const Iterator_t &it ) const { return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex() ); }
 int GetIndex( const Iterator_t &it ) const { return it.index; }
 bool IsIdxAfter( int i, const Iterator_t &it ) const { return i > it.index; }
 bool IsValidIterator( const Iterator_t &it ) const { return IsIdxValid( it.index ); }
 Iterator_t InvalidIterator() const { return Iterator_t( InvalidIndex() ); }

private:
 char m_Memory[ SIZE*sizeof(T) + nAlignment ];
};





template< class T, class I >
CUtlMemory<T,I>::CUtlMemory( int nGrowSize, int nInitAllocationCount ) : m_pMemory(0),
 m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize )
{
 ValidateGrowSize();
 ((void)0);
 if (m_nAllocationCount)
 {
  ((void)0);
  ;
  m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
 }
}

template< class T, class I >
CUtlMemory<T,I>::CUtlMemory( T* pMemory, int numElements ) : m_pMemory(pMemory),
 m_nAllocationCount( numElements )
{

 m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T, class I >
CUtlMemory<T,I>::CUtlMemory( const T* pMemory, int numElements ) : m_pMemory( (T*)pMemory ),
 m_nAllocationCount( numElements )
{

 m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T, class I >
CUtlMemory<T,I>::~CUtlMemory()
{
 Purge();
}

template< class T, class I >
void CUtlMemory<T,I>::Init( int nGrowSize , int nInitSize )
{
 Purge();

 m_nGrowSize = nGrowSize;
 m_nAllocationCount = nInitSize;
 ValidateGrowSize();
 ((void)0);
 if (m_nAllocationCount)
 {
  ((void)0);
  ;
  m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
 }
}




template< class T, class I >
void CUtlMemory<T,I>::Swap( CUtlMemory<T,I> &mem )
{
 swap( m_nGrowSize, mem.m_nGrowSize );
 swap( m_pMemory, mem.m_pMemory );
 swap( m_nAllocationCount, mem.m_nAllocationCount );
}





template< class T, class I >
void CUtlMemory<T,I>::ConvertToGrowableMemory( int nGrowSize )
{
 if ( !IsExternallyAllocated() )
  return;

 m_nGrowSize = nGrowSize;
 if (m_nAllocationCount)
 {
  ((void)0);
  ;

  int nNumBytes = m_nAllocationCount * sizeof(T);
  T *pMemory = (T*)malloc( nNumBytes );
  memcpy( pMemory, m_pMemory, nNumBytes );
  m_pMemory = pMemory;
 }
 else
 {
  m_pMemory = 
             __null
                 ;
 }
}





template< class T, class I >
void CUtlMemory<T,I>::SetExternalBuffer( T* pMemory, int numElements )
{

 Purge();

 m_pMemory = pMemory;
 m_nAllocationCount = numElements;


 m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T, class I >
void CUtlMemory<T,I>::SetExternalBuffer( const T* pMemory, int numElements )
{

 Purge();

 m_pMemory = const_cast<T*>( pMemory );
 m_nAllocationCount = numElements;


 m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T, class I >
void CUtlMemory<T,I>::AssumeMemory( T* pMemory, int numElements )
{

 Purge();


 m_pMemory = pMemory;
 m_nAllocationCount = numElements;
}





template< class T, class I >
inline T& CUtlMemory<T,I>::operator[]( I i )
{
 ((void)0);
 ((void)0);
 return m_pMemory[i];
}

template< class T, class I >
inline const T& CUtlMemory<T,I>::operator[]( I i ) const
{
 ((void)0);
 return m_pMemory[i];
}

template< class T, class I >
inline T& CUtlMemory<T,I>::Element( I i )
{
 ((void)0);
 ((void)0);
 return m_pMemory[i];
}

template< class T, class I >
inline const T& CUtlMemory<T,I>::Element( I i ) const
{
 ((void)0);
 return m_pMemory[i];
}





template< class T, class I >
bool CUtlMemory<T,I>::IsExternallyAllocated() const
{
 return (m_nGrowSize < 0);
}





template< class T, class I >
bool CUtlMemory<T,I>::IsReadOnly() const
{
 return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}


template< class T, class I >
void CUtlMemory<T,I>::SetGrowSize( int nSize )
{
 ((void)0);
 ((void)0);
 m_nGrowSize = nSize;
 ValidateGrowSize();
}





template< class T, class I >
inline T* CUtlMemory<T,I>::Base()
{
 ((void)0);
 return m_pMemory;
}

template< class T, class I >
inline const T *CUtlMemory<T,I>::Base() const
{
 return m_pMemory;
}





template< class T, class I >
inline int CUtlMemory<T,I>::NumAllocated() const
{
 return m_nAllocationCount;
}

template< class T, class I >
inline int CUtlMemory<T,I>::Count() const
{
 return m_nAllocationCount;
}





template< class T, class I >
inline bool CUtlMemory<T,I>::IsIdxValid( I i ) const
{
 int idx = (int)i;
 return idx >= 0 && idx < m_nAllocationCount;
}




inline int UtlMemory_CalcNewAllocationCount( int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem )
{
 if ( nGrowSize )
 {
  nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);
 }
 else
 {
  if ( !nAllocationCount )
  {

   nAllocationCount = (31 + nBytesItem) / nBytesItem;
  }

  while (nAllocationCount < nNewSize)
  {

   nAllocationCount *= 2;







  }
 }

 return nAllocationCount;
}

template< class T, class I >
void CUtlMemory<T,I>::Grow( int num )
{
 ((void)0);

 if ( IsExternallyAllocated() )
 {

  ((void)0);
  return;
 }



 int nAllocationRequested = m_nAllocationCount + num;

 ((void)0);

 m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );


 if ( ( int )( I )m_nAllocationCount < nAllocationRequested )
 {
  if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )
  {
   --m_nAllocationCount;
  }
  else
  {
   if ( ( int )( I )nAllocationRequested != nAllocationRequested )
   {

    ((void)0);
    return;
   }
   while ( ( int )( I )m_nAllocationCount < nAllocationRequested )
   {
    m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;
   }
  }
 }

 ((void)0);

 if (m_pMemory)
 {
  ;
  m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
  ((void)0);
 }
 else
 {
  ;
  m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
  ((void)0);
 }
}





template< class T, class I >
inline void CUtlMemory<T,I>::EnsureCapacity( int num )
{
 if (m_nAllocationCount >= num)
  return;

 if ( IsExternallyAllocated() )
 {

  ((void)0);
  return;
 }

 ((void)0);

 m_nAllocationCount = num;

 ((void)0);

 if (m_pMemory)
 {
  ;
  m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
 }
 else
 {
  ;
  m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
 }
}





template< class T, class I >
void CUtlMemory<T,I>::Purge()
{
 if ( !IsExternallyAllocated() )
 {
  if (m_pMemory)
  {
   ((void)0);
   free( (void*)m_pMemory );
   m_pMemory = 0;
  }
  m_nAllocationCount = 0;
 }
}

template< class T, class I >
void CUtlMemory<T,I>::Purge( int numElements )
{
 ((void)0);

 if( numElements > m_nAllocationCount )
 {

  ((void)0);
  return;
 }


 if( numElements == 0 )
 {
  Purge();
  return;
 }

 if ( IsExternallyAllocated() )
 {

  return;
 }


 if( numElements == m_nAllocationCount )
 {
  return;
 }


 if( !m_pMemory )
 {

  ((void)0);
  return;
 }

 ((void)0);

 m_nAllocationCount = numElements;

 ((void)0);


 ;
 m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
}





template< class T, int nAlignment >
class CUtlMemoryAligned : public CUtlMemory<T>
{
public:

 CUtlMemoryAligned( int nGrowSize = 0, int nInitSize = 0 );
 CUtlMemoryAligned( T* pMemory, int numElements );
 CUtlMemoryAligned( const T* pMemory, int numElements );
 ~CUtlMemoryAligned();


 void SetExternalBuffer( T* pMemory, int numElements );
 void SetExternalBuffer( const T* pMemory, int numElements );


 void Grow( int num = 1 );


 void EnsureCapacity( int num );


 void Purge();


 void Purge( int numElements ) { ((void)0); }

private:
 void *Align( const void *pAddr );
};





template< class T, int nAlignment >
void *CUtlMemoryAligned<T, nAlignment>::Align( const void *pAddr )
{
 size_t nAlignmentMask = nAlignment - 1;
 return (void*)( ((size_t)pAddr + nAlignmentMask) & (~nAlignmentMask) );
}





template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned( int nGrowSize, int nInitAllocationCount )
{
 CUtlMemory<T>::m_pMemory = 0;
 CUtlMemory<T>::m_nAllocationCount = nInitAllocationCount;
 CUtlMemory<T>::m_nGrowSize = nGrowSize;
 CUtlMemory<T>::ValidateGrowSize();


 ;
 ((void)0);
 if ( CUtlMemory<T>::m_nAllocationCount )
 {
  ((void)0);
  ;
  CUtlMemory<T>::m_pMemory = (T*)_aligned_malloc( nInitAllocationCount * sizeof(T), nAlignment );
 }
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned( T* pMemory, int numElements )
{

 CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_BUFFER_MARKER;

 CUtlMemory<T>::m_pMemory = (T*)Align( pMemory );
 CUtlMemory<T>::m_nAllocationCount = ( (int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory ) / sizeof(T);
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned( const T* pMemory, int numElements )
{

 CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_CONST_BUFFER_MARKER;

 CUtlMemory<T>::m_pMemory = (T*)Align( pMemory );
 CUtlMemory<T>::m_nAllocationCount = ( (int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory ) / sizeof(T);
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::~CUtlMemoryAligned()
{
 Purge();
}





template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::SetExternalBuffer( T* pMemory, int numElements )
{

 Purge();

 CUtlMemory<T>::m_pMemory = (T*)Align( pMemory );
 CUtlMemory<T>::m_nAllocationCount = ( (int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory ) / sizeof(T);


 CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_BUFFER_MARKER;
}

template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::SetExternalBuffer( const T* pMemory, int numElements )
{

 Purge();

 CUtlMemory<T>::m_pMemory = (T*)Align( pMemory );
 CUtlMemory<T>::m_nAllocationCount = ( (int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory ) / sizeof(T);


 CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_CONST_BUFFER_MARKER;
}





template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::Grow( int num )
{
 ((void)0);

 if ( CUtlMemory<T>::IsExternallyAllocated() )
 {

  ((void)0);
  return;
 }

 ((void)0);



 int nAllocationRequested = CUtlMemory<T>::m_nAllocationCount + num;

 CUtlMemory<T>::m_nAllocationCount = UtlMemory_CalcNewAllocationCount( CUtlMemory<T>::m_nAllocationCount, CUtlMemory<T>::m_nGrowSize, nAllocationRequested, sizeof(T) );

 ((void)0);

 if ( CUtlMemory<T>::m_pMemory )
 {
  ;
  CUtlMemory<T>::m_pMemory = (T*)_aligned_realloc( CUtlMemory<T>::m_pMemory, CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment );
  ((void)0);
 }
 else
 {
  ;
  CUtlMemory<T>::m_pMemory = (T*)_aligned_malloc( CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment );
  ((void)0);
 }
}





template< class T, int nAlignment >
inline void CUtlMemoryAligned<T, nAlignment>::EnsureCapacity( int num )
{
 if ( CUtlMemory<T>::m_nAllocationCount >= num )
  return;

 if ( CUtlMemory<T>::IsExternallyAllocated() )
 {

  ((void)0);
  return;
 }

 ((void)0);

 CUtlMemory<T>::m_nAllocationCount = num;

 ((void)0);

 if ( CUtlMemory<T>::m_pMemory )
 {
  ;
  CUtlMemory<T>::m_pMemory = (T*)_aligned_realloc( CUtlMemory<T>::m_pMemory, CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment );
 }
 else
 {
  ;
  CUtlMemory<T>::m_pMemory = (T*)_aligned_malloc( CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment );
 }
}





template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::Purge()
{
 if ( !CUtlMemory<T>::IsExternallyAllocated() )
 {
  if ( CUtlMemory<T>::m_pMemory )
  {
   ((void)0);
   _aligned_free( CUtlMemory<T>::m_pMemory );
   CUtlMemory<T>::m_pMemory = 0;
  }
  CUtlMemory<T>::m_nAllocationCount = 0;
 }
}


typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));


typedef int __v2si __attribute__ ((__vector_size__ (8)));
typedef short __v4hi __attribute__ ((__vector_size__ (8)));
typedef char __v8qi __attribute__ ((__vector_size__ (8)));
typedef long long __v1di __attribute__ ((__vector_size__ (8)));
typedef float __v2sf __attribute__ ((__vector_size__ (8)));


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_empty (void)
{
  __builtin_ia32_emms ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_empty (void)
{
  _mm_empty ();
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si64 (int __i)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int (int __i)
{
  return _mm_cvtsi32_si64 (__i);
}
extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si32 (__m64 __i)
{
  return __builtin_ia32_vec_ext_v2si ((__v2si)__i, 0);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int (__m64 __i)
{
  return _mm_cvtsi64_si32 (__i);
}
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packsswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packssdw (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi32 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packuswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pu16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhdq (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckldq (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddb (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddw (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddd (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi32 (__m1, __m2);
}



#pragma GCC push_options
#pragma GCC target("sse2")



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddq ((__v1di)__m1, (__v1di)__m2);
}


#pragma GCC pop_options




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubb (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubw (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubd (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi32 (__m1, __m2);
}



#pragma GCC push_options
#pragma GCC target("sse2")



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubq ((__v1di)__m1, (__v1di)__m2);
}


#pragma GCC pop_options




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaddwd (__m64 __m1, __m64 __m2)
{
  return _mm_madd_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhw (__m64 __m1, __m64 __m2)
{
  return _mm_mulhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmullw (__m64 __m1, __m64 __m2)
{
  return _mm_mullo_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllw (__m64 __m, __m64 __count)
{
  return _mm_sll_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllwi (__m64 __m, int __count)
{
  return _mm_slli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_pslld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslld (__m64 __m, __m64 __count)
{
  return _mm_sll_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_pslldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslldi (__m64 __m, int __count)
{
  return _mm_slli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllq (__m64 __m, __m64 __count)
{
  return _mm_sll_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllqi (__m64 __m, int __count)
{
  return _mm_slli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psraw (__m64 __m, __m64 __count)
{
  return _mm_sra_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrawi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrawi (__m64 __m, int __count)
{
  return _mm_srai_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrad ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrad (__m64 __m, __m64 __count)
{
  return _mm_sra_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psradi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psradi (__m64 __m, int __count)
{
  return _mm_srai_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlw (__m64 __m, __m64 __count)
{
  return _mm_srl_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlwi (__m64 __m, int __count)
{
  return _mm_srli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrld (__m64 __m, __m64 __count)
{
  return _mm_srl_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrldi (__m64 __m, int __count)
{
  return _mm_srli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlq (__m64 __m, __m64 __count)
{
  return _mm_srl_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlqi (__m64 __m, int __count)
{
  return _mm_srli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pand (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pand (__m64 __m1, __m64 __m2)
{
  return _mm_and_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pandn (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pandn (__m64 __m1, __m64 __m2)
{
  return _mm_andnot_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_por (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_por (__m64 __m1, __m64 __m2)
{
  return _mm_or_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pxor (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pxor (__m64 __m1, __m64 __m2)
{
  return _mm_xor_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi8 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi16 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi32 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si64 (void)
{
  return (__m64)0LL;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi32 (int __i1, int __i0)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
{
  return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
      char __b3, char __b2, char __b1, char __b0)
{
  return (__m64) __builtin_ia32_vec_init_v8qi (__b0, __b1, __b2, __b3,
            __b4, __b5, __b6, __b7);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi32 (int __i0, int __i1)
{
  return _mm_set_pi32 (__i1, __i0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)
{
  return _mm_set_pi16 (__w3, __w2, __w1, __w0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
       char __b4, char __b5, char __b6, char __b7)
{
  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi32 (int __i)
{
  return _mm_set_pi32 (__i, __i);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi16 (short __w)
{
  return _mm_set_pi16 (__w, __w, __w, __w);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi8 (char __b)
{
  return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);
}


extern "C" int posix_memalign (void **, size_t, size_t) throw ();


static __inline void *
_mm_malloc (size_t size, size_t alignment)
{
  void *ptr;
  if (alignment == 1)
    return malloc (size);
  if (alignment == 2 || (sizeof (void *) == 8 && alignment == 4))
    alignment = sizeof (void *);
  if (posix_memalign (&ptr, alignment, size) == 0)
    return ptr;
  else
    return __null;
}

static __inline void
_mm_free (void * ptr)
{
  free (ptr);
}


enum _mm_hint
{

  _MM_HINT_ET0 = 7,
  _MM_HINT_ET1 = 6,
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};




extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_prefetch (const void *__P, enum _mm_hint __I)
{
  __builtin_prefetch (__P, (__I & 0x4) >> 2, __I & 0x3);
}
typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));


typedef float __v4sf __attribute__ ((__vector_size__ (16)));
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_ps (void)
{
  __m128 __Y = __Y;
  return __Y;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_ps (void)
{
  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A + (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A - (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A * (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ps (__m128 __A, __m128 __B)
{
  return (__m128) ((__v4sf)__A / (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andnps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_orps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_xorps (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpltss ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpless ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnltss ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnless ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);
}




extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si32 (__m128 __A)
{
  return __builtin_ia32_cvtss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ss2si (__m128 __A)
{
  return _mm_cvtss_si32 (__A);
}
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ps2pi (__m128 __A)
{
  return _mm_cvtps_pi32 (__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si32 (__m128 __A)
{
  return __builtin_ia32_cvttss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ss2si (__m128 __A)
{
  return _mm_cvttss_si32 (__A);
}
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ps2pi (__m128 __A)
{
  return _mm_cvttps_pi32 (__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_ss (__m128 __A, int __B)
{
  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_si2ss (__m128 __A, int __B)
{
  return _mm_cvtsi32_ss (__A, __B);
}
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_ps (__m128 __A, __m64 __B)
{
  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_pi2ps (__m128 __A, __m64 __B)
{
  return _mm_cvtpi32_ps (__A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi16_ps (__m64 __A)
{
  __v4hi __sign;
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;




  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu16_ps (__m64 __A)
{
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi8_ps (__m64 __A)
{
  __v8qi __sign;




  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);


  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);

  return _mm_cvtpi16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu8_ps(__m64 __A)
{
  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);
  return _mm_cvtpu16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)
{
  __v4sf __zero = (__v4sf) _mm_setzero_ps ();
  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);
  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);
  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi16(__m128 __A)
{
  __v4sf __hisf = (__v4sf)__A;
  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);
  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);
  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);
  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi8(__m128 __A)
{
  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);
  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shuffle_ps (__m128 __A, __m128 __B, int const __mask)
{
  return (__m128) __builtin_ia32_shufps ((__v4sf)__A, (__v4sf)__B, __mask);
}







extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movehl_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movelh_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_ps (__m128 __A)
{
  return __builtin_ia32_movmskps ((__v4sf)__A);
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_getcsr (void)
{
  return __builtin_ia32_stmxcsr ();
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_STATE (void)
{
  return _mm_getcsr() & 0x003f;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_MASK (void)
{
  return _mm_getcsr() & 0x1f80;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_ROUNDING_MODE (void)
{
  return _mm_getcsr() & 0x6000;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_FLUSH_ZERO_MODE (void)
{
  return _mm_getcsr() & 0x8000;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setcsr (unsigned int __I)
{
  __builtin_ia32_ldmxcsr (__I);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_STATE(unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x003f) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_MASK (unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x1f80) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_ROUNDING_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x6000) | __mode);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x8000) | __mode);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ss (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_ps (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps1 (float __F)
{
  return _mm_set1_ps (__F);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ss (float const *__P)
{
  return _mm_set_ss (*__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_ps (float const *__P)
{
  return _mm_set1_ps (*__P);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps1 (float const *__P)
{
  return _mm_load1_ps (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps (float const *__P)
{
  return (__m128) *(__v4sf *)__P;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_ps (float const *__P)
{
  return (__m128) __builtin_ia32_loadups (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_ps (float const *__P)
{
  __v4sf __tmp = *(__v4sf *)__P;
  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)
{
  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_ps (float __Z, float __Y, float __X, float __W)
{
  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ss (float *__P, __m128 __A)
{
  *__P = ((__v4sf)__A)[0];
}

extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_f32 (__m128 __A)
{
  return ((__v4sf)__A)[0];
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps (float *__P, __m128 __A)
{
  *(__v4sf *)__P = (__v4sf)__A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_ps (float *__P, __m128 __A)
{
  __builtin_ia32_storeups (__P, (__v4sf)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((0) << 4) | ((0) << 2) | (0)));
  _mm_storeu_ps (__P, __tmp);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps1 (float *__P, __m128 __A)
{
  _mm_store1_ps (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
  _mm_store_ps (__P, __tmp);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf)__A, (__v4sf)__B);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_extract_pi16 (__m64 const __A, int const __N)
{
  return __builtin_ia32_vec_ext_v4hi ((__v4hi)__A, __N);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pextrw (__m64 const __A, int const __N)
{
  return _mm_extract_pi16 (__A, __N);
}
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_insert_pi16 (__m64 const __A, int const __D, int const __N)
{
  return (__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)__A, __D, __N);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pinsrw (__m64 const __A, int const __D, int const __N)
{
  return _mm_insert_pi16 (__A, __D, __N);
}
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxsw (__m64 __A, __m64 __B)
{
  return _mm_max_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxub (__m64 __A, __m64 __B)
{
  return _mm_max_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminsw (__m64 __A, __m64 __B)
{
  return _mm_min_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminub (__m64 __A, __m64 __B)
{
  return _mm_min_pu8 (__A, __B);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pi8 (__m64 __A)
{
  return __builtin_ia32_pmovmskb ((__v8qi)__A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmovmskb (__m64 __A)
{
  return _mm_movemask_pi8 (__A);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhuw (__m64 __A, __m64 __B)
{
  return _mm_mulhi_pu16 (__A, __B);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shuffle_pi16 (__m64 __A, int const __N)
{
  return (__m64) __builtin_ia32_pshufw ((__v4hi)__A, __N);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pshufw (__m64 __A, int const __N)
{
  return _mm_shuffle_pi16 (__A, __N);
}
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
{
  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_maskmovq (__m64 __A, __m64 __N, char *__P)
{
  _mm_maskmove_si64 (__A, __N, __P);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgb (__m64 __A, __m64 __B)
{
  return _mm_avg_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgw (__m64 __A, __m64 __B)
{
  return _mm_avg_pu16 (__A, __B);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psadbw (__m64 __A, __m64 __B)
{
  return _mm_sad_pu8 (__A, __B);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pi (__m64 *__P, __m64 __A)
{
  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_ps (float *__P, __m128 __A)
{
  __builtin_ia32_movntps (__P, (__v4sf)__A);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sfence (void)
{
  __builtin_ia32_sfence ();
}


#pragma GCC push_options
#pragma GCC target("sse2")




typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));
typedef int __v4si __attribute__ ((__vector_size__ (16)));
typedef unsigned int __v4su __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__ ((__vector_size__ (16)));
typedef unsigned short __v8hu __attribute__ ((__vector_size__ (16)));
typedef char __v16qi __attribute__ ((__vector_size__ (16)));
typedef unsigned char __v16qu __attribute__ ((__vector_size__ (16)));



typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));






extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_sd (double __F)
{
  return __extension__ (__m128d){ __F, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pd (double __F)
{
  return __extension__ (__m128d){ __F, __F };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd1 (double __F)
{
  return _mm_set1_pd (__F);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __X, __W };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __W, __X };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_pd (void)
{
  __m128d __Y = __Y;
  return __Y;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_pd (void)
{
  return __extension__ (__m128d){ 0.0, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd (double const *__P)
{
  return *(__m128d *)__P;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_pd (double const *__P)
{
  return __builtin_ia32_loadupd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_pd (double const *__P)
{
  return _mm_set1_pd (*__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_sd (double const *__P)
{
  return _mm_set_sd (*__P);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd1 (double const *__P)
{
  return _mm_load1_pd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_pd (double const *__P)
{
  __m128d __tmp = _mm_load_pd (__P);
  return __builtin_ia32_shufpd (__tmp, __tmp, (((0) << 1) | (1)));
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd (double *__P, __m128d __A)
{
  *(__m128d *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_pd (double *__P, __m128d __A)
{
  __builtin_ia32_storeupd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_sd (double *__P, __m128d __A)
{
  *__P = ((__v2df)__A)[0];
}

extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_f64 (__m128d __A)
{
  return ((__v2df)__A)[0];
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pd (double *__P, __m128d __A)
{
  _mm_store_sd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pd (double *__P, __m128d __A)
{
  *__P = ((__v2df)__A)[1];
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (0))));
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd1 (double *__P, __m128d __A)
{
  _mm_store1_pd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (1))));
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si32 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);
}
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A + (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A - (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A * (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_pd (__m128d __A, __m128d __B)
{
  return (__m128d) ((__v2df)__A / (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_pd (__m128d __A)
{
  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_sd (__m128d __A, __m128d __B)
{
  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpltsd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmplesd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnltsd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnlesd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64x (long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64 (__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x ((long long)__q1, (long long)__q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)
{
  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,
        short __q3, short __q2, short __q1, short __q0)
{
  return __extension__ (__m128i)(__v8hi){
    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,
       char __q11, char __q10, char __q09, char __q08,
       char __q07, char __q06, char __q05, char __q04,
       char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m128i)(__v16qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
  };
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64x (long long __A)
{
  return _mm_set_epi64x (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64 (__m64 __A)
{
  return _mm_set_epi64 (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi32 (int __A)
{
  return _mm_set_epi32 (__A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi16 (short __A)
{
  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi8 (char __A)
{
  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,
         __A, __A, __A, __A, __A, __A, __A, __A);
}




extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi64 (__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64 (__q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)
{
  return _mm_set_epi32 (__q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,
         short __q4, short __q5, short __q6, short __q7)
{
  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,
        char __q04, char __q05, char __q06, char __q07,
        char __q08, char __q09, char __q10, char __q11,
        char __q12, char __q13, char __q14, char __q15)
{
  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
         __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_si128 (__m128i const *__P)
{
  return *__P;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si128 (__m128i const *__P)
{
  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_epi64 (__m128i const *__P)
{
  return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_si128 (__m128i *__P, __m128i __B)
{
  *__P = __B;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si128 (__m128i *__P, __m128i __B)
{
  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_epi64 (__m128i *__P, __m128i __B)
{
  *(long long *)__P = ((__v2di)__B)[0];
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi64_pi64 (__m128i __B)
{
  return (__m64) ((__v2di)__B)[0];
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movpi64_epi64 (__m64 __A)
{
  return _mm_set_epi64 ((__m64)0LL, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_epi64 (__m128i __A)
{
  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_undefined_si128 (void)
{
  __m128i __Y = __Y;
  return __Y;
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_pd (__m128i __A)
{
  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_ps (__m128i __A)
{
  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_ps (__m128d __A)
{
  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_pd (__m64 __A)
{
  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pd (__m128 __A)
{
  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si ((__v2df) __A);
}
extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si ((__v2df) __A);
}
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_ss (__m128 __A, __m128d __B)
{
  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_sd (__m128d __A, int __B)
{
  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);
}
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_sd (__m128d __A, __m128 __B)
{
  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)
{
  return (__m128d)__builtin_ia32_shufpd ((__v2df)__A, (__v2df)__B, __mask);
}






extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pd (__m128d __A)
{
  return __builtin_ia32_movmskpd ((__v2df)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packus_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qu)__A + (__v16qu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hu)__A + (__v8hu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4su)__A + (__v4su)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A + (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qu)__A - (__v16qu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hu)__A - (__v8hu)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4su)__A - (__v4su)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A - (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hu)__A * (__v8hu)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_su32 (__m64 __A, __m64 __B)
{
  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_bsrli_si128 (__m128i __A, const int __N)
{
  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_bslli_si128 (__m128i __A, const int __N)
{
  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_si128 (__m128i __A, const int __N)
{
  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_si128 (__m128i __A, const int __N)
{
  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);
}
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si128 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A & (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si128 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A | (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si128 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v2du)__A ^ (__v2du)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hi)__A == (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4si)__A == (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qi)__A < (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hi)__A < (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4si)__A < (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v16qi)__A > (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v8hi)__A > (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i) ((__v4si)__A > (__v4si)__B);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_extract_epi16 (__m128i const __A, int const __N)
{
  return (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)__A, __N);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_insert_epi16 (__m128i const __A, int const __D, int const __N)
{
  return (__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)__A, __D, __N);
}
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_epi8 (__m128i __A)
{
  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shufflehi_epi16 (__m128i __A, const int __mask)
{
  return (__m128i)__builtin_ia32_pshufhw ((__v8hi)__A, __mask);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shufflelo_epi16 (__m128i __A, const int __mask)
{
  return (__m128i)__builtin_ia32_pshuflw ((__v8hi)__A, __mask);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_shuffle_epi32 (__m128i __A, const int __mask)
{
  return (__m128i)__builtin_ia32_pshufd ((__v4si)__A, __mask);
}
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
{
  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si32 (int *__A, int __B)
{
  __builtin_ia32_movnti (__A, __B);
}
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si128 (__m128i *__A, __m128i __B)
{
  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pd (double *__A, __m128d __B)
{
  __builtin_ia32_movntpd (__A, (__v2df)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clflush (void const *__A)
{
  __builtin_ia32_clflush (__A);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_lfence (void)
{
  __builtin_ia32_lfence ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mfence (void)
{
  __builtin_ia32_mfence ();
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si128 (int __A)
{
  return _mm_set_epi32 (0, 0, 0, __A);
}
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_ps(__m128d __A)
{
  return (__m128) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_si128(__m128d __A)
{
  return (__m128i) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_pd(__m128 __A)
{
  return (__m128d) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_si128(__m128 __A)
{
  return (__m128i) __A;
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_ps(__m128i __A)
{
  return (__m128) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_pd(__m128i __A)
{
  return (__m128d) __A;
}



#pragma GCC pop_options
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_pause (void)
{
  __builtin_ia32_pause ();
}





extern float (*pfSqrt)(float x);
extern float (*pfRSqrt)(float x);
extern float (*pfRSqrtFast)(float x);
extern void (*pfFastSinCos)(float x, float *s, float *c);
extern float (*pfFastCos)(float x);





class Vector2D
{
public:

 vec_t x, y;


 Vector2D(void);
 Vector2D(vec_t X, vec_t Y);
 Vector2D(const float *pFloat);


 void Init(vec_t ix=0.0f, vec_t iy=0.0f);


 bool IsValid() const;


 vec_t operator[](int i) const;
 vec_t& operator[](int i);


 vec_t* Base();
 vec_t const* Base() const;


 void Random( float minVal, float maxVal );


 bool operator==(const Vector2D& v) const;
 bool operator!=(const Vector2D& v) const;


 Vector2D& operator+=(const Vector2D &v);
 Vector2D& operator-=(const Vector2D &v);
 Vector2D& operator*=(const Vector2D &v);
 Vector2D& operator*=(float s);
 Vector2D& operator/=(const Vector2D &v);
 Vector2D& operator/=(float s);


 void Negate();


 vec_t Length() const;


 vec_t LengthSqr(void) const;


 bool IsZero( float tolerance = 0.01f ) const
 {
  return (x > -tolerance && x < tolerance &&
    y > -tolerance && y < tolerance);
 }


 vec_t NormalizeInPlace();


 bool IsLengthGreaterThan( float val ) const;
 bool IsLengthLessThan( float val ) const;


 vec_t DistTo(const Vector2D &vOther) const;


 vec_t DistToSqr(const Vector2D &vOther) const;


 void CopyToArray(float* rgfl) const;




 void MulAdd(const Vector2D& a, const Vector2D& b, float scalar);


 vec_t Dot(const Vector2D& vOther) const;


 Vector2D& operator=(const Vector2D &vOther);



 Vector2D(const Vector2D &vOther);


 Vector2D operator-(void) const;

 Vector2D operator+(const Vector2D& v) const;
 Vector2D operator-(const Vector2D& v) const;
 Vector2D operator*(const Vector2D& v) const;
 Vector2D operator/(const Vector2D& v) const;
 Vector2D operator*(float fl) const;
 Vector2D operator/(float fl) const;


 Vector2D Cross(const Vector2D &vOther) const;


 Vector2D Min(const Vector2D &vOther) const;
 Vector2D Max(const Vector2D &vOther) const;







};



const Vector2D vec2_origin(0,0);
const Vector2D vec2_invalid( 3.40282346638528859812e+38F, 3.40282346638528859812e+38F );






void Vector2DClear( Vector2D& a );


void Vector2DCopy( const Vector2D& src, Vector2D& dst );


void Vector2DAdd( const Vector2D& a, const Vector2D& b, Vector2D& result );
void Vector2DSubtract( const Vector2D& a, const Vector2D& b, Vector2D& result );
void Vector2DMultiply( const Vector2D& a, vec_t b, Vector2D& result );
void Vector2DMultiply( const Vector2D& a, const Vector2D& b, Vector2D& result );
void Vector2DDivide( const Vector2D& a, vec_t b, Vector2D& result );
void Vector2DDivide( const Vector2D& a, const Vector2D& b, Vector2D& result );
void Vector2DMA( const Vector2D& start, float s, const Vector2D& dir, Vector2D& result );


void Vector2DMin( const Vector2D &a, const Vector2D &b, Vector2D &result );
void Vector2DMax( const Vector2D &a, const Vector2D &b, Vector2D &result );




vec_t Vector2DNormalize( Vector2D& v );


vec_t Vector2DLength( const Vector2D& v );


vec_t DotProduct2D(const Vector2D& a, const Vector2D& b);


void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, vec_t t, Vector2D& dest );
inline Vector2D::Vector2D(void)
{




}

inline Vector2D::Vector2D(vec_t X, vec_t Y)
{
 x = X; y = Y;
 ((void)0);
}

inline Vector2D::Vector2D(const float *pFloat)
{
 ((void)0);
 x = pFloat[0]; y = pFloat[1];
 ((void)0);
}






inline Vector2D::Vector2D(const Vector2D &vOther)
{
 ((void)0);
 x = vOther.x; y = vOther.y;
}





inline void Vector2D::Init( vec_t ix, vec_t iy )
{
 x = ix; y = iy;
 ((void)0);
}

inline void Vector2D::Random( float minVal, float maxVal )
{
 x = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 y = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
}

inline void Vector2DClear( Vector2D& a )
{
 a.x = a.y = 0.0f;
}





inline Vector2D& Vector2D::operator=(const Vector2D &vOther)
{
 ((void)0);
 x=vOther.x; y=vOther.y;
 return *this;
}





inline vec_t& Vector2D::operator[](int i)
{
 ((void)0);
 return ((vec_t*)this)[i];
}

inline vec_t Vector2D::operator[](int i) const
{
 ((void)0);
 return ((vec_t*)this)[i];
}





inline vec_t* Vector2D::Base()
{
 return (vec_t*)this;
}

inline vec_t const* Vector2D::Base() const
{
 return (vec_t const*)this;
}





inline bool Vector2D::IsValid() const
{
 return IsFinite(x) && IsFinite(y);
}





inline bool Vector2D::operator==( const Vector2D& src ) const
{
 ((void)0);
 return (src.x == x) && (src.y == y);
}

inline bool Vector2D::operator!=( const Vector2D& src ) const
{
 ((void)0);
 return (src.x != x) || (src.y != y);
}






inline void Vector2DCopy( const Vector2D& src, Vector2D& dst )
{
 ((void)0);
 dst.x = src.x;
 dst.y = src.y;
}

inline void Vector2D::CopyToArray(float* rgfl) const
{
 ((void)0);
 ((void)0);
 rgfl[0] = x; rgfl[1] = y;
}





inline void Vector2D::Negate()
{
 ((void)0);
 x = -x; y = -y;
}

inline Vector2D& Vector2D::operator+=(const Vector2D& v)
{
 ((void)0);
 x+=v.x; y+=v.y;
 return *this;
}

inline Vector2D& Vector2D::operator-=(const Vector2D& v)
{
 ((void)0);
 x-=v.x; y-=v.y;
 return *this;
}

inline Vector2D& Vector2D::operator*=(float fl)
{
 x *= fl;
 y *= fl;
 ((void)0);
 return *this;
}

inline Vector2D& Vector2D::operator*=(const Vector2D& v)
{
 x *= v.x;
 y *= v.y;
 ((void)0);
 return *this;
}

inline Vector2D& Vector2D::operator/=(float fl)
{
 ((void)0);
 float oofl = 1.0f / fl;
 x *= oofl;
 y *= oofl;
 ((void)0);
 return *this;
}

inline Vector2D& Vector2D::operator/=(const Vector2D& v)
{
 ((void)0);
 x /= v.x;
 y /= v.y;
 ((void)0);
 return *this;
}

inline void Vector2DAdd( const Vector2D& a, const Vector2D& b, Vector2D& c )
{
 ((void)0);
 c.x = a.x + b.x;
 c.y = a.y + b.y;
}

inline void Vector2DSubtract( const Vector2D& a, const Vector2D& b, Vector2D& c )
{
 ((void)0);
 c.x = a.x - b.x;
 c.y = a.y - b.y;
}

inline void Vector2DMultiply( const Vector2D& a, vec_t b, Vector2D& c )
{
 ((void)0);
 c.x = a.x * b;
 c.y = a.y * b;
}

inline void Vector2DMultiply( const Vector2D& a, const Vector2D& b, Vector2D& c )
{
 ((void)0);
 c.x = a.x * b.x;
 c.y = a.y * b.y;
}


inline void Vector2DDivide( const Vector2D& a, vec_t b, Vector2D& c )
{
 ((void)0);
 ((void)0);
 vec_t oob = 1.0f / b;
 c.x = a.x * oob;
 c.y = a.y * oob;
}

inline void Vector2DDivide( const Vector2D& a, const Vector2D& b, Vector2D& c )
{
 ((void)0);
 ((void)0);
 c.x = a.x / b.x;
 c.y = a.y / b.y;
}

inline void Vector2DMA( const Vector2D& start, float s, const Vector2D& dir, Vector2D& result )
{
 ((void)0);
 result.x = start.x + s*dir.x;
 result.y = start.y + s*dir.y;
}



inline void Vector2D::MulAdd(const Vector2D& a, const Vector2D& b, float scalar)
{
 x = a.x + b.x * scalar;
 y = a.y + b.y * scalar;
}

inline void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, vec_t t, Vector2D& dest )
{
 dest[0] = src1[0] + (src2[0] - src1[0]) * t;
 dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}




inline vec_t DotProduct2D(const Vector2D& a, const Vector2D& b)
{
 ((void)0);
 return( a.x*b.x + a.y*b.y );
}


inline vec_t Vector2D::Dot( const Vector2D& vOther ) const
{
 return DotProduct2D( *this, vOther );
}





inline vec_t Vector2DLength( const Vector2D& v )
{
 ((void)0);
 return (vec_t)(*pfSqrt)(v.x*v.x + v.y*v.y);
}

inline vec_t Vector2D::LengthSqr(void) const
{
 ((void)0);
 return (x*x + y*y);
}

inline vec_t Vector2D::NormalizeInPlace()
{
 return Vector2DNormalize( *this );
}

inline bool Vector2D::IsLengthGreaterThan( float val ) const
{
 return LengthSqr() > val*val;
}

inline bool Vector2D::IsLengthLessThan( float val ) const
{
 return LengthSqr() < val*val;
}

inline vec_t Vector2D::Length(void) const
{
 return Vector2DLength( *this );
}


inline void Vector2DMin( const Vector2D &a, const Vector2D &b, Vector2D &result )
{
 result.x = (a.x < b.x) ? a.x : b.x;
 result.y = (a.y < b.y) ? a.y : b.y;
}


inline void Vector2DMax( const Vector2D &a, const Vector2D &b, Vector2D &result )
{
 result.x = (a.x > b.x) ? a.x : b.x;
 result.y = (a.y > b.y) ? a.y : b.y;
}





inline vec_t Vector2DNormalize( Vector2D& v )
{
 ((void)0);
 vec_t l = v.Length();
 if (l != 0.0f)
 {
  v /= l;
 }
 else
 {
  v.x = v.y = 0.0f;
 }
 return l;
}





inline vec_t Vector2D::DistTo(const Vector2D &vOther) const
{
 Vector2D delta;
 Vector2DSubtract( *this, vOther, delta );
 return delta.Length();
}

inline vec_t Vector2D::DistToSqr(const Vector2D &vOther) const
{
 Vector2D delta;
 Vector2DSubtract( *this, vOther, delta );
 return delta.LengthSqr();
}





inline void ComputeClosestPoint2D( const Vector2D& vecStart, float flMaxDist, const Vector2D& vecTarget, Vector2D *pResult )
{
 Vector2D vecDelta;
 Vector2DSubtract( vecTarget, vecStart, vecDelta );
 float flDistSqr = vecDelta.LengthSqr();
 if ( flDistSqr <= flMaxDist * flMaxDist )
 {
  *pResult = vecTarget;
 }
 else
 {
  vecDelta /= (*pfSqrt)(flDistSqr);
  Vector2DMA( vecStart, flMaxDist, vecDelta, *pResult );
 }
}
inline Vector2D Vector2D::Min(const Vector2D &vOther) const
{
 return Vector2D(x < vOther.x ? x : vOther.x,
  y < vOther.y ? y : vOther.y);
}

inline Vector2D Vector2D::Max(const Vector2D &vOther) const
{
 return Vector2D(x > vOther.x ? x : vOther.x,
  y > vOther.y ? y : vOther.y);
}






inline Vector2D Vector2D::operator-(void) const
{
 return Vector2D(-x,-y);
}

inline Vector2D Vector2D::operator+(const Vector2D& v) const
{
 Vector2D res;
 Vector2DAdd( *this, v, res );
 return res;
}

inline Vector2D Vector2D::operator-(const Vector2D& v) const
{
 Vector2D res;
 Vector2DSubtract( *this, v, res );
 return res;
}

inline Vector2D Vector2D::operator*(float fl) const
{
 Vector2D res;
 Vector2DMultiply( *this, fl, res );
 return res;
}

inline Vector2D Vector2D::operator*(const Vector2D& v) const
{
 Vector2D res;
 Vector2DMultiply( *this, v, res );
 return res;
}

inline Vector2D Vector2D::operator/(float fl) const
{
 Vector2D res;
 Vector2DDivide( *this, fl, res );
 return res;
}

inline Vector2D Vector2D::operator/(const Vector2D& v) const
{
 Vector2D res;
 Vector2DDivide( *this, v, res );
 return res;
}

inline Vector2D operator*(float fl, const Vector2D& v)
{
 return v * fl;
}
class VectorByValue;




class Vector
{
public:

 vec_t x, y, z;


 Vector(void);
 Vector(vec_t X, vec_t Y, vec_t Z);
 Vector(vec_t XYZ);


 void Init(vec_t ix=0.0f, vec_t iy=0.0f, vec_t iz=0.0f);



 bool IsValid() const;
 void Invalidate();


 vec_t operator[](int i) const;
 vec_t& operator[](int i);


 vec_t* Base();
 vec_t const* Base() const;


 Vector2D& AsVector2D();
 const Vector2D& AsVector2D() const;


 void Random( vec_t minVal, vec_t maxVal );
 inline void Zero();


 bool operator==(const Vector& v) const;
 bool operator!=(const Vector& v) const;


 inline Vector& operator+=(const Vector &v);
 inline Vector& operator-=(const Vector &v);
 inline Vector& operator*=(const Vector &v);
 inline Vector& operator*=(float s);
 inline Vector& operator/=(const Vector &v);
 inline Vector& operator/=(float s);
 inline Vector& operator+=(float fl) ;
 inline Vector& operator-=(float fl) ;


 void Negate();


 inline vec_t Length() const;


 inline vec_t LengthSqr(void) const
 {
  ;
  return (x*x + y*y + z*z);
 }


 bool IsZero( float tolerance = 0.01f ) const
 {
  return (x > -tolerance && x < tolerance &&
    y > -tolerance && y < tolerance &&
    z > -tolerance && z < tolerance);
 }

 vec_t NormalizeInPlace();
 bool IsLengthGreaterThan( float val ) const;
 bool IsLengthLessThan( float val ) const;


 inline bool WithinAABox( Vector const &boxmin, Vector const &boxmax);


 vec_t DistTo(const Vector &vOther) const;




 inline vec_t DistToSqr(const Vector &vOther) const
 {
  Vector delta;

  delta.x = x - vOther.x;
  delta.y = y - vOther.y;
  delta.z = z - vOther.z;

  return delta.LengthSqr();
 }


 void CopyToArray(float* rgfl) const;




 void MulAdd(const Vector& a, const Vector& b, float scalar);


 vec_t Dot(const Vector& vOther) const;


 Vector& operator=(const Vector &vOther);


 vec_t Length2D(void) const;
 vec_t Length2DSqr(void) const;

 operator VectorByValue &() { return *((VectorByValue *)(this)); }
 operator const VectorByValue &() const { return *((const VectorByValue *)(this)); }






 Vector operator-(void) const;

 Vector operator+(const Vector& v) const;
 Vector operator-(const Vector& v) const;
 Vector operator*(const Vector& v) const;
 Vector operator/(const Vector& v) const;
 Vector operator*(float fl) const;
 Vector operator/(float fl) const;


 Vector Cross(const Vector &vOther) const;


 Vector Min(const Vector &vOther) const;
 Vector Max(const Vector &vOther) const;







};
class __attribute__((aligned(8))) ShortVector
{
public:

 short x, y, z, w;


 void Init(short ix = 0, short iy = 0, short iz = 0, short iw = 0 );
 void Set( const ShortVector& vOther );
 void Set( const short ix, const short iy, const short iz, const short iw );


 short operator[](int i) const;
 short& operator[](int i);


 short* Base();
 short const* Base() const;


 bool operator==(const ShortVector& v) const;
 bool operator!=(const ShortVector& v) const;


 inline ShortVector& operator+=(const ShortVector &v);
 inline ShortVector& operator-=(const ShortVector &v);
 inline ShortVector& operator*=(const ShortVector &v);
 inline ShortVector& operator*=(float s);
 inline ShortVector& operator/=(const ShortVector &v);
 inline ShortVector& operator/=(float s);
 inline ShortVector operator*(float fl) const;

private:







};
class IntVector4D
{
public:

 int x, y, z, w;


 void Init(int ix = 0, int iy = 0, int iz = 0, int iw = 0 );







 void Set( const IntVector4D& vOther );
 void Set( const int ix, const int iy, const int iz, const int iw );


 int operator[](int i) const;
 int& operator[](int i);


 int* Base();
 int const* Base() const;


 bool operator==(const IntVector4D& v) const;
 bool operator!=(const IntVector4D& v) const;


 inline IntVector4D& operator+=(const IntVector4D &v);
 inline IntVector4D& operator-=(const IntVector4D &v);
 inline IntVector4D& operator*=(const IntVector4D &v);
 inline IntVector4D& operator*=(float s);
 inline IntVector4D& operator/=(const IntVector4D &v);
 inline IntVector4D& operator/=(float s);
 inline IntVector4D operator*(float fl) const;

private:







};






class VectorByValue : public Vector
{
public:

 VectorByValue(void) : Vector() {}
 VectorByValue(vec_t X, vec_t Y, vec_t Z) : Vector( X, Y, Z ) {}
 VectorByValue(const VectorByValue& vOther) { *this = vOther; }
};






class TableVector
{
public:
 vec_t x, y, z;

 operator Vector &() { return *((Vector *)(this)); }
 operator const Vector &() const { return *((const Vector *)(this)); }


 inline vec_t& operator[](int i)
 {
  ((void)0);
  return ((vec_t*)this)[i];
 }

 inline vec_t operator[](int i) const
 {
  ((void)0);
  return ((vec_t*)this)[i];
 }
};






class __attribute__((aligned(16))) VectorAligned : public Vector
{
public:
 inline VectorAligned(void) {};
 inline VectorAligned(vec_t X, vec_t Y, vec_t Z)
 {
  Init(X,Y,Z);
 }
public:
 explicit VectorAligned(const Vector &vOther)
 {
  Init(vOther.x, vOther.y, vOther.z);
 }

 VectorAligned& operator=(const Vector &vOther)
 {
  Init(vOther.x, vOther.y, vOther.z);
  return *this;
 }


 float w;
};






inline void VectorClear( Vector& a );


inline void VectorCopy( const Vector& src, Vector& dst );


inline void VectorAdd( const Vector& a, const Vector& b, Vector& result );
inline void VectorSubtract( const Vector& a, const Vector& b, Vector& result );
inline void VectorMultiply( const Vector& a, vec_t b, Vector& result );
inline void VectorMultiply( const Vector& a, const Vector& b, Vector& result );
inline void VectorDivide( const Vector& a, vec_t b, Vector& result );
inline void VectorDivide( const Vector& a, const Vector& b, Vector& result );
inline void VectorScale ( const Vector& in, vec_t scale, Vector& result );
inline void VectorMA( const Vector& start, float scale, const Vector& direction, Vector& dest );


bool VectorsAreEqual( const Vector& src1, const Vector& src2, float tolerance = 0.0f );
inline vec_t VectorLength( const Vector& v );


inline vec_t DotProduct(const Vector& a, const Vector& b);


void CrossProduct(const Vector& a, const Vector& b, Vector& result );


void VectorMin( const Vector &a, const Vector &b, Vector &result );
void VectorMax( const Vector &a, const Vector &b, Vector &result );


void VectorLerp(const Vector& src1, const Vector& src2, vec_t t, Vector& dest );




Vector CrossProduct( const Vector& a, const Vector& b );


Vector RandomVector( vec_t minVal, vec_t maxVal );
inline Vector::Vector(void)
{






}

inline Vector::Vector(vec_t X, vec_t Y, vec_t Z)
{
 x = X; y = Y; z = Z;
 ;
}

inline Vector::Vector(vec_t XYZ)
{
 x = y = z = XYZ;
 ;
}
inline void Vector::Init( vec_t ix, vec_t iy, vec_t iz )
{
 x = ix; y = iy; z = iz;
 ;
}

inline void Vector::Random( vec_t minVal, vec_t maxVal )
{
 x = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 y = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 z = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 ;
}


inline void Vector::Zero()
{
 x = y = z = 0.0f;
}

inline void VectorClear( Vector& a )
{
 a.x = a.y = a.z = 0.0f;
}





inline Vector& Vector::operator=(const Vector &vOther)
{
 ;
 x=vOther.x; y=vOther.y; z=vOther.z;
 return *this;
}





inline vec_t& Vector::operator[](int i)
{
 ((void)0);
 return ((vec_t*)this)[i];
}

inline vec_t Vector::operator[](int i) const
{
 ((void)0);
 return ((vec_t*)this)[i];
}





inline vec_t* Vector::Base()
{
 return (vec_t*)this;
}

inline vec_t const* Vector::Base() const
{
 return (vec_t const*)this;
}





inline Vector2D& Vector::AsVector2D()
{
 return *(Vector2D*)this;
}

inline const Vector2D& Vector::AsVector2D() const
{
 return *(const Vector2D*)this;
}





inline bool Vector::IsValid() const
{
 return IsFinite(x) && IsFinite(y) && IsFinite(z);
}





inline void Vector::Invalidate()
{


 x = y = z = BitsToFloat( (unsigned long)0x7FC00000 );


}





inline bool Vector::operator==( const Vector& src ) const
{
 ;
 ;
 return (src.x == x) && (src.y == y) && (src.z == z);
}

inline bool Vector::operator!=( const Vector& src ) const
{
 ;
 ;
 return (src.x != x) || (src.y != y) || (src.z != z);
}






inline void VectorCopy( const Vector& src, Vector& dst )
{
 ;
 dst.x = src.x;
 dst.y = src.y;
 dst.z = src.z;
}

inline void Vector::CopyToArray(float* rgfl) const
{
 ((void)0);
 ;
 rgfl[0] = x, rgfl[1] = y, rgfl[2] = z;
}






inline void Vector::Negate()
{
 ;
 x = -x; y = -y; z = -z;
}

inline Vector& Vector::operator+=(const Vector& v)
{
 ;
 ;
 x+=v.x; y+=v.y; z += v.z;
 return *this;
}

inline Vector& Vector::operator-=(const Vector& v)
{
 ;
 ;
 x-=v.x; y-=v.y; z -= v.z;
 return *this;
}

inline Vector& Vector::operator*=(float fl)
{
 x *= fl;
 y *= fl;
 z *= fl;
 ;
 return *this;
}

inline Vector& Vector::operator*=(const Vector& v)
{
 ;
 x *= v.x;
 y *= v.y;
 z *= v.z;
 ;
 return *this;
}


inline Vector& Vector::operator+=(float fl)
{
 x += fl;
 y += fl;
 z += fl;
 ;
 return *this;
}

inline Vector& Vector::operator-=(float fl)
{
 x -= fl;
 y -= fl;
 z -= fl;
 ;
 return *this;
}



inline Vector& Vector::operator/=(float fl)
{
 ((void)0);
 float oofl = 1.0f / fl;
 x *= oofl;
 y *= oofl;
 z *= oofl;
 ;
 return *this;
}

inline Vector& Vector::operator/=(const Vector& v)
{
 ;
 ((void)0);
 x /= v.x;
 y /= v.y;
 z /= v.z;
 ;
 return *this;
}
inline void ShortVector::Init( short ix, short iy, short iz, short iw )
{
 x = ix; y = iy; z = iz; w = iw;
}

inline void ShortVector::Set( const ShortVector& vOther )
{
   x = vOther.x;
   y = vOther.y;
   z = vOther.z;
   w = vOther.w;
}

inline void ShortVector::Set( const short ix, const short iy, const short iz, const short iw )
{
   x = ix;
   y = iy;
   z = iz;
   w = iw;
}





inline short ShortVector::operator[](int i) const
{
 ((void)0);
 return ((short*)this)[i];
}

inline short& ShortVector::operator[](int i)
{
 ((void)0);
 return ((short*)this)[i];
}




inline short* ShortVector::Base()
{
 return (short*)this;
}

inline short const* ShortVector::Base() const
{
 return (short const*)this;
}






inline bool ShortVector::operator==( const ShortVector& src ) const
{
 return (src.x == x) && (src.y == y) && (src.z == z) && (src.w == w);
}

inline bool ShortVector::operator!=( const ShortVector& src ) const
{
 return (src.x != x) || (src.y != y) || (src.z != z) || (src.w != w);
}







inline ShortVector& ShortVector::operator+=(const ShortVector& v)
{
 x+=v.x; y+=v.y; z += v.z; w += v.w;
 return *this;
}

inline ShortVector& ShortVector::operator-=(const ShortVector& v)
{
 x-=v.x; y-=v.y; z -= v.z; w -= v.w;
 return *this;
}

inline ShortVector& ShortVector::operator*=(float fl)
{
 x = static_cast<short>(x* fl);
 y = static_cast<short>(y * fl);
 z = static_cast<short>(z * fl);
 w = static_cast<short>(w * fl);
 return *this;
}

inline ShortVector& ShortVector::operator*=(const ShortVector& v)
{
 x *= v.x;
 y *= v.y;
 z *= v.z;
 w *= v.w;
 return *this;
}

inline ShortVector& ShortVector::operator/=(float fl)
{
 ((void)0);
 float oofl = 1.0f / fl;
 x = static_cast<short>(x * oofl);
 y = static_cast<short>(y * oofl);
 z = static_cast<short>(z * oofl);
 w = static_cast<short>(w * oofl);
 return *this;
}

inline ShortVector& ShortVector::operator/=(const ShortVector& v)
{
 ((void)0);
 x /= v.x;
 y /= v.y;
 z /= v.z;
 w /= v.w;
 return *this;
}

inline void ShortVectorMultiply( const ShortVector& src, float fl, ShortVector& res )
{
 ((void)0);
 res.x = static_cast<short>(src.x * fl);
 res.y = static_cast<short>(src.y * fl);
 res.z = static_cast<short>(src.z * fl);
 res.w = static_cast<short>(src.w * fl);
}

inline ShortVector ShortVector::operator*(float fl) const
{
 ShortVector res;
 ShortVectorMultiply( *this, fl, res );
 return res;
}
inline void IntVector4D::Init( int ix, int iy, int iz, int iw )
{
 x = ix; y = iy; z = iz; w = iw;
}

inline void IntVector4D::Set( const IntVector4D& vOther )
{
 x = vOther.x;
 y = vOther.y;
 z = vOther.z;
 w = vOther.w;
}

inline void IntVector4D::Set( const int ix, const int iy, const int iz, const int iw )
{
 x = ix;
 y = iy;
 z = iz;
 w = iw;
}





inline int IntVector4D::operator[](int i) const
{
 ((void)0);
 return ((int*)this)[i];
}

inline int& IntVector4D::operator[](int i)
{
 ((void)0);
 return ((int*)this)[i];
}




inline int* IntVector4D::Base()
{
 return (int*)this;
}

inline int const* IntVector4D::Base() const
{
 return (int const*)this;
}






inline bool IntVector4D::operator==( const IntVector4D& src ) const
{
 return (src.x == x) && (src.y == y) && (src.z == z) && (src.w == w);
}

inline bool IntVector4D::operator!=( const IntVector4D& src ) const
{
 return (src.x != x) || (src.y != y) || (src.z != z) || (src.w != w);
}







inline IntVector4D& IntVector4D::operator+=(const IntVector4D& v)
{
 x+=v.x; y+=v.y; z += v.z; w += v.w;
 return *this;
}

inline IntVector4D& IntVector4D::operator-=(const IntVector4D& v)
{
 x-=v.x; y-=v.y; z -= v.z; w -= v.w;
 return *this;
}

inline IntVector4D& IntVector4D::operator*=(float fl)
{
 x = static_cast<int>(x * fl);
 y = static_cast<int>(y * fl);
 z = static_cast<int>(z * fl);
 w = static_cast<int>(w * fl);
 return *this;
}

inline IntVector4D& IntVector4D::operator*=(const IntVector4D& v)
{
 x *= v.x;
 y *= v.y;
 z *= v.z;
 w *= v.w;
 return *this;
}

inline IntVector4D& IntVector4D::operator/=(float fl)
{
 ((void)0);
 float oofl = 1.0f / fl;
 x = static_cast<int>(x * oofl);
 y = static_cast<int>(y * oofl);
 z = static_cast<int>(z * oofl);
 w = static_cast<int>(w * oofl);
 return *this;
}

inline IntVector4D& IntVector4D::operator/=(const IntVector4D& v)
{
 ((void)0);
 x /= v.x;
 y /= v.y;
 z /= v.z;
 w /= v.w;
 return *this;
}

inline void IntVector4DMultiply( const IntVector4D& src, float fl, IntVector4D& res )
{
 ((void)0);
 res.x = static_cast<int>(src.x * fl);
 res.y = static_cast<int>(src.y * fl);
 res.z = static_cast<int>(src.z * fl);
 res.w = static_cast<int>(src.w * fl);
}

inline IntVector4D IntVector4D::operator*(float fl) const
{
 IntVector4D res;
 IntVector4DMultiply( *this, fl, res );
 return res;
}






inline void VectorAdd( const Vector& a, const Vector& b, Vector& c )
{
 ;
 ;
 c.x = a.x + b.x;
 c.y = a.y + b.y;
 c.z = a.z + b.z;
}

inline void VectorSubtract( const Vector& a, const Vector& b, Vector& c )
{
 ;
 ;
 c.x = a.x - b.x;
 c.y = a.y - b.y;
 c.z = a.z - b.z;
}

inline void VectorMultiply( const Vector& a, vec_t b, Vector& c )
{
 ;
 ((void)0);
 c.x = a.x * b;
 c.y = a.y * b;
 c.z = a.z * b;
}

inline void VectorMultiply( const Vector& a, const Vector& b, Vector& c )
{
 ;
 ;
 c.x = a.x * b.x;
 c.y = a.y * b.y;
 c.z = a.z * b.z;
}


inline void VectorScale ( const Vector& in, vec_t scale, Vector& result )
{
 VectorMultiply( in, scale, result );
}

inline void VectorMA( const Vector& start, float scale, const Vector& direction, Vector& dest )
{
 ;
 ;
 dest.x = start.x + scale * direction.x;
 dest.y = start.y + scale * direction.y;
 dest.z = start.z + scale * direction.z;
}

inline void VectorDivide( const Vector& a, vec_t b, Vector& c )
{
 ;
 ((void)0);
 vec_t oob = 1.0f / b;
 c.x = a.x * oob;
 c.y = a.y * oob;
 c.z = a.z * oob;
}

inline void VectorDivide( const Vector& a, const Vector& b, Vector& c )
{
 ;
 ;
 ((void)0);
 c.x = a.x / b.x;
 c.y = a.y / b.y;
 c.z = a.z / b.z;
}



inline void Vector::MulAdd(const Vector& a, const Vector& b, float scalar)
{
 ;
 ;
 x = a.x + b.x * scalar;
 y = a.y + b.y * scalar;
 z = a.z + b.z * scalar;
}

inline void VectorLerp(const Vector& src1, const Vector& src2, vec_t t, Vector& dest )
{
 ;
 ;
 dest.x = src1.x + (src2.x - src1.x) * t;
 dest.y = src1.y + (src2.y - src1.y) * t;
 dest.z = src1.z + (src2.z - src1.z) * t;
}





inline Vector &AllocTempVector()
{
 static Vector s_vecTemp[128];
 static CInterlockedInt s_nIndex;

 int nIndex;
 for (;;)
 {
  int nOldIndex = s_nIndex;
  nIndex = ( (nOldIndex + 0x10001) & 0x7F );

  if ( s_nIndex.AssignIf( nOldIndex, nIndex ) )
  {
   break;
  }
  ThreadPause();
 }
 return s_vecTemp[nIndex & 0xffff];
}






inline vec_t DotProduct(const Vector& a, const Vector& b)
{
 ;
 ;
 return( a.x*b.x + a.y*b.y + a.z*b.z );
}


inline vec_t Vector::Dot( const Vector& vOther ) const
{
 ;
 return DotProduct( *this, vOther );
}

inline void CrossProduct(const Vector& a, const Vector& b, Vector& result )
{
 ;
 ;
 ((void)0);
 ((void)0);
 result.x = a.y*b.z - a.z*b.y;
 result.y = a.z*b.x - a.x*b.z;
 result.z = a.x*b.y - a.y*b.x;
}

inline vec_t DotProductAbs( const Vector &v0, const Vector &v1 )
{
 ;
 ;
 return FloatMakePositive(v0.x*v1.x) + FloatMakePositive(v0.y*v1.y) + FloatMakePositive(v0.z*v1.z);
}

inline vec_t DotProductAbs( const Vector &v0, const float *v1 )
{
 return FloatMakePositive(v0.x * v1[0]) + FloatMakePositive(v0.y * v1[1]) + FloatMakePositive(v0.z * v1[2]);
}





inline vec_t VectorLength( const Vector& v )
{
 ;
 return (vec_t)(*pfSqrt)(v.x*v.x + v.y*v.y + v.z*v.z);
}


inline vec_t Vector::Length(void) const
{
 ;
 return VectorLength( *this );
}
bool Vector::WithinAABox( Vector const &boxmin, Vector const &boxmax)
{
 return (
  ( x >= boxmin.x ) && ( x <= boxmax.x) &&
  ( y >= boxmin.y ) && ( y <= boxmax.y) &&
  ( z >= boxmin.z ) && ( z <= boxmax.z)
  );
}




inline vec_t Vector::DistTo(const Vector &vOther) const
{
 Vector delta;
 VectorSubtract( *this, vOther, delta );
 return delta.Length();
}





inline bool VectorsAreEqual( const Vector& src1, const Vector& src2, float tolerance )
{
 if (FloatMakePositive(src1.x - src2.x) > tolerance)
  return false;
 if (FloatMakePositive(src1.y - src2.y) > tolerance)
  return false;
 return (FloatMakePositive(src1.z - src2.z) <= tolerance);
}





inline void ComputeClosestPoint( const Vector& vecStart, float flMaxDist, const Vector& vecTarget, Vector *pResult )
{
 Vector vecDelta;
 VectorSubtract( vecTarget, vecStart, vecDelta );
 float flDistSqr = vecDelta.LengthSqr();
 if ( flDistSqr <= flMaxDist * flMaxDist )
 {
  *pResult = vecTarget;
 }
 else
 {
  vecDelta /= (*pfSqrt)(flDistSqr);
  VectorMA( vecStart, flMaxDist, vecDelta, *pResult );
 }
}





inline void VectorAbs( const Vector& src, Vector& dst )
{
 dst.x = FloatMakePositive(src.x);
 dst.y = FloatMakePositive(src.y);
 dst.z = FloatMakePositive(src.z);
}
inline Vector Vector::Min(const Vector &vOther) const
{
 return Vector(x < vOther.x ? x : vOther.x,
  y < vOther.y ? y : vOther.y,
  z < vOther.z ? z : vOther.z);
}

inline Vector Vector::Max(const Vector &vOther) const
{
 return Vector(x > vOther.x ? x : vOther.x,
  y > vOther.y ? y : vOther.y,
  z > vOther.z ? z : vOther.z);
}






inline Vector Vector::operator-(void) const
{
 return Vector(-x,-y,-z);
}

inline Vector Vector::operator+(const Vector& v) const
{
 Vector res;
 VectorAdd( *this, v, res );
 return res;
}

inline Vector Vector::operator-(const Vector& v) const
{
 Vector res;
 VectorSubtract( *this, v, res );
 return res;
}

inline Vector Vector::operator*(float fl) const
{
 Vector res;
 VectorMultiply( *this, fl, res );
 return res;
}

inline Vector Vector::operator*(const Vector& v) const
{
 Vector res;
 VectorMultiply( *this, v, res );
 return res;
}

inline Vector Vector::operator/(float fl) const
{
 Vector res;
 VectorDivide( *this, fl, res );
 return res;
}

inline Vector Vector::operator/(const Vector& v) const
{
 Vector res;
 VectorDivide( *this, v, res );
 return res;
}

inline Vector operator*(float fl, const Vector& v)
{
 return v * fl;
}





inline Vector Vector::Cross(const Vector& vOther) const
{
 Vector res;
 CrossProduct( *this, vOther, res );
 return res;
}





inline vec_t Vector::Length2D(void) const
{
 return (vec_t)(*pfSqrt)(x*x + y*y);
}

inline vec_t Vector::Length2DSqr(void) const
{
 return (x*x + y*y);
}

inline Vector CrossProduct(const Vector& a, const Vector& b)
{
 return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x );
}

inline void VectorMin( const Vector &a, const Vector &b, Vector &result )
{
 result.x = fpmin(a.x, b.x);
 result.y = fpmin(a.y, b.y);
 result.z = fpmin(a.z, b.z);
}

inline void VectorMax( const Vector &a, const Vector &b, Vector &result )
{
 result.x = fpmax(a.x, b.x);
 result.y = fpmax(a.y, b.y);
 result.z = fpmax(a.z, b.z);
}


inline Vector RandomVector( float minVal, float maxVal )
{
 Vector random;
 random.Random( minVal, maxVal );
 return random;
}







inline bool operator==( float const* f, const Vector& v )
{

 ((void)0);
 return false;
}

inline bool operator==( const Vector& v, float const* f )
{

 ((void)0);
 return false;
}

inline bool operator!=( float const* f, const Vector& v )
{

 ((void)0);
 return false;
}

inline bool operator!=( const Vector& v, float const* f )
{

 ((void)0);
 return false;
}






typedef Vector AngularImpulse;



inline AngularImpulse RandomAngularImpulse( float minVal, float maxVal )
{
 AngularImpulse angImp;
 angImp.Random( minVal, maxVal );
 return angImp;
}
class RadianEuler;

class Quaternion
{
public:
 inline Quaternion(void) {







 }
 inline Quaternion(vec_t ix, vec_t iy, vec_t iz, vec_t iw) : x(ix), y(iy), z(iz), w(iw) { }
 inline Quaternion(RadianEuler const &angle);

 inline void Init(vec_t ix=0.0f, vec_t iy=0.0f, vec_t iz=0.0f, vec_t iw=0.0f) { x = ix; y = iy; z = iz; w = iw; }

 bool IsValid() const;
 void Invalidate();

 bool operator==( const Quaternion &src ) const;
 bool operator!=( const Quaternion &src ) const;

 vec_t* Base() { return (vec_t*)this; }
 const vec_t* Base() const { return (vec_t*)this; }


 vec_t operator[](int i) const;
 vec_t& operator[](int i);

 vec_t x, y, z, w;
};





inline vec_t& Quaternion::operator[](int i)
{
 ((void)0);
 return ((vec_t*)this)[i];
}

inline vec_t Quaternion::operator[](int i) const
{
 ((void)0);
 return ((vec_t*)this)[i];
}





inline bool Quaternion::operator==( const Quaternion &src ) const
{
 return ( x == src.x ) && ( y == src.y ) && ( z == src.z ) && ( w == src.w );
}

inline bool Quaternion::operator!=( const Quaternion &src ) const
{
 return !operator==( src );
}





inline bool QuaternionsAreEqual( const Quaternion& src1, const Quaternion& src2, float tolerance )
{
 if (FloatMakePositive(src1.x - src2.x) > tolerance)
  return false;
 if (FloatMakePositive(src1.y - src2.y) > tolerance)
  return false;
 if (FloatMakePositive(src1.z - src2.z) > tolerance)
  return false;
 return (FloatMakePositive(src1.w - src2.w) <= tolerance);
}





class __attribute__((aligned(16))) QuaternionAligned : public Quaternion
{
public:
 inline QuaternionAligned(void) {};
 inline QuaternionAligned(vec_t X, vec_t Y, vec_t Z, vec_t W)
 {
  Init(X,Y,Z,W);
 }
public:
 explicit QuaternionAligned(const Quaternion &vOther)
 {
  Init(vOther.x, vOther.y, vOther.z, vOther.w);
 }

 QuaternionAligned& operator=(const Quaternion &vOther)
 {
  Init(vOther.x, vOther.y, vOther.z, vOther.w);
  return *this;
 }


};





class QAngle;
class RadianEuler
{
public:
 inline RadianEuler(void) { }
 inline RadianEuler(vec_t X, vec_t Y, vec_t Z) { x = X; y = Y; z = Z; }
 inline RadianEuler(Quaternion const &q);
 inline RadianEuler(QAngle const &angles);


 inline void Init(vec_t ix=0.0f, vec_t iy=0.0f, vec_t iz=0.0f) { x = ix; y = iy; z = iz; }


 QAngle ToQAngle( void ) const;
 bool IsValid() const;
 void Invalidate();


 vec_t operator[](int i) const;
 vec_t& operator[](int i);

 vec_t x, y, z;
};


extern void AngleQuaternion( RadianEuler const &angles, Quaternion &qt );
extern void QuaternionAngles( Quaternion const &q, RadianEuler &angles );
inline Quaternion::Quaternion(RadianEuler const &angle)
{
 AngleQuaternion( angle, *this );
}

inline bool Quaternion::IsValid() const
{
 return IsFinite(x) && IsFinite(y) && IsFinite(z) && IsFinite(w);
}

inline void Quaternion::Invalidate()
{


 x = y = z = w = BitsToFloat( (unsigned long)0x7FC00000 );


}

inline RadianEuler::RadianEuler(Quaternion const &q)
{
 QuaternionAngles( q, *this );
}

inline void VectorCopy( RadianEuler const& src, RadianEuler &dst )
{
 ;
 dst.x = src.x;
 dst.y = src.y;
 dst.z = src.z;
}

inline void VectorScale( RadianEuler const& src, float b, RadianEuler &dst )
{
 ;
 ((void)0);
 dst.x = src.x * b;
 dst.y = src.y * b;
 dst.z = src.z * b;
}

inline bool RadianEuler::IsValid() const
{
 return IsFinite(x) && IsFinite(y) && IsFinite(z);
}

inline void RadianEuler::Invalidate()
{


 x = y = z = BitsToFloat( (unsigned long)0x7FC00000 );


}





inline vec_t& RadianEuler::operator[](int i)
{
 ((void)0);
 return ((vec_t*)this)[i];
}

inline vec_t RadianEuler::operator[](int i) const
{
 ((void)0);
 return ((vec_t*)this)[i];
}





class QAngleByValue;

class QAngle
{
public:

 vec_t x, y, z;


 QAngle(void);
 QAngle(vec_t X, vec_t Y, vec_t Z);



 operator QAngleByValue &() { return *((QAngleByValue *)(this)); }
 operator const QAngleByValue &() const { return *((const QAngleByValue *)(this)); }


 void Init(vec_t ix=0.0f, vec_t iy=0.0f, vec_t iz=0.0f);
 void Random( vec_t minVal, vec_t maxVal );


 bool IsValid() const;
 void Invalidate();


 vec_t operator[](int i) const;
 vec_t& operator[](int i);


 vec_t* Base();
 vec_t const* Base() const;


 bool operator==(const QAngle& v) const;
 bool operator!=(const QAngle& v) const;


 QAngle& operator+=(const QAngle &v);
 QAngle& operator-=(const QAngle &v);
 QAngle& operator*=(float s);
 QAngle& operator/=(float s);


 vec_t Length() const;
 vec_t LengthSqr() const;





 QAngle& operator=( const QAngle& src );





 QAngle operator-(void) const;

 QAngle operator+(const QAngle& v) const;
 QAngle operator-(const QAngle& v) const;
 QAngle operator*(float fl) const;
 QAngle operator/(float fl) const;







};




class QAngleByValue : public QAngle
{
public:

 QAngleByValue(void) : QAngle() {}
 QAngleByValue(vec_t X, vec_t Y, vec_t Z) : QAngle( X, Y, Z ) {}
 QAngleByValue(const QAngleByValue& vOther) { *this = vOther; }
};


inline void VectorAdd( const QAngle& a, const QAngle& b, QAngle& result )
{
 ;
 ;
 result.x = a.x + b.x;
 result.y = a.y + b.y;
 result.z = a.z + b.z;
}

inline void VectorMA( const QAngle &start, float scale, const QAngle &direction, QAngle &dest )
{
 ;
 ;
 dest.x = start.x + scale * direction.x;
 dest.y = start.y + scale * direction.y;
 dest.z = start.z + scale * direction.z;
}





inline QAngle::QAngle(void)
{






}

inline QAngle::QAngle(vec_t X, vec_t Y, vec_t Z)
{
 x = X; y = Y; z = Z;
 ;
}





inline void QAngle::Init( vec_t ix, vec_t iy, vec_t iz )
{
 x = ix; y = iy; z = iz;
 ;
}

inline void QAngle::Random( vec_t minVal, vec_t maxVal )
{
 x = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 y = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 z = minVal + ((float)rand() / 
                              2147483647
                                      ) * (maxVal - minVal);
 ;
}



inline QAngle RandomAngle( float minVal, float maxVal )
{
 Vector random;
 random.Random( minVal, maxVal );
 QAngle ret( random.x, random.y, random.z );
 return ret;
}




inline RadianEuler::RadianEuler(QAngle const &angles)
{
 Init(
  angles.z * 3.14159265358979323846f / 180.f,
  angles.x * 3.14159265358979323846f / 180.f,
  angles.y * 3.14159265358979323846f / 180.f );
}




inline QAngle RadianEuler::ToQAngle( void) const
{
 return QAngle(
  y * 180.f / 3.14159265358979323846f,
  z * 180.f / 3.14159265358979323846f,
  x * 180.f / 3.14159265358979323846f );
}





inline QAngle& QAngle::operator=(const QAngle &vOther)
{
 ;
 x=vOther.x; y=vOther.y; z=vOther.z;
 return *this;
}





inline vec_t& QAngle::operator[](int i)
{
 ((void)0);
 return ((vec_t*)this)[i];
}

inline vec_t QAngle::operator[](int i) const
{
 ((void)0);
 return ((vec_t*)this)[i];
}





inline vec_t* QAngle::Base()
{
 return (vec_t*)this;
}

inline vec_t const* QAngle::Base() const
{
 return (vec_t const*)this;
}





inline bool QAngle::IsValid() const
{
 return IsFinite(x) && IsFinite(y) && IsFinite(z);
}





inline void QAngle::Invalidate()
{


 x = y = z = BitsToFloat( (unsigned long)0x7FC00000 );


}




inline bool QAngle::operator==( const QAngle& src ) const
{
 ;
 ;
 return (src.x == x) && (src.y == y) && (src.z == z);
}

inline bool QAngle::operator!=( const QAngle& src ) const
{
 ;
 ;
 return (src.x != x) || (src.y != y) || (src.z != z);
}





inline void VectorCopy( const QAngle& src, QAngle& dst )
{
 ;
 dst.x = src.x;
 dst.y = src.y;
 dst.z = src.z;
}





inline QAngle& QAngle::operator+=(const QAngle& v)
{
 ;
 ;
 x+=v.x; y+=v.y; z += v.z;
 return *this;
}

inline QAngle& QAngle::operator-=(const QAngle& v)
{
 ;
 ;
 x-=v.x; y-=v.y; z -= v.z;
 return *this;
}

inline QAngle& QAngle::operator*=(float fl)
{
 x *= fl;
 y *= fl;
 z *= fl;
 ;
 return *this;
}

inline QAngle& QAngle::operator/=(float fl)
{
 ((void)0);
 float oofl = 1.0f / fl;
 x *= oofl;
 y *= oofl;
 z *= oofl;
 ;
 return *this;
}





inline vec_t QAngle::Length( ) const
{
 ;
 return (vec_t)(*pfSqrt)(LengthSqr( ));
}


inline vec_t QAngle::LengthSqr( ) const
{
 ;
 return x * x + y * y + z * z;
}





inline bool QAnglesAreEqual( const QAngle& src1, const QAngle& src2, float tolerance = 0.0f )
{
 if (FloatMakePositive(src1.x - src2.x) > tolerance)
  return false;
 if (FloatMakePositive(src1.y - src2.y) > tolerance)
  return false;
 return (FloatMakePositive(src1.z - src2.z) <= tolerance);
}







inline QAngle QAngle::operator-(void) const
{
 QAngle ret(-x,-y,-z);
 return ret;
}

inline QAngle QAngle::operator+(const QAngle& v) const
{
 QAngle res;
 res.x = x + v.x;
 res.y = y + v.y;
 res.z = z + v.z;
 return res;
}

inline QAngle QAngle::operator-(const QAngle& v) const
{
 QAngle res;
 res.x = x - v.x;
 res.y = y - v.y;
 res.z = z - v.z;
 return res;
}

inline QAngle QAngle::operator*(float fl) const
{
 QAngle res;
 res.x = x * fl;
 res.y = y * fl;
 res.z = z * fl;
 return res;
}

inline QAngle QAngle::operator/(float fl) const
{
 QAngle res;
 res.x = x / fl;
 res.y = y / fl;
 res.z = z / fl;
 return res;
}

inline QAngle operator*(float fl, const QAngle& v)
{
        QAngle ret( v * fl );
 return ret;
}







inline void QAngleToAngularImpulse( const QAngle &angles, AngularImpulse &impulse )
{
 impulse.x = angles.z;
 impulse.y = angles.x;
 impulse.z = angles.y;
}

inline void AngularImpulseToQAngle( const AngularImpulse &impulse, QAngle &angles )
{
 angles.x = impulse.y;
 angles.y = impulse.z;
 angles.z = impulse.x;
}


extern float (*pfInvRSquared)( const float *v );

inline vec_t InvRSquared( float const *v )
{
 return (*pfInvRSquared)(v);
}

inline vec_t InvRSquared( const Vector &v )
{
 return InvRSquared(&v.x);
}
extern float ( *pfVectorNormalize)(Vector& v);


inline float VectorNormalize( Vector& v )
{
 return (*pfVectorNormalize)(v);
}

inline float VectorNormalize( float * v )
{
 return VectorNormalize(*(reinterpret_cast<Vector *>(v)));
}
extern void ( *pfVectorNormalizeFast)(Vector& v);

inline void VectorNormalizeFast( Vector& v )
{
 (*pfVectorNormalizeFast)(v);
}
inline vec_t Vector::NormalizeInPlace()
{
 return VectorNormalize( *this );
}

inline bool Vector::IsLengthGreaterThan( float val ) const
{
 return LengthSqr() > val*val;
}

inline bool Vector::IsLengthLessThan( float val ) const
{
 return LengthSqr() < val*val;
}
struct cplane_t
{
 Vector normal;
 float dist;
 byte type;
 byte signbits;
 byte pad[2];
};
enum
{
 FRUSTUM_RIGHT = 0,
 FRUSTUM_LEFT = 1,
 FRUSTUM_TOP = 2,
 FRUSTUM_BOTTOM = 3,
 FRUSTUM_NEARZ = 4,
 FRUSTUM_FARZ = 5,
 FRUSTUM_NUMPLANES = 6
};

extern int SignbitsForPlane( cplane_t *out );

class Frustum_t
{
public:
 void SetPlane( int i, int nType, const Vector &vecNormal, float dist )
 {
  m_Plane[i].normal = vecNormal;
  m_Plane[i].dist = dist;
  m_Plane[i].type = nType;
  m_Plane[i].signbits = SignbitsForPlane( &m_Plane[i] );
  m_AbsNormal[i].Init( fabs(vecNormal.x), fabs(vecNormal.y), fabs(vecNormal.z) );
 }

 inline const cplane_t *GetPlane( int i ) const { return &m_Plane[i]; }
 inline const Vector &GetAbsNormal( int i ) const { return m_AbsNormal[i]; }

private:
 cplane_t m_Plane[FRUSTUM_NUMPLANES];
 Vector m_AbsNormal[FRUSTUM_NUMPLANES];
};


float CalcFovY( float flFovX, float flScreenAspect );
float CalcFovX( float flFovY, float flScreenAspect );



void GeneratePerspectiveFrustum( const Vector& origin, const QAngle &angles, float flZNear, float flZFar, float flFovX, float flAspectRatio, Frustum_t &frustum );
void GeneratePerspectiveFrustum( const Vector& origin, const Vector &forward, const Vector &right, const Vector &up, float flZNear, float flZFar, float flFovX, float flFovY, Frustum_t &frustum );


bool R_CullBox( const Vector& mins, const Vector& maxs, const Frustum_t &frustum );
bool R_CullBoxSkipNear( const Vector& mins, const Vector& maxs, const Frustum_t &frustum );

struct matrix3x4_t
{
 matrix3x4_t() {}
 matrix3x4_t(
  float m00, float m01, float m02, float m03,
  float m10, float m11, float m12, float m13,
  float m20, float m21, float m22, float m23 )
 {
  m_flMatVal[0][0] = m00; m_flMatVal[0][1] = m01; m_flMatVal[0][2] = m02; m_flMatVal[0][3] = m03;
  m_flMatVal[1][0] = m10; m_flMatVal[1][1] = m11; m_flMatVal[1][2] = m12; m_flMatVal[1][3] = m13;
  m_flMatVal[2][0] = m20; m_flMatVal[2][1] = m21; m_flMatVal[2][2] = m22; m_flMatVal[2][3] = m23;
 }





 void Init( const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector &vecOrigin )
 {
  m_flMatVal[0][0] = xAxis.x; m_flMatVal[0][1] = yAxis.x; m_flMatVal[0][2] = zAxis.x; m_flMatVal[0][3] = vecOrigin.x;
  m_flMatVal[1][0] = xAxis.y; m_flMatVal[1][1] = yAxis.y; m_flMatVal[1][2] = zAxis.y; m_flMatVal[1][3] = vecOrigin.y;
  m_flMatVal[2][0] = xAxis.z; m_flMatVal[2][1] = yAxis.z; m_flMatVal[2][2] = zAxis.z; m_flMatVal[2][3] = vecOrigin.z;
 }





 matrix3x4_t( const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector &vecOrigin )
 {
  Init( xAxis, yAxis, zAxis, vecOrigin );
 }

 inline void Invalidate( void )
 {
  for (int i = 0; i < 3; i++)
  {
   for (int j = 0; j < 4; j++)
   {
    m_flMatVal[i][j] = BitsToFloat( (unsigned long)0x7FC00000 );
   }
  }
 }

 float *operator[]( int i ) { ((void)0); return m_flMatVal[i]; }
 const float *operator[]( int i ) const { ((void)0); return m_flMatVal[i]; }
 float *Base() { return &m_flMatVal[0][0]; }
 const float *Base() const { return &m_flMatVal[0][0]; }

 float m_flMatVal[3][4];
};
extern bool s_bMathlibInitialized;

extern const Vector vec3_origin;
extern const QAngle vec3_angle;
extern const Quaternion quat_identity;
extern const Vector vec3_invalid;
extern const int nanmask;



inline vec_t DotProduct(const vec_t *v1, const vec_t *v2)
{
 return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}
inline void VectorSubtract(const vec_t *a, const vec_t *b, vec_t *c)
{
 c[0]=a[0]-b[0];
 c[1]=a[1]-b[1];
 c[2]=a[2]-b[2];
}
inline void VectorAdd(const vec_t *a, const vec_t *b, vec_t *c)
{
 c[0]=a[0]+b[0];
 c[1]=a[1]+b[1];
 c[2]=a[2]+b[2];
}
inline void VectorCopy(const vec_t *a, vec_t *b)
{
 b[0]=a[0];
 b[1]=a[1];
 b[2]=a[2];
}
inline void VectorClear(vec_t *a)
{
 a[0]=a[1]=a[2]=0;
}

inline float VectorMaximum(const vec_t *v)
{
 return ( ( ( v[0] ) > ( ( ( ( v[1] ) > ( v[2] ) ) ? ( v[1] ) : ( v[2] ) ) ) ) ? ( v[0] ) : ( ( ( ( v[1] ) > ( v[2] ) ) ? ( v[1] ) : ( v[2] ) ) ) );
}

inline float VectorMaximum(const Vector& v)
{
 return ( ( ( v.x ) > ( ( ( ( v.y ) > ( v.z ) ) ? ( v.y ) : ( v.z ) ) ) ) ? ( v.x ) : ( ( ( ( v.y ) > ( v.z ) ) ? ( v.y ) : ( v.z ) ) ) );
}

inline void VectorScale (const float* in, vec_t scale, float* out)
{
 out[0] = in[0]*scale;
 out[1] = in[1]*scale;
 out[2] = in[2]*scale;
}



inline void VectorFill(vec_t *a, float b)
{
 a[0]=a[1]=a[2]=b;
}

inline void VectorNegate(vec_t *a)
{
 a[0]=-a[0];
 a[1]=-a[1];
 a[2]=-a[2];
}
inline void VectorMAInline( const float* start, float scale, const float* direction, float* dest )
{
 dest[0]=start[0]+direction[0]*scale;
 dest[1]=start[1]+direction[1]*scale;
 dest[2]=start[2]+direction[2]*scale;
}

inline void VectorMAInline( const Vector& start, float scale, const Vector& direction, Vector& dest )
{
 dest.x=start.x+direction.x*scale;
 dest.y=start.y+direction.y*scale;
 dest.z=start.z+direction.z*scale;
}






inline void VectorMA( const float * start, float scale, const float *direction, float *dest )
{
 VectorMAInline(start, scale, direction, dest);
}


int VectorCompare (const float *v1, const float *v2);

inline float VectorLength(const float *v)
{
 return (*pfSqrt)(v[0]*v[0] + v[1]*v[1] + v[2]*v[2] + 1.19209289550781250000e-7F);
}

void CrossProduct (const float *v1, const float *v2, float *cross);

qboolean VectorsEqual( const float *v1, const float *v2 );

inline vec_t RoundInt (vec_t in)
{
 return floor(in + 0.5f);
}

int Q_log2(int val);


void inline SinCos( float radians, float *sine, float *cosine )
{
 register double __cosr, __sinr;
  __asm __volatile__
      ("fsincos"
      : "=t" (__cosr), "=u" (__sinr) : "0" (radians));

   *sine = __sinr;
   *cosine = __cosr;

}



extern float SinCosTable[256];

inline float TableCos( float theta )
{
 union
 {
  int i;
  float f;
 } ftmp;


 ftmp.f = theta * ( float )( 256 / ( 2.0f * 
                                                      3.14159265358979323846 
                                                           ) ) + ( 12582912.f + ( 256 / 4 ) );
 return SinCosTable[ ftmp.i & ( 256 - 1 ) ];
}

inline float TableSin( float theta )
{
 union
 {
  int i;
  float f;
 } ftmp;


 ftmp.f = theta * ( float )( 256 / ( 2.0f * 
                                                      3.14159265358979323846 
                                                           ) ) + 12582912.f;
 return SinCosTable[ ftmp.i & ( 256 - 1 ) ];
}

template<class T>
inline T Square( T const &a )
{
 return a * a;
}


inline bool IsPowerOfTwo( uint x )
{
 return ( x & ( x - 1 ) ) == 0;
}





inline uint SmallestPowerOfTwoGreaterOrEqual( uint x )
{
 x -= 1;
 x |= x >> 1;
 x |= x >> 2;
 x |= x >> 4;
 x |= x >> 8;
 x |= x >> 16;
 return x + 1;
}


inline uint LargestPowerOfTwoLessThanOrEqual( uint x )
{
 if ( x >= 0x80000000 )
  return 0x80000000;

 return SmallestPowerOfTwoGreaterOrEqual( x + 1 ) >> 1;
}



void FloorDivMod (double numer, double denom, int *quotient, int *rem);
int GreatestCommonDivisor (int i1, int i2);


bool IsDenormal( const float &val );


enum
{
 PITCH = 0,
 YAW,
 ROLL
};

void MatrixAngles( const matrix3x4_t & matrix, float *angles );
void MatrixVectors( const matrix3x4_t &matrix, Vector* pForward, Vector *pRight, Vector *pUp );
void VectorTransform (const float *in1, const matrix3x4_t & in2, float *out);
void VectorITransform (const float *in1, const matrix3x4_t & in2, float *out);
void VectorRotate( const float *in1, const matrix3x4_t & in2, float *out);
void VectorRotate( const Vector &in1, const QAngle &in2, Vector &out );
void VectorRotate( const Vector &in1, const Quaternion &in2, Vector &out );
void VectorIRotate( const float *in1, const matrix3x4_t & in2, float *out);



QAngle TransformAnglesToLocalSpace( const QAngle &angles, const matrix3x4_t &parentMatrix );
QAngle TransformAnglesToWorldSpace( const QAngle &angles, const matrix3x4_t &parentMatrix );



void MatrixInitialize( matrix3x4_t &mat, const Vector &vecOrigin, const Vector &vecXAxis, const Vector &vecYAxis, const Vector &vecZAxis );
void MatrixCopy( const matrix3x4_t &in, matrix3x4_t &out );
void MatrixInvert( const matrix3x4_t &in, matrix3x4_t &out );


bool MatricesAreEqual( const matrix3x4_t &src1, const matrix3x4_t &src2, float flTolerance = 1e-5 );

void MatrixGetColumn( const matrix3x4_t &in, int column, Vector &out );
void MatrixSetColumn( const Vector &in, int column, matrix3x4_t &out );


void ConcatRotations (const matrix3x4_t &in1, const matrix3x4_t &in2, matrix3x4_t &out);
void ConcatTransforms (const matrix3x4_t &in1, const matrix3x4_t &in2, matrix3x4_t &out);


inline void MatrixMultiply ( const matrix3x4_t &in1, const matrix3x4_t &in2, matrix3x4_t &out )
{
 ConcatTransforms( in1, in2, out );
}

void QuaternionSlerp( const Quaternion &p, const Quaternion &q, float t, Quaternion &qt );
void QuaternionSlerpNoAlign( const Quaternion &p, const Quaternion &q, float t, Quaternion &qt );
void QuaternionBlend( const Quaternion &p, const Quaternion &q, float t, Quaternion &qt );
void QuaternionBlendNoAlign( const Quaternion &p, const Quaternion &q, float t, Quaternion &qt );
void QuaternionIdentityBlend( const Quaternion &p, float t, Quaternion &qt );
float QuaternionAngleDiff( const Quaternion &p, const Quaternion &q );
void QuaternionScale( const Quaternion &p, float t, Quaternion &q );
void QuaternionAlign( const Quaternion &p, const Quaternion &q, Quaternion &qt );
float QuaternionDotProduct( const Quaternion &p, const Quaternion &q );
void QuaternionConjugate( const Quaternion &p, Quaternion &q );
void QuaternionInvert( const Quaternion &p, Quaternion &q );
float QuaternionNormalize( Quaternion &q );
void QuaternionAdd( const Quaternion &p, const Quaternion &q, Quaternion &qt );
void QuaternionMult( const Quaternion &p, const Quaternion &q, Quaternion &qt );
void QuaternionMatrix( const Quaternion &q, matrix3x4_t &matrix );
void QuaternionMatrix( const Quaternion &q, const Vector &pos, matrix3x4_t &matrix );
void QuaternionAngles( const Quaternion &q, QAngle &angles );
void AngleQuaternion( const QAngle& angles, Quaternion &qt );
void QuaternionAngles( const Quaternion &q, RadianEuler &angles );
void AngleQuaternion( RadianEuler const &angles, Quaternion &qt );
void QuaternionAxisAngle( const Quaternion &q, Vector &axis, float &angle );
void AxisAngleQuaternion( const Vector &axis, float angle, Quaternion &q );
void BasisToQuaternion( const Vector &vecForward, const Vector &vecRight, const Vector &vecUp, Quaternion &q );
void MatrixQuaternion( const matrix3x4_t &mat, Quaternion &q );


inline float MatrixRowDotProduct( const matrix3x4_t &in1, int row, const Vector& in2 )
{
 ((void)0);
 return DotProduct( in1[row], in2.Base() );
}

inline float MatrixColumnDotProduct( const matrix3x4_t &in1, int col, const Vector& in2 )
{
 ((void)0);
 return in1[0][col] * in2[0] + in1[1][col] * in2[1] + in1[2][col] * in2[2];
}

int BoxOnPlaneSide (const float *emins, const float *emaxs, const cplane_t *plane);

inline float anglemod(float a)
{
 a = (360.f/65536) * ((int)(a*(65536.f/360.0f)) & 65535);
 return a;
}


inline float RemapVal( float val, float A, float B, float C, float D)
{
 if ( A == B )
  return val >= B ? D : C;
 return C + (D - C) * (val - A) / (B - A);
}

inline float RemapValClamped( float val, float A, float B, float C, float D)
{
 if ( A == B )
  return val >= B ? D : C;
 float cVal = (val - A) / (B - A);
 cVal = clamp( cVal, 0.0f, 1.0f );

 return C + (D - C) * cVal;
}



template <class T>
inline T Lerp( float flPercent, T const &A, T const &B )
{
 return (T)(A + (B - A) * flPercent);
}

inline float Sqr( float f )
{
 return f*f;
}
static inline float FLerp(float f1, float f2, float i1, float i2, float x)
{
  return f1+(f2-f1)*(x-i1)/(i2-i1);
}





template<> inline QAngle Lerp<QAngle>( float flPercent, const QAngle& q1, const QAngle& q2 )
{

 if ( q1 == q2 )
  return q1;

 Quaternion src, dest;


 AngleQuaternion( q1, src );
 AngleQuaternion( q2, dest );

 Quaternion result;


 QuaternionSlerp( src, dest, flPercent, result );


 QAngle output;
 QuaternionAngles( result, output );
 return output;
}
template <class T>
inline void swap( T& x, T& y )
{
 T temp = x;
 x = y;
 y = temp;
}

template <class T> inline T AVG(T a, T b)
{
 return (a+b)/2;
}
inline float Sign( float x )
{
 return (x <0.0f) ? -1.0f : 1.0f;
}
inline int ClampArrayBounds( int n, unsigned maxindex )
{

 unsigned int inrangemask = 0xFFFFFFFF + (((unsigned) n) > maxindex );
 unsigned int lessthan0mask = 0xFFFFFFFF + ( n >= 0 );


 int result = (inrangemask & n);


 result |= ((~inrangemask) & (~lessthan0mask)) & maxindex;

 return result;
}
void AngleVectors (const QAngle& angles, Vector *forward);
void AngleVectors (const QAngle& angles, Vector *forward, Vector *right, Vector *up);
void AngleVectorsTranspose (const QAngle& angles, Vector *forward, Vector *right, Vector *up);
void AngleMatrix (const QAngle &angles, matrix3x4_t &mat );
void AngleMatrix( const QAngle &angles, const Vector &position, matrix3x4_t &mat );
void AngleMatrix (const RadianEuler &angles, matrix3x4_t &mat );
void AngleMatrix( RadianEuler const &angles, const Vector &position, matrix3x4_t &mat );
void AngleIMatrix (const QAngle &angles, matrix3x4_t &mat );
void AngleIMatrix (const QAngle &angles, const Vector &position, matrix3x4_t &mat );
void AngleIMatrix (const RadianEuler &angles, matrix3x4_t &mat );
void VectorAngles( const Vector &forward, QAngle &angles );
void VectorAngles( const Vector &forward, const Vector &pseudoup, QAngle &angles );
void VectorMatrix( const Vector &forward, matrix3x4_t &mat );
void VectorVectors( const Vector &forward, Vector &right, Vector &up );
void SetIdentityMatrix( matrix3x4_t &mat );
void SetScaleMatrix( float x, float y, float z, matrix3x4_t &dst );
void MatrixBuildRotationAboutAxis( const Vector &vAxisOfRot, float angleDegrees, matrix3x4_t &dst );

inline void SetScaleMatrix( float flScale, matrix3x4_t &dst )
{
 SetScaleMatrix( flScale, flScale, flScale, dst );
}

inline void SetScaleMatrix( const Vector& scale, matrix3x4_t &dst )
{
 SetScaleMatrix( scale.x, scale.y, scale.z, dst );
}


void MatrixTranspose( matrix3x4_t& mat );
void MatrixTranspose( const matrix3x4_t& src, matrix3x4_t& dst );
void MatrixInverseTranspose( const matrix3x4_t& src, matrix3x4_t& dst );

inline void PositionMatrix( const Vector &position, matrix3x4_t &mat )
{
 MatrixSetColumn( position, 3, mat );
}

inline void MatrixPosition( const matrix3x4_t &matrix, Vector &position )
{
 MatrixGetColumn( matrix, 3, position );
}

inline void VectorRotate( const Vector& in1, const matrix3x4_t &in2, Vector &out)
{
 VectorRotate( &in1.x, in2, &out.x );
}

inline void VectorIRotate( const Vector& in1, const matrix3x4_t &in2, Vector &out)
{
 VectorIRotate( &in1.x, in2, &out.x );
}

inline void MatrixAngles( const matrix3x4_t &matrix, QAngle &angles )
{
 MatrixAngles( matrix, &angles.x );
}

inline void MatrixAngles( const matrix3x4_t &matrix, QAngle &angles, Vector &position )
{
 MatrixAngles( matrix, angles );
 MatrixPosition( matrix, position );
}

inline void MatrixAngles( const matrix3x4_t &matrix, RadianEuler &angles )
{
 MatrixAngles( matrix, &angles.x );

 angles.Init( ( (float)(angles.z) * (float)(((float)(
             3.14159265358979323846
             )) / 180.f) ), ( (float)(angles.x) * (float)(((float)(
                                  3.14159265358979323846
                                  )) / 180.f) ), ( (float)(angles.y) * (float)(((float)(
                                                       3.14159265358979323846
                                                       )) / 180.f) ) );
}

void MatrixAngles( const matrix3x4_t &mat, RadianEuler &angles, Vector &position );

void MatrixAngles( const matrix3x4_t &mat, Quaternion &q, Vector &position );

inline int VectorCompare (const Vector& v1, const Vector& v2)
{
 return v1 == v2;
}

inline void VectorTransform (const Vector& in1, const matrix3x4_t &in2, Vector &out)
{
 VectorTransform( &in1.x, in2, &out.x );
}

inline void VectorITransform (const Vector& in1, const matrix3x4_t &in2, Vector &out)
{
 VectorITransform( &in1.x, in2, &out.x );
}
inline int BoxOnPlaneSide (const Vector& emins, const Vector& emaxs, const cplane_t *plane )
{
 return BoxOnPlaneSide( &emins.x, &emaxs.x, plane );
}

inline void VectorFill(Vector& a, float b)
{
 a[0]=a[1]=a[2]=b;
}

inline void VectorNegate(Vector& a)
{
 a[0] = -a[0];
 a[1] = -a[1];
 a[2] = -a[2];
}

inline vec_t VectorAvg(Vector& a)
{
 return ( a[0] + a[1] + a[2] ) / 3;
}




inline int BoxOnPlaneSide2 (const Vector& emins, const Vector& emaxs, const cplane_t *p, float tolerance = 0.f )
{
 Vector corners[2];

 if (p->normal[0] < 0)
 {
  corners[0][0] = emins[0];
  corners[1][0] = emaxs[0];
 }
 else
 {
  corners[1][0] = emins[0];
  corners[0][0] = emaxs[0];
 }

 if (p->normal[1] < 0)
 {
  corners[0][1] = emins[1];
  corners[1][1] = emaxs[1];
 }
 else
 {
  corners[1][1] = emins[1];
  corners[0][1] = emaxs[1];
 }

 if (p->normal[2] < 0)
 {
  corners[0][2] = emins[2];
  corners[1][2] = emaxs[2];
 }
 else
 {
  corners[1][2] = emins[2];
  corners[0][2] = emaxs[2];
 }

 int sides = 0;

 float dist1 = DotProduct (p->normal, corners[0]) - p->dist;
 if (dist1 >= tolerance)
  sides = 1;

 float dist2 = DotProduct (p->normal, corners[1]) - p->dist;
 if (dist2 < -tolerance)
  sides |= 2;

 return sides;
}





void ClearBounds (Vector& mins, Vector& maxs);
void AddPointToBounds (const Vector& v, Vector& mins, Vector& maxs);




void BuildGammaTable( float gamma, float texGamma, float brightness, int overbright );


inline float TexLightToLinear( int c, int exponent )
{
 extern float power2_n[256];
 ((void)0);
 return ( float )c * power2_n[exponent+128];
}



int LinearToTexture( float f );

int LinearToScreenGamma( float f );
float TextureToLinear( int c );


struct ColorRGBExp32
{
 byte r, g, b;
 signed char exponent;
};

void ColorRGBExp32ToVector( const ColorRGBExp32& in, Vector& out );
void VectorToColorRGBExp32( const Vector& v, ColorRGBExp32 &c );


bool SolveQuadratic( float a, float b, float c, float &root1, float &root2 );


bool SolveInverseQuadratic( float x1, float y1, float x2, float y2, float x3, float y3, float &a, float &b, float &c );





bool SolveInverseQuadraticMonotonic( float x1, float y1, float x2, float y2,
          float x3, float y3, float &a, float &b, float &c );





bool SolveInverseReciprocalQuadratic( float x1, float y1, float x2, float y2, float x3, float y3, float &a, float &b, float &c );


void VectorYawRotate( const Vector& in, float flYaw, Vector &out);
float Bias( float x, float biasAmt );
float Gain( float x, float biasAmt );
float SmoothCurve( float x );
float SmoothCurve_Tweak( float x, float flPeakPos=0.5, float flPeakSharpness=0.5 );






inline float ExponentialDecay( float halflife, float dt )
{

 return expf( -0.69314718f / halflife * dt);
}


inline float ExponentialDecay( float decayTo, float decayTime, float dt )
{
 return expf( logf( decayTo ) / decayTime * dt);
}




inline float ExponentialDecayIntegral( float decayTo, float decayTime, float dt )
{
 return (powf( decayTo, dt / decayTime) * decayTime - decayTime) / logf( decayTo );
}




inline float SimpleSpline( float value )
{
 float valueSquared = value * value;


 return (3 * valueSquared - 2 * valueSquared * value);
}



inline float SimpleSplineRemapVal( float val, float A, float B, float C, float D)
{
 if ( A == B )
  return val >= B ? D : C;
 float cVal = (val - A) / (B - A);
 return C + (D - C) * SimpleSpline( cVal );
}



inline float SimpleSplineRemapValClamped( float val, float A, float B, float C, float D )
{
 if ( A == B )
  return val >= B ? D : C;
 float cVal = (val - A) / (B - A);
 cVal = (((cVal) > (1.0f)) ? (1.0f) : (((cVal) < (0.0f)) ? (0.0f) : (cVal)));
 return C + (D - C) * SimpleSpline( cVal );
}

inline int RoundFloatToInt(float f)
{
 int nResult;







 __asm __volatile__ (
  "fistpl %0;": "=m" (nResult): "t" (f) : "st"
 );

 return nResult;

}

inline unsigned char RoundFloatToByte(float f)
{
 int nResult;
 __asm __volatile__ (
  "fistpl %0;": "=m" (nResult): "t" (f) : "st"
 );



 ((void)0);

 return nResult;


}

inline unsigned long RoundFloatToUnsignedLong(float f)
{
 unsigned char nResult[8];
 __asm __volatile__ (
  "fistpl %0;": "=m" (nResult): "t" (f) : "st"
 );


 return *((unsigned long*)nResult);

}

inline bool IsIntegralValue( float flValue, float flTolerance = 0.001f )
{
 return fabs( RoundFloatToInt( flValue ) - flValue ) < flTolerance;
}


inline int Float2Int( float a )
{
 int RetVal;
 RetVal = static_cast<int>( a );


 return RetVal;

}


inline int Floor2Int( float a )
{
   int RetVal;
 RetVal = static_cast<int>( floor(a) );


 return RetVal;
}




inline unsigned char FastFToC( float c )
{
 volatile float dc;


 dc = c * 255.0f + (float)(1 << 23);





 return *(unsigned char*)&dc;

}






inline float ClampToMsec( float in )
{
 int msec = Floor2Int( in * 1000.0f + 0.5f );
 return msec / 1000.0f;
}


inline int Ceil2Int( float a )
{
   int RetVal;
 RetVal = static_cast<int>( ceil(a) );


 return RetVal;
}
inline void GetBarycentricCoords2D(
 Vector2D const &A,
 Vector2D const &B,
 Vector2D const &C,
 Vector2D const &pt,
 float bcCoords[3] )
{

 float invTriArea = 1.0f / ( ( ( B.x - A.x ) * ( C.y - A.y ) - ( B.y - A.y ) * ( C.x - A.x ) ) );



 bcCoords[0] = ( ( ( C.x - B.x ) * ( pt.y - B.y ) - ( C.y - B.y ) * ( pt.x - B.x ) ) ) * invTriArea;
 bcCoords[1] = ( ( ( A.x - C.x ) * ( pt.y - C.y ) - ( A.y - C.y ) * ( pt.x - C.x ) ) ) * invTriArea;
 bcCoords[2] = ( ( ( B.x - A.x ) * ( pt.y - A.y ) - ( B.y - A.y ) * ( pt.x - A.x ) ) ) * invTriArea;
}





inline bool QuickBoxSphereTest(
 const Vector& vOrigin,
 float flRadius,
 const Vector& bbMin,
 const Vector& bbMax )
{
 return vOrigin.x - flRadius < bbMax.x && vOrigin.x + flRadius > bbMin.x &&
  vOrigin.y - flRadius < bbMax.y && vOrigin.y + flRadius > bbMin.y &&
  vOrigin.z - flRadius < bbMax.z && vOrigin.z + flRadius > bbMin.z;
}



inline bool QuickBoxIntersectTest(
 const Vector& vBox1Min,
 const Vector& vBox1Max,
 const Vector& vBox2Min,
 const Vector& vBox2Max )
{
 return
  vBox1Min.x < vBox2Max.x && vBox1Max.x > vBox2Min.x &&
  vBox1Min.y < vBox2Max.y && vBox1Max.y > vBox2Min.y &&
  vBox1Min.z < vBox2Max.z && vBox1Max.z > vBox2Min.z;
}


extern float GammaToLinearFullRange( float gamma );
extern float LinearToGammaFullRange( float linear );
extern float GammaToLinear( float gamma );
extern float LinearToGamma( float linear );

extern float SrgbGammaToLinear( float flSrgbGammaValue );
extern float SrgbLinearToGamma( float flLinearValue );
extern float X360GammaToLinear( float fl360GammaValue );
extern float X360LinearToGamma( float flLinearValue );
extern float SrgbGammaTo360Gamma( float flSrgbGammaValue );


inline float LinearToVertexLight( float f )
{
 extern float lineartovertex[4096];



 int i = RoundFloatToInt( f * 1024.f );


 if( (unsigned)i > 4095 )
 {
  if ( i < 0 )
   i = 0;
  else
   i = 4095;
 }

 return lineartovertex[i];
}


inline unsigned char LinearToLightmap( float f )
{
 extern unsigned char lineartolightmap[4096];


 int i = RoundFloatToInt( f * 1024.f );


 if ( (unsigned)i > 4095 )
 {
  if ( i < 0 )
   i = 0;
  else
   i = 4095;
 }

 return lineartolightmap[i];
}

inline void ColorClamp( Vector& color )
{
 float maxc = ( ( ( color.x ) > ( ( ( ( color.y ) > ( color.z ) ) ? ( color.y ) : ( color.z ) ) ) ) ? ( color.x ) : ( ( ( ( color.y ) > ( color.z ) ) ? ( color.y ) : ( color.z ) ) ) );
 if ( maxc > 1.0f )
 {
  float ooMax = 1.0f / maxc;
  color.x *= ooMax;
  color.y *= ooMax;
  color.z *= ooMax;
 }

 if ( color[0] < 0.f ) color[0] = 0.f;
 if ( color[1] < 0.f ) color[1] = 0.f;
 if ( color[2] < 0.f ) color[2] = 0.f;
}

inline void ColorClampTruncate( Vector& color )
{
 if (color[0] > 1.0f) color[0] = 1.0f; else if (color[0] < 0.0f) color[0] = 0.0f;
 if (color[1] > 1.0f) color[1] = 1.0f; else if (color[1] < 0.0f) color[1] = 0.0f;
 if (color[2] > 1.0f) color[2] = 1.0f; else if (color[2] < 0.0f) color[2] = 0.0f;
}



void Catmull_Rom_Spline(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector &output );



void Catmull_Rom_Spline_Tangent(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector &output );


void Catmull_Rom_Spline_Integral(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );


void Catmull_Rom_Spline_Integral(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 Vector& output );



void Catmull_Rom_Spline_Normalize(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector &output );



void Catmull_Rom_Spline_Integral_Normalize(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );



void Catmull_Rom_Spline_NormalizeX(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector &output );


void Catmull_Rom_Spline_NormalizeX(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );



void Hermite_Spline(
 const Vector &p1,
 const Vector &p2,
 const Vector &d1,
 const Vector &d2,
 float t,
 Vector& output );

float Hermite_Spline(
 float p1,
 float p2,
 float d1,
 float d2,
 float t );


void Hermite_Spline(
 const Vector &p0,
 const Vector &p1,
 const Vector &p2,
 float t,
 Vector& output );

float Hermite_Spline(
 float p0,
 float p1,
 float p2,
 float t );


void Hermite_SplineBasis( float t, float basis[] );

void Hermite_Spline(
 const Quaternion &q0,
 const Quaternion &q1,
 const Quaternion &q2,
 float t,
 Quaternion &output );
void Kochanek_Bartels_Spline(
 float tension,
 float bias,
 float continuity,
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );

void Kochanek_Bartels_Spline_NormalizeX(
 float tension,
 float bias,
 float continuity,
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );


void Cubic_Spline(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );

void Cubic_Spline_NormalizeX(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );


void BSpline(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );

void BSpline_NormalizeX(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );


void Parabolic_Spline(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );

void Parabolic_Spline_NormalizeX(
 const Vector &p1,
 const Vector &p2,
 const Vector &p3,
 const Vector &p4,
 float t,
 Vector& output );



inline float QuinticInterpolatingPolynomial(float t)
{

 return t * t * t *( t * ( t* 6.0 - 15.0 ) + 10.0 );
}




void GetInterpolationData( float const *pKnotPositions,
         float const *pKnotValues,
         int nNumValuesinList,
         int nInterpolationRange,
         float flPositionToInterpolateAt,
         bool bWrap,
         float *pValueA,
         float *pValueB,
         float *pInterpolationValue);

float RangeCompressor( float flValue, float flMin, float flMax, float flBase );




float CalcSqrDistanceToAABB( const Vector &mins, const Vector &maxs, const Vector &point );
void CalcClosestPointOnAABB( const Vector &mins, const Vector &maxs, const Vector &point, Vector &closestOut );
void CalcSqrDistAndClosestPointOnAABB( const Vector &mins, const Vector &maxs, const Vector &point, Vector &closestOut, float &distSqrOut );

inline float CalcDistanceToAABB( const Vector &mins, const Vector &maxs, const Vector &point )
{
 float flDistSqr = CalcSqrDistanceToAABB( mins, maxs, point );
 return sqrt(flDistSqr);
}





void CalcClosestPointOnLine( const Vector &P, const Vector &vLineA, const Vector &vLineB, Vector &vClosest, float *t=0 );
float CalcDistanceToLine( const Vector &P, const Vector &vLineA, const Vector &vLineB, float *t=0 );
float CalcDistanceSqrToLine( const Vector &P, const Vector &vLineA, const Vector &vLineB, float *t=0 );


void CalcClosestPointOnLineSegment( const Vector &P, const Vector &vLineA, const Vector &vLineB, Vector &vClosest, float *t=0 );
float CalcDistanceToLineSegment( const Vector &P, const Vector &vLineA, const Vector &vLineB, float *t=0 );
float CalcDistanceSqrToLineSegment( const Vector &P, const Vector &vLineA, const Vector &vLineB, float *t=0 );


bool CalcLineToLineIntersectionSegment(
   const Vector& p1,const Vector& p2,const Vector& p3,const Vector& p4,Vector *s1,Vector *s2,
   float *t1, float *t2 );


void CalcClosestPointOnLine2D( Vector2D const &P, Vector2D const &vLineA, Vector2D const &vLineB, Vector2D &vClosest, float *t=0 );
float CalcDistanceToLine2D( Vector2D const &P, Vector2D const &vLineA, Vector2D const &vLineB, float *t=0 );
float CalcDistanceSqrToLine2D( Vector2D const &P, Vector2D const &vLineA, Vector2D const &vLineB, float *t=0 );
void CalcClosestPointOnLineSegment2D( Vector2D const &P, Vector2D const &vLineA, Vector2D const &vLineB, Vector2D &vClosest, float *t=0 );
float CalcDistanceToLineSegment2D( Vector2D const &P, Vector2D const &vLineA, Vector2D const &vLineB, float *t=0 );
float CalcDistanceSqrToLineSegment2D( Vector2D const &P, Vector2D const &vLineA, Vector2D const &vLineB, float *t=0 );


void MathLib_Init( float gamma = 2.2f, float texGamma = 2.2f, float brightness = 0.0f, int overbright = 2.0f, bool bAllow3DNow = true, bool bAllowSSE = true, bool bAllowSSE2 = true, bool bAllowMMX = true );
bool MathLib_MMXEnabled( void );
bool MathLib_SSEEnabled( void );
bool MathLib_SSE2Enabled( void );

float Approach( float target, float value, float speed );
float ApproachAngle( float target, float value, float speed );
float AngleDiff( float destAngle, float srcAngle );
float AngleDistance( float next, float cur );
float AngleNormalize( float angle );


float AngleNormalizePositive( float angle );

bool AnglesAreEqual( float a, float b, float tolerance = 0.0f );


void RotationDeltaAxisAngle( const QAngle &srcAngles, const QAngle &destAngles, Vector &deltaAxis, float &deltaAngle );
void RotationDelta( const QAngle &srcAngles, const QAngle &destAngles, QAngle *out );

void ComputeTrianglePlane( const Vector& v1, const Vector& v2, const Vector& v3, Vector& normal, float& intercept );
int PolyFromPlane( Vector *outVerts, const Vector& normal, float dist, float fHalfScale = 9000.0f );
int ClipPolyToPlane( Vector *inVerts, int vertCount, Vector *outVerts, const Vector& normal, float dist, float fOnPlaneEpsilon = 0.1f );
int ClipPolyToPlane_Precise( double *inVerts, int vertCount, double *outVerts, const double *normal, double dist, double fOnPlaneEpsilon = 0.1 );




void CalcTriangleTangentSpace( const Vector &p0, const Vector &p1, const Vector &p2,
         const Vector2D &t0, const Vector2D &t1, const Vector2D& t2,
         Vector &sVect, Vector &tVect );




void TransformAABB( const matrix3x4_t &in1, const Vector &vecMinsIn, const Vector &vecMaxsIn, Vector &vecMinsOut, Vector &vecMaxsOut );




void ITransformAABB( const matrix3x4_t &in1, const Vector &vecMinsIn, const Vector &vecMaxsIn, Vector &vecMinsOut, Vector &vecMaxsOut );





void RotateAABB( const matrix3x4_t &in1, const Vector &vecMinsIn, const Vector &vecMaxsIn, Vector &vecMinsOut, Vector &vecMaxsOut );




void IRotateAABB( const matrix3x4_t &in1, const Vector &vecMinsIn, const Vector &vecMaxsIn, Vector &vecMinsOut, Vector &vecMaxsOut );




inline void MatrixTransformPlane( const matrix3x4_t &src, const cplane_t &inPlane, cplane_t &outPlane )
{
 VectorRotate( inPlane.normal, src, outPlane.normal );
 outPlane.dist = inPlane.dist * DotProduct( outPlane.normal, outPlane.normal );
 outPlane.dist += outPlane.normal.x * src[0][3] + outPlane.normal.y * src[1][3] + outPlane.normal.z * src[2][3];
}

inline void MatrixITransformPlane( const matrix3x4_t &src, const cplane_t &inPlane, cplane_t &outPlane )
{


 Vector vecTranslation;
 MatrixGetColumn( src, 3, vecTranslation );

 Vector vecInvTranslation;
 VectorIRotate( vecTranslation, src, vecInvTranslation );

 VectorIRotate( inPlane.normal, src, outPlane.normal );
 outPlane.dist = inPlane.dist * DotProduct( outPlane.normal, outPlane.normal );
 outPlane.dist -= outPlane.normal.x * vecInvTranslation[0] + outPlane.normal.y * vecInvTranslation[1] + outPlane.normal.z * vecInvTranslation[2];
}

int CeilPow2( int in );
int FloorPow2( int in );

inline float * UnpackNormal_HEND3N( const unsigned int *pPackedNormal, float *pNormal )
{
 int temp[3];
 temp[0] = ((*pPackedNormal >> 0L) & 0x7ff);
 if ( temp[0] & 0x400 )
 {
  temp[0] = 2048 - temp[0];
 }
 temp[1] = ((*pPackedNormal >> 11L) & 0x7ff);
 if ( temp[1] & 0x400 )
 {
  temp[1] = 2048 - temp[1];
 }
 temp[2] = ((*pPackedNormal >> 22L) & 0x3ff);
 if ( temp[2] & 0x200 )
 {
  temp[2] = 1024 - temp[2];
 }
 pNormal[0] = (float)temp[0] * 1.0f/1023.0f;
 pNormal[1] = (float)temp[1] * 1.0f/1023.0f;
 pNormal[2] = (float)temp[2] * 1.0f/511.0f;
 return pNormal;
}

inline unsigned int * PackNormal_HEND3N( const float *pNormal, unsigned int *pPackedNormal )
{
 int temp[3];

 temp[0] = Float2Int( pNormal[0] * 1023.0f );
 temp[1] = Float2Int( pNormal[1] * 1023.0f );
 temp[2] = Float2Int( pNormal[2] * 511.0f );



 ((void)0);
 ((void)0);
 ((void)0);

 *pPackedNormal = ( ( temp[2] & 0x3ff ) << 22L ) |
                     ( ( temp[1] & 0x7ff ) << 11L ) |
                     ( ( temp[0] & 0x7ff ) << 0L );
 return pPackedNormal;
}

inline unsigned int * PackNormal_HEND3N( float nx, float ny, float nz, unsigned int *pPackedNormal )
{
 int temp[3];

 temp[0] = Float2Int( nx * 1023.0f );
 temp[1] = Float2Int( ny * 1023.0f );
 temp[2] = Float2Int( nz * 511.0f );



 ((void)0);
 ((void)0);
 ((void)0);

 *pPackedNormal = ( ( temp[2] & 0x3ff ) << 22L ) |
                     ( ( temp[1] & 0x7ff ) << 11L ) |
                     ( ( temp[0] & 0x7ff ) << 0L );
 return pPackedNormal;
}

inline float * UnpackNormal_SHORT2( const unsigned int *pPackedNormal, float *pNormal, bool bIsTangent = 0 )
{



 short iX = (*pPackedNormal & 0x0000FFFF);
 short iY = (*pPackedNormal & 0xFFFF0000) >> 16;

 float zSign = +1;
 if ( iX < 0 )
 {
  zSign = -1;
  iX = -iX;
 }
 float tSign = +1;
 if ( iY < 0 )
 {
  tSign = -1;
  iY = -iY;
 }

 pNormal[0] = ( iX - 16384.0f ) / 16384.0f;
 pNormal[1] = ( iY - 16384.0f ) / 16384.0f;
 pNormal[2] = zSign*sqrtf( 1.0f - ( pNormal[0]*pNormal[0] + pNormal[1]*pNormal[1] ) );
 if ( bIsTangent )
 {
  pNormal[3] = tSign;
 }

 return pNormal;
}

inline unsigned int * PackNormal_SHORT2( float nx, float ny, float nz, unsigned int *pPackedNormal, float binormalSign = +1.0f )
{







 nx += 1;
 ny += 1;
 nx *= 16384.0f;
 ny *= 16384.0f;


 nx = ( ( ( nx ) > ( 1.0f ) ) ? ( nx ) : ( 1.0f ) );
 ny = ( ( ( ny ) > ( 1.0f ) ) ? ( ny ) : ( 1.0f ) );
 nx = ( ( ( nx ) < ( 32767.0f ) ) ? ( nx ) : ( 32767.0f ) );
 ny = ( ( ( ny ) < ( 32767.0f ) ) ? ( ny ) : ( 32767.0f ) );

 if ( nz < 0.0f )
  nx = -nx;

 ny *= binormalSign;


 short sX = (short)nx;
 short sY = (short)ny;

 *pPackedNormal = ( sX & 0x0000FFFF ) | ( sY << 16 );

 return pPackedNormal;
}

inline unsigned int * PackNormal_SHORT2( const float *pNormal, unsigned int *pPackedNormal, float binormalSign = +1.0f )
{
 return PackNormal_SHORT2( pNormal[0], pNormal[1], pNormal[2], pPackedNormal, binormalSign );
}


inline float * UnpackNormal_UBYTE4( const unsigned int *pPackedNormal, float *pNormal, bool bIsTangent = 0 )
{
 unsigned char cX, cY;
 if ( bIsTangent )
 {
  cX = *pPackedNormal >> 16;
  cY = *pPackedNormal >> 24;
 }
 else
 {
  cX = *pPackedNormal >> 0;
  cY = *pPackedNormal >> 8;
 }

 float x = cX - 128.0f;
 float y = cY - 128.0f;
 float z;

 float zSignBit = x < 0 ? 1.0f : 0.0f;
 float tSignBit = y < 0 ? 1.0f : 0.0f;
 float zSign = -( 2*zSignBit - 1 );
 float tSign = -( 2*tSignBit - 1 );

 x = x*zSign - zSignBit;
 y = y*tSign - tSignBit;
 x = x - 64;
 y = y - 64;

 float xSignBit = x < 0 ? 1.0f : 0.0f;
 float ySignBit = y < 0 ? 1.0f : 0.0f;
 float xSign = -( 2*xSignBit - 1 );
 float ySign = -( 2*ySignBit - 1 );

 x = ( x*xSign - xSignBit ) / 63.0f;
 y = ( y*ySign - ySignBit ) / 63.0f;
 z = 1.0f - x - y;

 float oolen = 1.0f / sqrt( x*x + y*y + z*z );
 x *= oolen * xSign;
 y *= oolen * ySign;
 z *= oolen * zSign;

 pNormal[0] = x;
 pNormal[1] = y;
 pNormal[2] = z;
 if ( bIsTangent )
 {
  pNormal[3] = tSign;
 }

 return pNormal;
}
inline unsigned int * PackNormal_UBYTE4( float nx, float ny, float nz, unsigned int *pPackedNormal, bool bIsTangent = false, float binormalSign = +1.0f )
{
 float xSign = nx < 0.0f ? -1.0f : 1.0f;
 float ySign = ny < 0.0f ? -1.0f : 1.0f;
 float zSign = nz < 0.0f ? -1.0f : 1.0f;
 float tSign = binormalSign;
 ((void)0);

 float xSignBit = 0.5f*( 1 - xSign );
 float ySignBit = 0.5f*( 1 - ySign );
 float zSignBit = 0.5f*( 1 - zSign );
 float tSignBit = 0.5f*( 1 - binormalSign );

 float absX = xSign*nx;
 float absY = ySign*ny;
 float absZ = zSign*nz;

 float xbits = absX / ( absX + absY + absZ );
 float ybits = absY / ( absX + absY + absZ );

 xbits *= 63;
 ybits *= 63;

 xbits = xbits * xSign - xSignBit;
 ybits = ybits * ySign - ySignBit;
 xbits += 64.0f;
 ybits += 64.0f;

 xbits = xbits * zSign - zSignBit;
 ybits = ybits * tSign - tSignBit;

 xbits += 128.0f;
 ybits += 128.0f;

 unsigned char cX = (unsigned char) xbits;
 unsigned char cY = (unsigned char) ybits;

 if ( !bIsTangent )
  *pPackedNormal = (cX << 0) | (cY << 8);
 else
  *pPackedNormal = (cX << 16) | (cY << 24);

 return pPackedNormal;
}

inline unsigned int * PackNormal_UBYTE4( const float *pNormal, unsigned int *pPackedNormal, bool bIsTangent = false, float binormalSign = +1.0f )
{
 return PackNormal_UBYTE4( pNormal[0], pNormal[1], pNormal[2], pPackedNormal, bIsTangent, binormalSign );
}





void RGBtoHSV( const Vector &rgb, Vector &hsv );





void HSVtoRGB( const Vector &hsv, Vector &rgb );


template< class T, class I >
class CUtlBlockMemory
{
public:

 CUtlBlockMemory( int nGrowSize = 0, int nInitSize = 0 );
 ~CUtlBlockMemory();


 void Init( int nGrowSize = 0, int nInitSize = 0 );


 T* Base() { return 
                   __null
                       ; }
 const T* Base() const { return 
                               __null
                                   ; }

 class Iterator_t
 {
 public:
  Iterator_t( I i ) : index( i ) {}
  I index;

  bool operator==( const Iterator_t it ) const { return index == it.index; }
  bool operator!=( const Iterator_t it ) const { return index != it.index; }
 };
 Iterator_t First() const { return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex() ); }
 Iterator_t Next( const Iterator_t &it ) const { return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex() ); }
 I GetIndex( const Iterator_t &it ) const { return it.index; }
 bool IsIdxAfter( I i, const Iterator_t &it ) const { return i > it.index; }
 bool IsValidIterator( const Iterator_t &it ) const { return IsIdxValid( it.index ); }
 Iterator_t InvalidIterator() const { return Iterator_t( InvalidIndex() ); }


 T& operator[]( I i );
 const T& operator[]( I i ) const;
 T& Element( I i );
 const T& Element( I i ) const;


 bool IsIdxValid( I i ) const;
 static I InvalidIndex() { return ( I )-1; }

 void Swap( CUtlBlockMemory< T, I > &mem );


 int NumAllocated() const;
 int Count() const { return NumAllocated(); }


 void Grow( int num = 1 );


 void EnsureCapacity( int num );


 void Purge();


 void Purge( int numElements );

protected:
 int Index( int major, int minor ) const { return ( major << m_nIndexShift ) | minor; }
 int MajorIndex( int i ) const { return i >> m_nIndexShift; }
 int MinorIndex( int i ) const { return i & m_nIndexMask; }
 void ChangeSize( int nBlocks );
 int NumElementsInBlock() const { return m_nIndexMask + 1; }

 T** m_pMemory;
 int m_nBlocks;
 int m_nIndexMask : 27;
 int m_nIndexShift : 5;
};





template< class T, class I >
CUtlBlockMemory<T,I>::CUtlBlockMemory( int nGrowSize, int nInitAllocationCount )
: m_pMemory( 0 ), m_nBlocks( 0 ), m_nIndexMask( 0 ), m_nIndexShift( 0 )
{
 Init( nGrowSize, nInitAllocationCount );
}

template< class T, class I >
CUtlBlockMemory<T,I>::~CUtlBlockMemory()
{
 Purge();
}





template< class T, class I >
void CUtlBlockMemory<T,I>::Swap( CUtlBlockMemory< T, I > &mem )
{
 swap( m_pMemory, mem.m_pMemory );
 swap( m_nBlocks, mem.m_nBlocks );
 swap( m_nIndexMask, mem.m_nIndexMask );
 swap( m_nIndexShift, mem.m_nIndexShift );
}





template< class T, class I >
void CUtlBlockMemory<T,I>::Init( int nGrowSize , int nInitSize )
{
 Purge();

 if ( nGrowSize == 0)
 {

  nGrowSize = ( 127 + sizeof( T ) ) / sizeof( T );
 }
 nGrowSize = SmallestPowerOfTwoGreaterOrEqual( nGrowSize );
 m_nIndexMask = nGrowSize - 1;

 m_nIndexShift = 0;
 while ( nGrowSize > 1 )
 {
  nGrowSize >>= 1;
  ++m_nIndexShift;
 }
 ((void)0);

 Grow( nInitSize );
}





template< class T, class I >
inline T& CUtlBlockMemory<T,I>::operator[]( I i )
{
 ((void)0);
 T *pBlock = m_pMemory[ MajorIndex( i ) ];
 return pBlock[ MinorIndex( i ) ];
}

template< class T, class I >
inline const T& CUtlBlockMemory<T,I>::operator[]( I i ) const
{
 ((void)0);
 const T *pBlock = m_pMemory[ MajorIndex( i ) ];
 return pBlock[ MinorIndex( i ) ];
}

template< class T, class I >
inline T& CUtlBlockMemory<T,I>::Element( I i )
{
 ((void)0);
 T *pBlock = m_pMemory[ MajorIndex( i ) ];
 return pBlock[ MinorIndex( i ) ];
}

template< class T, class I >
inline const T& CUtlBlockMemory<T,I>::Element( I i ) const
{
 ((void)0);
 const T *pBlock = m_pMemory[ MajorIndex( i ) ];
 return pBlock[ MinorIndex( i ) ];
}





template< class T, class I >
inline int CUtlBlockMemory<T,I>::NumAllocated() const
{
 return m_nBlocks * NumElementsInBlock();
}





template< class T, class I >
inline bool CUtlBlockMemory<T,I>::IsIdxValid( I i ) const
{
 return ( i >= 0 ) && ( MajorIndex( i ) < m_nBlocks );
}

template< class T, class I >
void CUtlBlockMemory<T,I>::Grow( int num )
{
 if ( num <= 0 )
  return;

 int nBlockSize = NumElementsInBlock();
 int nBlocks = ( num + nBlockSize - 1 ) / nBlockSize;

 ChangeSize( m_nBlocks + nBlocks );
}

template< class T, class I >
void CUtlBlockMemory<T,I>::ChangeSize( int nBlocks )
{
 ((void)0);

 int nBlocksOld = m_nBlocks;
 m_nBlocks = nBlocks;

 ((void)0);


 for ( int i = m_nBlocks; i < nBlocksOld; ++i )
 {
  ((void)0);
  free( (void*)m_pMemory[ i ] );
 }

 if ( m_pMemory )
 {
  ;
  m_pMemory = (T**)realloc( m_pMemory, m_nBlocks * sizeof(T*) );
  ((void)0);
 }
 else
 {
  ;
  m_pMemory = (T**)malloc( m_nBlocks * sizeof(T*) );
  ((void)0);
 }

 if ( !m_pMemory )
 {
  Error( "CUtlBlockMemory overflow!\n" );
 }


 int nBlockSize = NumElementsInBlock();
 for ( int i = nBlocksOld; i < m_nBlocks; ++i )
 {
  ;
  m_pMemory[ i ] = (T*)malloc( nBlockSize * sizeof( T ) );
  ((void)0);
 }
}





template< class T, class I >
inline void CUtlBlockMemory<T,I>::EnsureCapacity( int num )
{
 Grow( num - NumAllocated() );
}





template< class T, class I >
void CUtlBlockMemory<T,I>::Purge()
{
 if ( !m_pMemory )
  return;

 for ( int i = 0; i < m_nBlocks; ++i )
 {
  ((void)0);
  free( (void*)m_pMemory[ i ] );
 }
 m_nBlocks = 0;

 ((void)0);
 free( (void*)m_pMemory );
 m_pMemory = 0;
}

template< class T, class I >
void CUtlBlockMemory<T,I>::Purge( int numElements )
{
 ((void)0);

 int nAllocated = NumAllocated();
 if ( numElements > nAllocated )
 {

  ((void)0);
  return;
 }

 if ( numElements <= 0 )
 {
  Purge();
  return;
 }

 int nBlockSize = NumElementsInBlock();
 int nBlocks = ( numElements + nBlockSize - 1 ) / nBlockSize;


 if ( nBlocks == m_nBlocks )
  return;

 ChangeSize( nBlocks );
}

template< class T, class A = CUtlMemory<T> >
class CUtlVector
{
 typedef A CAllocator;
public:
 typedef T ElemType_t;


 CUtlVector( int growSize = 0, int initSize = 0 );
 CUtlVector( T* pMemory, int allocationCount, int numElements = 0 );
 ~CUtlVector();


 CUtlVector<T, A>& operator=( const CUtlVector<T, A> &other );


 T& operator[]( int i );
 const T& operator[]( int i ) const;
 T& Element( int i );
 const T& Element( int i ) const;
 T& Head();
 const T& Head() const;
 T& Tail();
 const T& Tail() const;


 T* Base() { return m_Memory.Base(); }
 const T* Base() const { return m_Memory.Base(); }



 int Count() const;
 int Size() const;


 bool IsValidIndex( int i ) const;
 static int InvalidIndex();


 int AddToHead();
 int AddToTail();
 int InsertBefore( int elem );
 int InsertAfter( int elem );


 int AddToHead( const T& src );
 int AddToTail( const T& src );
 int InsertBefore( int elem, const T& src );
 int InsertAfter( int elem, const T& src );


 int AddMultipleToHead( int num );
 int AddMultipleToTail( int num, const T *pToCopy=
                                                 __null 
                                                      );
 int InsertMultipleBefore( int elem, int num, const T *pToCopy=
                                                              __null 
                                                                   );
 int InsertMultipleAfter( int elem, int num );


 void SetSize( int size );
 void SetCount( int count );


 void CopyArray( const T *pArray, int size );


 void Swap( CUtlVector< T, A > &vec );


 int AddVectorToTail( CUtlVector<T, A> const &src );


 int Find( const T& src ) const;

 bool HasElement( const T& src ) const;


 void EnsureCapacity( int num );


 void EnsureCount( int num );


 void FastRemove( int elem );
 void Remove( int elem );
 bool FindAndRemove( const T& src );
 void RemoveMultiple( int elem, int num );
 void RemoveAll();


 void Purge();


 void PurgeAndDeleteElements();


 void Compact();


 void SetGrowSize( int size ) { m_Memory.SetGrowSize( size ); }

 int NumAllocated() const;

 void Sort( int ( *pfnCompare)(const T *, const T *) );





protected:

 CUtlVector( CUtlVector const& vec ) { ((void)0); }


 void GrowVector( int num = 1 );


 void ShiftElementsRight( int elem, int num = 1 );
 void ShiftElementsLeft( int elem, int num = 1 );

 CAllocator m_Memory;
 int m_Size;



 T *m_pElements;

 inline void ResetDbgInfo()
 {
  m_pElements = Base();
 }
};



template < class T >
class CUtlBlockVector : public CUtlVector< T, CUtlBlockMemory< T, int > >
{
public:
 CUtlBlockVector( int growSize = 0, int initSize = 0 )
  : CUtlVector< T, CUtlBlockMemory< T, int > >( growSize, initSize ) {}
};






template< class BASE_UTLVECTOR, class MUTEX_TYPE = CThreadFastMutex >
class CUtlVectorMT : public BASE_UTLVECTOR, public MUTEX_TYPE
{
 typedef BASE_UTLVECTOR BaseClass;
public:
 MUTEX_TYPE Mutex_t;


 CUtlVectorMT( int growSize = 0, int initSize = 0 ) : BaseClass( growSize, initSize ) {}
 CUtlVectorMT( typename BaseClass::ElemType_t* pMemory, int numElements ) : BaseClass( pMemory, numElements ) {}
};






template< class T, size_t MAX_SIZE >
class CUtlVectorFixed : public CUtlVector< T, CUtlMemoryFixed<T, MAX_SIZE > >
{
 typedef CUtlVector< T, CUtlMemoryFixed<T, MAX_SIZE > > BaseClass;
public:


 CUtlVectorFixed( int growSize = 0, int initSize = 0 ) : BaseClass( growSize, initSize ) {}
 CUtlVectorFixed( T* pMemory, int numElements ) : BaseClass( pMemory, numElements ) {}
};






template< class T, size_t MAX_SIZE >
class CUtlVectorFixedGrowable : public CUtlVector< T, CUtlMemoryFixedGrowable<T, MAX_SIZE > >
{
 typedef CUtlVector< T, CUtlMemoryFixedGrowable<T, MAX_SIZE > > BaseClass;

public:

 CUtlVectorFixedGrowable( int growSize = 0 ) : BaseClass( growSize, MAX_SIZE ) {}
};
template< class T >
class CCopyableUtlVector : public CUtlVector< T, CUtlMemory<T> >
{
 typedef CUtlVector< T, CUtlMemory<T> > BaseClass;
public:
 CCopyableUtlVector( int growSize = 0, int initSize = 0 ) : BaseClass( growSize, initSize ) {}
 CCopyableUtlVector( T* pMemory, int numElements ) : BaseClass( pMemory, numElements ) {}
 virtual ~CCopyableUtlVector() {}
 CCopyableUtlVector( CCopyableUtlVector const& vec ) { CopyArray( vec.Base(), vec.Count() ); }
};




template< typename T, class A >
inline CUtlVector<T, A>::CUtlVector( int growSize, int initSize ) :
 m_Memory(growSize, initSize), m_Size(0)
{
 ResetDbgInfo();
}

template< typename T, class A >
inline CUtlVector<T, A>::CUtlVector( T* pMemory, int allocationCount, int numElements ) :
 m_Memory(pMemory, allocationCount), m_Size(numElements)
{
 ResetDbgInfo();
}

template< typename T, class A >
inline CUtlVector<T, A>::~CUtlVector()
{
 Purge();
}

template< typename T, class A >
inline CUtlVector<T, A>& CUtlVector<T, A>::operator=( const CUtlVector<T, A> &other )
{
 int nCount = other.Count();
 SetSize( nCount );
 for ( int i = 0; i < nCount; i++ )
 {
  (*this)[ i ] = other[ i ];
 }
 return *this;
}





template< typename T, class A >
inline T& CUtlVector<T, A>::operator[]( int i )
{
 return m_Memory[ i ];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::operator[]( int i ) const
{
 return m_Memory[ i ];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Element( int i )
{
 return m_Memory[ i ];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Element( int i ) const
{
 return m_Memory[ i ];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Head()
{
 ((void)0);
 return m_Memory[ 0 ];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Head() const
{
 ((void)0);
 return m_Memory[ 0 ];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Tail()
{
 ((void)0);
 return m_Memory[ m_Size - 1 ];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Tail() const
{
 ((void)0);
 return m_Memory[ m_Size - 1 ];
}





template< typename T, class A >
inline int CUtlVector<T, A>::Size() const
{
 return m_Size;
}

template< typename T, class A >
inline int CUtlVector<T, A>::Count() const
{
 return m_Size;
}





template< typename T, class A >
inline bool CUtlVector<T, A>::IsValidIndex( int i ) const
{
 return (i >= 0) && (i < m_Size);
}





template< typename T, class A >
inline int CUtlVector<T, A>::InvalidIndex()
{
 return -1;
}





template< typename T, class A >
void CUtlVector<T, A>::GrowVector( int num )
{
 if (m_Size + num > m_Memory.NumAllocated())
 {
  ;
  m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );
 }

 m_Size += num;
 ResetDbgInfo();
}





template< typename T, class A >
void CUtlVector<T, A>::Sort( int ( *pfnCompare)(const T *, const T *) )
{
 typedef int ( *QSortCompareFunc_t)(const void *, const void *);
 if ( Count() <= 1 )
  return;

 if ( Base() )
 {
  qsort( Base(), Count(), sizeof(T), (QSortCompareFunc_t)(pfnCompare) );
 }
 else
 {
  ((void)0);





  for ( int i = m_Size - 1; i >= 0; --i )
  {
   for ( int j = 1; j <= i; ++j )
   {
    if ( pfnCompare( &Element( j - 1 ), &Element( j ) ) < 0 )
    {
     swap( Element( j - 1 ), Element( j ) );
    }
   }
  }
 }
}




template< typename T, class A >
void CUtlVector<T, A>::EnsureCapacity( int num )
{
 ;
 m_Memory.EnsureCapacity(num);
 ResetDbgInfo();
}





template< typename T, class A >
void CUtlVector<T, A>::EnsureCount( int num )
{
 if (Count() < num)
  AddMultipleToTail( num - Count() );
}





template< typename T, class A >
void CUtlVector<T, A>::ShiftElementsRight( int elem, int num )
{
 ((void)0);
 int numToMove = m_Size - elem - num;
 if ((numToMove > 0) && (num > 0))
  V_memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );
}

template< typename T, class A >
void CUtlVector<T, A>::ShiftElementsLeft( int elem, int num )
{
 ((void)0);
 int numToMove = m_Size - elem - num;
 if ((numToMove > 0) && (num > 0))
 {
  V_memmove( &Element(elem), &Element(elem+num), numToMove * sizeof(T) );




 }
}





template< typename T, class A >
inline int CUtlVector<T, A>::AddToHead()
{
 return InsertBefore(0);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddToTail()
{
 return InsertBefore( m_Size );
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertAfter( int elem )
{
 return InsertBefore( elem + 1 );
}

template< typename T, class A >
int CUtlVector<T, A>::InsertBefore( int elem )
{

 ((void)0);

 GrowVector();
 ShiftElementsRight(elem);
 Construct( &Element(elem) );
 return elem;
}





template< typename T, class A >
inline int CUtlVector<T, A>::AddToHead( const T& src )
{

 ((void)0);
 return InsertBefore( 0, src );
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddToTail( const T& src )
{

 ((void)0);
 return InsertBefore( m_Size, src );
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertAfter( int elem, const T& src )
{

 ((void)0);
 return InsertBefore( elem + 1, src );
}

template< typename T, class A >
int CUtlVector<T, A>::InsertBefore( int elem, const T& src )
{

 ((void)0);


 ((void)0);

 GrowVector();
 ShiftElementsRight(elem);
 CopyConstruct( &Element(elem), src );
 return elem;
}





template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToHead( int num )
{
 return InsertMultipleBefore( 0, num );
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToTail( int num, const T *pToCopy )
{

 ((void)0);

 return InsertMultipleBefore( m_Size, num, pToCopy );
}

template< typename T, class A >
int CUtlVector<T, A>::InsertMultipleAfter( int elem, int num )
{
 return InsertMultipleBefore( elem + 1, num );
}


template< typename T, class A >
void CUtlVector<T, A>::SetCount( int count )
{
 RemoveAll();
 AddMultipleToTail( count );
}

template< typename T, class A >
inline void CUtlVector<T, A>::SetSize( int size )
{
 SetCount( size );
}

template< typename T, class A >
void CUtlVector<T, A>::CopyArray( const T *pArray, int size )
{

 ((void)0);

 SetSize( size );
 for( int i=0; i < size; i++ )
 {
  (*this)[i] = pArray[i];
 }
}

template< typename T, class A >
void CUtlVector<T, A>::Swap( CUtlVector< T, A > &vec )
{
 m_Memory.Swap( vec.m_Memory );
 swap( m_Size, vec.m_Size );
 swap( m_pElements, vec.m_pElements );
}

template< typename T, class A >
int CUtlVector<T, A>::AddVectorToTail( CUtlVector const &src )
{
 ((void)0);

 int base = Count();


 AddMultipleToTail( src.Count() );


 for ( int i=0; i < src.Count(); i++ )
 {
  (*this)[base + i] = src[i];
 }

 return base;
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertMultipleBefore( int elem, int num, const T *pToInsert )
{
 if( num == 0 )
  return elem;


 ((void)0);

 GrowVector(num);
 ShiftElementsRight(elem, num);


 for (int i = 0; i < num; ++i)
  Construct( &Element(elem+i) );


 if ( pToInsert )
 {
  for ( int i=0; i < num; i++ )
  {
   Element( elem+i ) = pToInsert[i];
  }
 }

 return elem;
}





template< typename T, class A >
int CUtlVector<T, A>::Find( const T& src ) const
{
 for ( int i = 0; i < Count(); ++i )
 {
  if (Element(i) == src)
   return i;
 }
 return -1;
}

template< typename T, class A >
bool CUtlVector<T, A>::HasElement( const T& src ) const
{
 return ( Find(src) >= 0 );
}





template< typename T, class A >
void CUtlVector<T, A>::FastRemove( int elem )
{
 ((void)0);

 Destruct( &Element(elem) );
 if (m_Size > 0)
 {
  memcpy( &Element(elem), &Element(m_Size-1), sizeof(T) );
  --m_Size;
 }
}

template< typename T, class A >
void CUtlVector<T, A>::Remove( int elem )
{
 Destruct( &Element(elem) );
 ShiftElementsLeft(elem);
 --m_Size;
}

template< typename T, class A >
bool CUtlVector<T, A>::FindAndRemove( const T& src )
{
 int elem = Find( src );
 if ( elem != -1 )
 {
  Remove( elem );
  return true;
 }
 return false;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultiple( int elem, int num )
{
 ((void)0);
 ((void)0);

 for (int i = elem + num; --i >= elem; )
  Destruct(&Element(i));

 ShiftElementsLeft(elem, num);
 m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveAll()
{
 for (int i = m_Size; --i >= 0; )
 {
  Destruct(&Element(i));
 }

 m_Size = 0;
}






template< typename T, class A >
inline void CUtlVector<T, A>::Purge()
{
 RemoveAll();
 m_Memory.Purge();
 ResetDbgInfo();
}


template< typename T, class A >
inline void CUtlVector<T, A>::PurgeAndDeleteElements()
{
 for( int i=0; i < m_Size; i++ )
 {
  delete Element(i);
 }
 Purge();
}

template< typename T, class A >
inline void CUtlVector<T, A>::Compact()
{
 m_Memory.Purge(m_Size);
}

template< typename T, class A >
inline int CUtlVector<T, A>::NumAllocated() const
{
 return m_Memory.NumAllocated();
}
class CUtlBinaryBlock
{
public:
 CUtlBinaryBlock( int growSize = 0, int initSize = 0 );


 CUtlBinaryBlock( void* pMemory, int nSizeInBytes, int nInitialLength );
 CUtlBinaryBlock( const void* pMemory, int nSizeInBytes );
 CUtlBinaryBlock( const CUtlBinaryBlock& src );

 void Get( void *pValue, int nMaxLen ) const;
 void Set( const void *pValue, int nLen );
 const void *Get( ) const;
 void *Get( );

 unsigned char& operator[]( int i );
 const unsigned char& operator[]( int i ) const;

 int Length() const;
 void SetLength( int nLength );
 bool IsEmpty() const;

 bool IsReadOnly() const;

 CUtlBinaryBlock &operator=( const CUtlBinaryBlock &src );


 bool operator==( const CUtlBinaryBlock &src ) const;

private:
 CUtlMemory<unsigned char> m_Memory;
 int m_nActualLength;
};





inline const void *CUtlBinaryBlock::Get( ) const
{
 return m_Memory.Base();
}

inline void *CUtlBinaryBlock::Get( )
{
 return m_Memory.Base();
}

inline int CUtlBinaryBlock::Length() const
{
 return m_nActualLength;
}

inline unsigned char& CUtlBinaryBlock::operator[]( int i )
{
 return m_Memory[i];
}

inline const unsigned char& CUtlBinaryBlock::operator[]( int i ) const
{
 return m_Memory[i];
}

inline bool CUtlBinaryBlock::IsReadOnly() const
{
 return m_Memory.IsReadOnly();
}

inline bool CUtlBinaryBlock::IsEmpty() const
{
 return Length() == 0;
}






class CUtlString
{
public:
 CUtlString();
 CUtlString( const char *pString );
 CUtlString( const CUtlString& string );


 CUtlString( void* pMemory, int nSizeInBytes, int nInitialLength );
 CUtlString( const void* pMemory, int nSizeInBytes );

 const char *Get( ) const;
 void Set( const char *pValue );


 operator const char*() const;


 const char *String() const { return Get(); }


 int Length() const;
 bool IsEmpty() const;


 void SetLength( int nLen );
 char *Get();


 void StripTrailingSlash();

 CUtlString &operator=( const CUtlString &src );
 CUtlString &operator=( const char *src );


 bool operator==( const CUtlString &src ) const;
 bool operator==( const char *src ) const;
 bool operator!=( const CUtlString &src ) const { return !operator==( src ); }
 bool operator!=( const char *src ) const { return !operator==( src ); }

 CUtlString &operator+=( const CUtlString &rhs );
 CUtlString &operator+=( const char *rhs );
 CUtlString &operator+=( char c );
 CUtlString &operator+=( int rhs );
 CUtlString &operator+=( double rhs );

 int Format( const char *pFormat, ... );

private:
 CUtlBinaryBlock m_Storage;
};





inline bool CUtlString::IsEmpty() const
{
 return Length() == 0;
}

class IBaseInterface
{
public:
 virtual ~IBaseInterface() {}
};
typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);
typedef void* (*InstantiateInterfaceFn)();


class InterfaceReg
{
public:
 InterfaceReg(InstantiateInterfaceFn fn, const char *pName);

public:
 InstantiateInterfaceFn m_CreateFn;
 const char *m_pName;

 InterfaceReg *m_pNext;
 static InterfaceReg *s_pInterfaceRegs;
};
class CSysModule;


enum
{
 IFACE_OK = 0,
 IFACE_FAILED
};






extern "C" __attribute__ ((visibility("default"))) void* CreateInterface(const char *pName, int *pReturnCode);
extern CreateInterfaceFn Sys_GetFactory( CSysModule *pModule );
extern CreateInterfaceFn Sys_GetFactory( const char *pModuleName );
extern CreateInterfaceFn Sys_GetFactoryThis( void );






extern CSysModule *Sys_LoadModule( const char *pModuleName );
extern void Sys_UnloadModule( CSysModule *pModule );




bool Sys_LoadInterface(
 const char *pModuleName,
 const char *pInterfaceVersionName,
 CSysModule **pOutModule,
 void **pOutInterface );

bool Sys_IsDebuggerPresent();
class CDllDemandLoader
{
public:
      CDllDemandLoader( char const *pchModuleName );
 virtual ~CDllDemandLoader();
 CreateInterfaceFn GetFactory();
 void Unload();

private:

 char const *m_pchModuleName;
 CSysModule *m_hModule;
 bool m_bLoadAttempted;
};
enum InitReturnVal_t
{
 INIT_FAILED = 0,
 INIT_OK,

 INIT_LAST_VAL,
};


class IAppSystem
{
public:

 virtual bool Connect( CreateInterfaceFn factory ) = 0;
 virtual void Disconnect() = 0;



 virtual void *QueryInterface( const char *pInterfaceName ) = 0;


 virtual InitReturnVal_t Init() = 0;
 virtual void Shutdown() = 0;
};





template< class IInterface >
class CBaseAppSystem : public IInterface
{
public:

 virtual bool Connect( CreateInterfaceFn factory ) { return true; }
 virtual void Disconnect() {}



 virtual void *QueryInterface( const char *pInterfaceName ) { return 
                                                                    __null
                                                                        ; }


 virtual InitReturnVal_t Init() { return INIT_OK; }
 virtual void Shutdown() {}
};





template< class IInterface >
class CTier0AppSystem : public CBaseAppSystem< IInterface >
{
public:
 CTier0AppSystem( bool bIsPrimaryAppSystem = true )
 {
  m_bIsPrimaryAppSystem = bIsPrimaryAppSystem;
 }

protected:







 bool IsPrimaryAppSystem() { return m_bIsPrimaryAppSystem; }

private:
 bool m_bIsPrimaryAppSystem;
};






class IAppSystemV0
{
public:

 virtual bool Connect( CreateInterfaceFn factory ) = 0;
 virtual void Disconnect() = 0;



 virtual void *QueryInterface( const char *pInterfaceName ) = 0;


 virtual InitReturnVal_t Init() = 0;
 virtual void Shutdown() = 0;
};

class ConCommandBase;
class ConCommand;
class ConVar;
class Color;





typedef int CVarDLLIdentifier_t;





class IConsoleDisplayFunc
{
public:
 virtual void ColorPrint( const Color& clr, const char *pMessage ) = 0;
 virtual void Print( const char *pMessage ) = 0;
 virtual void DPrint( const char *pMessage ) = 0;

 virtual void GetConsoleText( char *pchText, size_t bufSize ) const = 0;
};






class ICvarQuery : public IAppSystem
{
public:

 virtual bool AreConVarsLinkable( const ConVar *child, const ConVar *parent ) = 0;
};




class ICvar : public IAppSystem
{
public:

 virtual CVarDLLIdentifier_t AllocateDLLIdentifier() = 0;


 virtual void RegisterConCommand( ConCommandBase *pCommandBase ) = 0;
 virtual void UnregisterConCommand( ConCommandBase *pCommandBase ) = 0;
 virtual void UnregisterConCommands( CVarDLLIdentifier_t id ) = 0;



 virtual const char* GetCommandLineValue( const char *pVariableName ) = 0;


 virtual ConCommandBase *FindCommandBase( const char *name ) = 0;
 virtual const ConCommandBase *FindCommandBase( const char *name ) const = 0;
 virtual ConVar *FindVar ( const char *var_name ) = 0;
 virtual const ConVar *FindVar ( const char *var_name ) const = 0;
 virtual ConCommand *FindCommand( const char *name ) = 0;
 virtual const ConCommand *FindCommand( const char *name ) const = 0;




 virtual void InstallGlobalChangeCallback( FnChangeCallback_t callback ) = 0;
 virtual void RemoveGlobalChangeCallback( FnChangeCallback_t callback ) = 0;
 virtual void CallGlobalChangeCallbacks( ConVar *var, const char *pOldString, float flOldValue ) = 0;


 virtual void InstallConsoleDisplayFunc( IConsoleDisplayFunc* pDisplayFunc ) = 0;
 virtual void RemoveConsoleDisplayFunc( IConsoleDisplayFunc* pDisplayFunc ) = 0;
 virtual void ConsoleColorPrintf( const Color& clr, const char *pFormat, ... ) const = 0;
 virtual void ConsolePrintf( const char *pFormat, ... ) const = 0;
 virtual void ConsoleDPrintf( const char *pFormat, ... ) const = 0;


 virtual void RevertFlaggedConVars( int nFlag ) = 0;




 virtual void InstallCVarQuery( ICvarQuery *pQuery ) = 0;





 virtual void SetMaxSplitScreenSlots( int nSlots ) = 0;
 virtual int GetMaxSplitScreenSlots() const = 0;

 virtual void AddSplitScreenConVars() = 0;
 virtual void RemoveSplitScreenConVars( CVarDLLIdentifier_t id ) = 0;

 virtual int GetConsoleDisplayFuncCount() const = 0;
 virtual void GetConsoleText( int nDisplayFuncIndex, char *pchText, size_t bufSize ) const = 0;


 virtual bool IsMaterialThreadSetAllowed( ) const = 0;
 virtual void QueueMaterialThreadSetValue( ConVar *pConVar, const char *pValue ) = 0;
 virtual void QueueMaterialThreadSetValue( ConVar *pConVar, int nValue ) = 0;
 virtual void QueueMaterialThreadSetValue( ConVar *pConVar, float flValue ) = 0;
 virtual bool HasQueuedMaterialThreadConVarSets() const = 0;
 virtual int ProcessQueuedMaterialThreadConVarSets() = 0;

protected: class ICVarIteratorInternal;
public:
 class Iterator
 {
 public:
  inline Iterator(ICvar *icvar);
  inline ~Iterator(void);
  inline void SetFirst( void );
  inline void Next( void );
  inline bool IsValid( void );
  inline ConCommandBase *Get( void );
 private:
  ICVarIteratorInternal *m_pIter;
 };

protected:

 class ICVarIteratorInternal
 {
 public:
  virtual ~ICVarIteratorInternal() {}
  virtual void SetFirst( void ) = 0;
  virtual void Next( void ) = 0;
  virtual bool IsValid( void ) = 0;
  virtual ConCommandBase *Get( void ) = 0;
 };

 virtual ICVarIteratorInternal *FactoryInternalIterator( void ) = 0;
 friend class Iterator;
};



inline ICvar::Iterator::Iterator(ICvar *icvar)
{
 m_pIter = icvar->FactoryInternalIterator();
}

inline ICvar::Iterator::~Iterator( void )
{
 delete m_pIter;
}

inline void ICvar::Iterator::SetFirst( void )
{
 m_pIter->SetFirst();
}

inline void ICvar::Iterator::Next( void )
{
 m_pIter->Next();
}

inline bool ICvar::Iterator::IsValid( void )
{
 return m_pIter->IsValid();
}

inline ConCommandBase * ICvar::Iterator::Get( void )
{
 return m_pIter->Get();
}
extern "C" __attribute__ ((visibility("default"))) ICvar *cvar;
extern "C" __attribute__ ((visibility("default"))) ICvar *g_pCVar;
class ConVar;
class CCommand;
class ConCommand;
class ConCommandBase;
struct characterset_t;







class IConCommandBaseAccessor
{
public:


 virtual bool RegisterConCommandBase( ConCommandBase *pVar ) = 0;
};
typedef void ( *FnCommandCallbackV1_t )( void );
typedef void ( *FnCommandCallback_t )( const CCommand &command );







typedef int ( *FnCommandCompletionCallback )( const char *partial, char commands[ 64 ][ 64 ] );





class ICommandCallback
{
public:
 virtual void CommandCallback( const CCommand &command ) = 0;
};

class ICommandCompletionCallback
{
public:
 virtual int CommandCompletionCallback( const char *pPartial, CUtlVector< CUtlString > &commands ) = 0;
};




class ConCommandBase
{
 friend class CCvar;
 friend class ConVar;
 friend class ConCommand;
 friend void ConVar_Register( int nCVarFlag, IConCommandBaseAccessor *pAccessor );
 friend void ConVar_PublishToVXConsole();


 friend class CDefaultCvar;

public:
        ConCommandBase( void );
        ConCommandBase( const char *pName, const char *pHelpString = 0,
         int flags = 0 );

 virtual ~ConCommandBase( void );

 virtual bool IsCommand( void ) const;


 virtual bool IsFlagSet( int flag ) const;

 virtual void AddFlags( int flags );

 virtual void RemoveFlags( int flags );

 virtual int GetFlags() const;


 virtual const char *GetName( void ) const;


 virtual const char *GetHelpText( void ) const;


 const ConCommandBase *GetNext( void ) const;
 ConCommandBase *GetNext( void );

 inline void SetNext(ConCommandBase *pBase)
 {
  m_pNext = pBase;
 }

 virtual bool IsRegistered( void ) const;


 virtual CVarDLLIdentifier_t GetDLLIdentifier() const;

protected:
 virtual void Create( const char *pName, const char *pHelpString = 0,
         int flags = 0 );


 virtual void Init();
 void Shutdown();


 char *CopyString( const char *from );

private:




 ConCommandBase *m_pNext;


 bool m_bRegistered;


 const char *m_pszName;
 const char *m_pszHelpString;


 int m_nFlags;

protected:



 static ConCommandBase *s_pConCommandBases;


 static IConCommandBaseAccessor *s_pAccessor;
};





class CCommand
{
public:
 CCommand();
 CCommand( int nArgC, const char **ppArgV );
 bool Tokenize( const char *pCommand, characterset_t *pBreakSet = 
                                                                 __null 
                                                                      );
 void Reset();

 int ArgC() const;
 const char **ArgV() const;
 const char *ArgS() const;
 const char *GetCommandString() const;
 const char *operator[]( int nIndex ) const;
 const char *Arg( int nIndex ) const;


 const char* FindArg( const char *pName ) const;
 int FindArgInt( const char *pName, int nDefaultVal ) const;

 static int MaxCommandLength();
 static characterset_t* DefaultBreakSet();

private:
 enum
 {
  COMMAND_MAX_ARGC = 64,
  COMMAND_MAX_LENGTH = 512,
 };

 int m_nArgc;
 int m_nArgv0Size;
 char m_pArgSBuffer[ COMMAND_MAX_LENGTH ];
 char m_pArgvBuffer[ COMMAND_MAX_LENGTH ];
 const char* m_ppArgv[ COMMAND_MAX_ARGC ];
};

inline int CCommand::MaxCommandLength()
{
 return COMMAND_MAX_LENGTH - 1;
}

inline int CCommand::ArgC() const
{
 return m_nArgc;
}

inline const char **CCommand::ArgV() const
{
 return m_nArgc ? (const char**)m_ppArgv : 
                                          __null
                                              ;
}

inline const char *CCommand::ArgS() const
{
 return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : "";
}

inline const char *CCommand::GetCommandString() const
{
 return m_nArgc ? m_pArgSBuffer : "";
}

inline const char *CCommand::Arg( int nIndex ) const
{



 if ( nIndex < 0 || nIndex >= m_nArgc )
  return "";
 return m_ppArgv[nIndex];
}

inline const char *CCommand::operator[]( int nIndex ) const
{
 return Arg( nIndex );
}





class ConCommand : public ConCommandBase
{
friend class CCvar;

public:
 typedef ConCommandBase BaseClass;

 ConCommand( const char *pName, FnCommandCallbackV1_t callback,
  const char *pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0 );
 ConCommand( const char *pName, FnCommandCallback_t callback,
  const char *pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0 );
 ConCommand( const char *pName, ICommandCallback *pCallback,
  const char *pHelpString = 0, int flags = 0, ICommandCompletionCallback *pCommandCompletionCallback = 0 );

 virtual ~ConCommand( void );

 virtual bool IsCommand( void ) const;

 virtual int AutoCompleteSuggest( const char *partial, CUtlVector< CUtlString > &commands );

 virtual bool CanAutoComplete( void );


 virtual void Dispatch( const CCommand &command );

private:
 union
 {
  FnCommandCallbackV1_t m_fnCommandCallbackV1;
  FnCommandCallback_t m_fnCommandCallback;
  ICommandCallback *m_pCommandCallback;
 };

 union
 {
  FnCommandCompletionCallback m_fnCompletionCallback;
  ICommandCompletionCallback *m_pCommandCompletionCallback;
 };

 bool m_bHasCompletionCallback : 1;
 bool m_bUsingNewCommandCallback : 1;
 bool m_bUsingCommandCallbackInterface : 1;
};





class ConVar : public ConCommandBase, public IConVar
{
friend class CCvar;
friend class ConVarRef;


public:
 typedef ConCommandBase BaseClass;

        ConVar( const char *pName, const char *pDefaultValue, int flags = 0);

        ConVar( const char *pName, const char *pDefaultValue, int flags,
         const char *pHelpString );
        ConVar( const char *pName, const char *pDefaultValue, int flags,
         const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax );
        ConVar( const char *pName, const char *pDefaultValue, int flags,
         const char *pHelpString, FnChangeCallback_t callback );
        ConVar( const char *pName, const char *pDefaultValue, int flags,
         const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax,
         FnChangeCallback_t callback );

 virtual ~ConVar( void );

 virtual bool IsCommand( void ) const;
 virtual bool IsFlagSet( int flag ) const;
 virtual void AddFlags( int flags );
 virtual int GetFlags( void ) const;
 virtual const char *GetName( void ) const;
 virtual const char* GetHelpText( void ) const;
 virtual bool IsRegistered( void ) const;


 void InstallChangeCallback( FnChangeCallback_t callback );


 inline float GetFloat( void ) const;
 inline int GetInt( void ) const;
 inline bool GetBool() const { return !!GetInt(); }
 inline char const *GetString( void ) const;
 inline Color GetColor ( void ) const;


 virtual void Init();

 virtual const char *GetBaseName( void ) const;
 virtual int GetSplitScreenPlayerSlot ( void ) const;





 virtual void SetValue( const char *value );
 virtual void SetValue( float value );
 virtual void SetValue( int value );
 virtual void SetValue( Color value );


 void Revert( void );


 bool GetMin( float& minVal ) const;
 bool GetMax( float& maxVal ) const;
 const char *GetDefault( void ) const;

private:

 virtual void InternalSetValue(const char *value);

 virtual void InternalSetFloatValue( float fNewValue );
 virtual void InternalSetIntValue( int nValue );
 virtual void InternalSetColorValue( Color cValue );

 virtual bool ClampValue( float& value );
 virtual void ChangeStringValue( const char *tempVal, float flOldValue );

 virtual void Create( const char *pName, const char *pDefaultValue, int flags = 0,
         const char *pHelpString = 0, bool bMin = false, float fMin = 0.0,
         bool bMax = false, float fMax = false, FnChangeCallback_t callback = 0 );

private:




 ConVar *m_pParent;


 const char *m_pszDefaultValue;



 char *m_pszString;
 int m_StringLength;


 float m_fValue;
 int m_nValue;


 bool m_bHasMin;
 float m_fMinVal;
 bool m_bHasMax;
 float m_fMaxVal;


 FnChangeCallback_t m_fnChangeCallback;
};






inline float ConVar::GetFloat( void ) const
{
 return m_pParent->m_fValue;
}





inline int ConVar::GetInt( void ) const
{
 return m_pParent->m_nValue;
}






inline const char *ConVar::GetString( void ) const
{
 if ( m_nFlags & (1<<12) )
  return "FCVAR_NEVER_AS_STRING";

 return ( m_pParent->m_pszString ) ? m_pParent->m_pszString : "";
}





inline Color ConVar::GetColor( void ) const
{
 Color color = Color();
 color.SetRawColor(m_pParent->m_nValue);

 return color;
}





class ConVarRef
{
public:
 ConVarRef( const char *pName );
 ConVarRef( const char *pName, bool bIgnoreMissing );
 ConVarRef( IConVar *pConVar );

 void Init( const char *pName, bool bIgnoreMissing );
 bool IsValid() const;
 bool IsFlagSet( int nFlags ) const;
 IConVar *GetLinkedConVar();


 float GetFloat( void ) const;
 int GetInt( void ) const;
 bool GetBool() const { return !!GetInt(); }
 const char *GetString( void ) const;
 Color GetColor( void ) const;

 void SetValue( const char *pValue );
 void SetValue( float flValue );
 void SetValue( int nValue );
 void SetValue( bool bValue );
 void SetValue( Color cValue );

 const char *GetName() const;

 const char *GetDefault() const;

private:

 IConVar *m_pConVar;
 ConVar *m_pConVarState;
};





inline bool ConVarRef::IsFlagSet( int nFlags ) const
{
 return ( m_pConVar->IsFlagSet( nFlags ) != 0 );
}

inline IConVar *ConVarRef::GetLinkedConVar()
{
 return m_pConVar;
}

inline const char *ConVarRef::GetName() const
{
 return m_pConVar->GetName();
}





inline float ConVarRef::GetFloat( void ) const
{
 return m_pConVarState->m_fValue;
}




inline int ConVarRef::GetInt( void ) const
{
 return m_pConVarState->m_nValue;
}




inline const char *ConVarRef::GetString( void ) const
{
 ((void)0);
 return m_pConVarState->m_pszString;
}




inline Color ConVarRef::GetColor( void ) const
{
 Color color = Color();
 color.SetRawColor(m_pConVarState->m_nValue);

 return color;
}

inline void ConVarRef::SetValue( const char *pValue )
{
 m_pConVar->SetValue( pValue );
}

inline void ConVarRef::SetValue( float flValue )
{
 m_pConVar->SetValue( flValue );
}

inline void ConVarRef::SetValue( int nValue )
{
 m_pConVar->SetValue( nValue );
}

inline void ConVarRef::SetValue( bool bValue )
{
 m_pConVar->SetValue( bValue ? 1 : 0 );
}

inline void ConVarRef::SetValue( Color cValue )
{
 m_pConVar->SetValue( cValue );
}

inline const char *ConVarRef::GetDefault() const
{
 return m_pConVarState->m_pszDefaultValue;
}





void ConVar_Register( int nCVarFlag = 0, IConCommandBaseAccessor *pAccessor = 
                                                                             __null 
                                                                                  );
void ConVar_Unregister( );





void ConVar_PrintFlags( const ConCommandBase *var );
void ConVar_PrintDescription( const ConCommandBase *pVar );
template< class T >
class CConCommandMemberAccessor : public ConCommand, public ICommandCallback, public ICommandCompletionCallback
{
 typedef ConCommand BaseClass;
 typedef void ( T::*FnMemberCommandCallback_t )( const CCommand &command );
 typedef int ( T::*FnMemberCommandCompletionCallback_t )( const char *pPartial, CUtlVector< CUtlString > &commands );

public:
 CConCommandMemberAccessor( T* pOwner, const char *pName, FnMemberCommandCallback_t callback, const char *pHelpString = 0,
  int flags = 0, FnMemberCommandCompletionCallback_t completionFunc = 0 ) :
  BaseClass( pName, this, pHelpString, flags, ( completionFunc != 0 ) ? this : 
                                                                              __null 
                                                                                   )
 {
  m_pOwner = pOwner;
  m_Func = callback;
  m_CompletionFunc = completionFunc;
 }

 ~CConCommandMemberAccessor()
 {
  Shutdown();
 }

 void SetOwner( T* pOwner )
 {
  m_pOwner = pOwner;
 }

 virtual void CommandCallback( const CCommand &command )
 {
  ((void)0);
  (m_pOwner->*m_Func)( command );
 }

 virtual int CommandCompletionCallback( const char *pPartial, CUtlVector< CUtlString > &commands )
 {
  ((void)0);
  return (m_pOwner->*m_CompletionFunc)( pPartial, commands );
 }

private:
 T* m_pOwner;
 FnMemberCommandCallback_t m_Func;
 FnMemberCommandCompletionCallback_t m_CompletionFunc;
};
class CBaseTrace
{
public:


 bool IsDispSurface( void ) { return ( ( dispFlags & (1<<0) ) != 0 ); }
 bool IsDispSurfaceWalkable( void ) { return ( ( dispFlags & (1<<1) ) != 0 ); }
 bool IsDispSurfaceBuildable( void ) { return ( ( dispFlags & (1<<2) ) != 0 ); }
 bool IsDispSurfaceProp1( void ) { return ( ( dispFlags & (1<<3) ) != 0 ); }
 bool IsDispSurfaceProp2( void ) { return ( ( dispFlags & (1<<4) ) != 0 ); }

public:


 Vector startpos;
 Vector endpos;
 cplane_t plane;

 float fraction;

 int contents;
 unsigned short dispFlags;

 bool allsolid;
 bool startsolid;

 CBaseTrace() {}

private:

 CBaseTrace(const CBaseTrace& vOther);
};
enum MoveType_t
{
 MOVETYPE_NONE = 0,
 MOVETYPE_ISOMETRIC,
 MOVETYPE_WALK,
 MOVETYPE_STEP,
 MOVETYPE_FLY,
 MOVETYPE_FLYGRAVITY,
 MOVETYPE_VPHYSICS,
 MOVETYPE_PUSH,
 MOVETYPE_NOCLIP,
 MOVETYPE_LADDER,
 MOVETYPE_OBSERVER,
 MOVETYPE_CUSTOM,


 MOVETYPE_LAST = MOVETYPE_CUSTOM,

 MOVETYPE_MAX_BITS = 4
};


enum MoveCollide_t
{
 MOVECOLLIDE_DEFAULT = 0,


 MOVECOLLIDE_FLY_BOUNCE,
 MOVECOLLIDE_FLY_CUSTOM,
 MOVECOLLIDE_FLY_SLIDE,

 MOVECOLLIDE_COUNT,


 MOVECOLLIDE_MAX_BITS = 3
};
enum SolidType_t
{
 SOLID_NONE = 0,
 SOLID_BSP = 1,
 SOLID_BBOX = 2,
 SOLID_OBB = 3,
 SOLID_OBB_YAW = 4,
 SOLID_CUSTOM = 5,
 SOLID_VPHYSICS = 6,
 SOLID_LAST,
};

enum SolidFlags_t
{
 FSOLID_CUSTOMRAYTEST = 0x0001,
 FSOLID_CUSTOMBOXTEST = 0x0002,
 FSOLID_NOT_SOLID = 0x0004,
 FSOLID_TRIGGER = 0x0008,

 FSOLID_NOT_STANDABLE = 0x0010,
 FSOLID_VOLUME_CONTENTS = 0x0020,
 FSOLID_FORCE_WORLD_ALIGNED = 0x0040,
 FSOLID_USE_TRIGGER_BOUNDS = 0x0080,
 FSOLID_ROOT_PARENT_ALIGNED = 0x0100,
 FSOLID_TRIGGER_TOUCH_DEBRIS = 0x0200,

 FSOLID_MAX_BITS = 10
};




inline bool IsSolid( SolidType_t solidType, int nSolidFlags )
{
 return (solidType != SOLID_NONE) && ((nSolidFlags & FSOLID_NOT_SOLID) == 0);
}
enum
{
 EF_BONEMERGE = 0x001,
 EF_BRIGHTLIGHT = 0x002,
 EF_DIMLIGHT = 0x004,
 EF_NOINTERP = 0x008,
 EF_NOSHADOW = 0x010,
 EF_NODRAW = 0x020,
 EF_NORECEIVESHADOW = 0x040,
 EF_BONEMERGE_FASTCULL = 0x080,




 EF_ITEM_BLINK = 0x100,
 EF_PARENT_ANIMATES = 0x200,
 EF_MAX_BITS = 10
};
enum RenderMode_t
{
 kRenderNormal,
 kRenderTransColor,
 kRenderTransTexture,
 kRenderGlow,
 kRenderTransAlpha,
 kRenderTransAdd,
 kRenderEnvironmental,
 kRenderTransAddFrameBlend,
 kRenderTransAlphaAdd,
 kRenderWorldGlow,
 kRenderNone,
};

enum RenderFx_t
{
 kRenderFxNone = 0,
 kRenderFxPulseSlow,
 kRenderFxPulseFast,
 kRenderFxPulseSlowWide,
 kRenderFxPulseFastWide,
 kRenderFxFadeSlow,
 kRenderFxFadeFast,
 kRenderFxSolidSlow,
 kRenderFxSolidFast,
 kRenderFxStrobeSlow,
 kRenderFxStrobeFast,
 kRenderFxStrobeFaster,
 kRenderFxFlickerSlow,
 kRenderFxFlickerFast,
 kRenderFxNoDissipation,
 kRenderFxDistort,
 kRenderFxHologram,
 kRenderFxExplode,
 kRenderFxGlowShell,
 kRenderFxClampMinScale,
 kRenderFxEnvRain,
 kRenderFxEnvSnow,
 kRenderFxSpotlight,
 kRenderFxRagdoll,
 kRenderFxPulseFastWider,
 kRenderFxMax
};

enum Collision_Group_t
{
 COLLISION_GROUP_NONE = 0,
 COLLISION_GROUP_DEBRIS,
 COLLISION_GROUP_DEBRIS_TRIGGER,
 COLLISION_GROUP_INTERACTIVE_DEBRIS,
 COLLISION_GROUP_INTERACTIVE,
 COLLISION_GROUP_PLAYER,
 COLLISION_GROUP_BREAKABLE_GLASS,
 COLLISION_GROUP_VEHICLE,
 COLLISION_GROUP_PLAYER_MOVEMENT,

 COLLISION_GROUP_NPC,
 COLLISION_GROUP_IN_VEHICLE,
 COLLISION_GROUP_WEAPON,
 COLLISION_GROUP_VEHICLE_CLIP,
 COLLISION_GROUP_PROJECTILE,
 COLLISION_GROUP_DOOR_BLOCKER,
 COLLISION_GROUP_PASSABLE_DOOR,
 COLLISION_GROUP_DISSOLVING,
 COLLISION_GROUP_PUSHAWAY,

 COLLISION_GROUP_NPC_ACTOR,
 COLLISION_GROUP_NPC_SCRIPTED,

 LAST_SHARED_COLLISION_GROUP
};

class CThreadMutex;
typedef CThreadMutex CSourceMutex;



class IHandleEntity;






class CBaseHandle
{
friend class CBaseEntityList;

public:

 CBaseHandle();
 CBaseHandle( const CBaseHandle &other );
 CBaseHandle( unsigned long value );
 CBaseHandle( int iEntry, int iSerialNumber );

 void Init( int iEntry, int iSerialNumber );
 void Term();



 bool IsValid() const;

 int GetEntryIndex() const;
 int GetSerialNumber() const;

 int ToInt() const;
 bool operator !=( const CBaseHandle &other ) const;
 bool operator ==( const CBaseHandle &other ) const;
 bool operator ==( const IHandleEntity* pEnt ) const;
 bool operator !=( const IHandleEntity* pEnt ) const;
 bool operator <( const CBaseHandle &other ) const;
 bool operator <( const IHandleEntity* pEnt ) const;


 const CBaseHandle& operator=( const IHandleEntity *pEntity );
 const CBaseHandle& Set( const IHandleEntity *pEntity );



 IHandleEntity* Get() const;


protected:


 unsigned long m_Index;
};


class CBaseHandle;



class IHandleEntity
{
public:
 virtual ~IHandleEntity() {}
 virtual void SetRefEHandle( const CBaseHandle &handle ) = 0;
 virtual const CBaseHandle& GetRefEHandle() const = 0;
};


inline CBaseHandle::CBaseHandle()
{
 m_Index = 0xFFFFFFFF;
}

inline CBaseHandle::CBaseHandle( const CBaseHandle &other )
{
 m_Index = other.m_Index;
}

inline CBaseHandle::CBaseHandle( unsigned long value )
{
 m_Index = value;
}

inline CBaseHandle::CBaseHandle( int iEntry, int iSerialNumber )
{
 Init( iEntry, iSerialNumber );
}

inline void CBaseHandle::Init( int iEntry, int iSerialNumber )
{
 ((void)0);
 ((void)0);

 m_Index = iEntry | (iSerialNumber << (11 + 1));
}

inline void CBaseHandle::Term()
{
 m_Index = 0xFFFFFFFF;
}

inline bool CBaseHandle::IsValid() const
{
 return m_Index != 0xFFFFFFFF;
}

inline int CBaseHandle::GetEntryIndex() const
{
 return m_Index & ((1 << (11 + 1)) - 1);
}

inline int CBaseHandle::GetSerialNumber() const
{
 return m_Index >> (11 + 1);
}

inline int CBaseHandle::ToInt() const
{
 return (int)m_Index;
}

inline bool CBaseHandle::operator !=( const CBaseHandle &other ) const
{
 return m_Index != other.m_Index;
}

inline bool CBaseHandle::operator ==( const CBaseHandle &other ) const
{
 return m_Index == other.m_Index;
}

inline bool CBaseHandle::operator ==( const IHandleEntity* pEnt ) const
{
 return Get() == pEnt;
}

inline bool CBaseHandle::operator !=( const IHandleEntity* pEnt ) const
{
 return Get() != pEnt;
}

inline bool CBaseHandle::operator <( const CBaseHandle &other ) const
{
 return m_Index < other.m_Index;
}

inline bool CBaseHandle::operator <( const IHandleEntity *pEntity ) const
{
 unsigned long otherIndex = (pEntity) ? pEntity->GetRefEHandle().m_Index : 0xFFFFFFFF;
 return m_Index < otherIndex;
}

inline const CBaseHandle& CBaseHandle::operator=( const IHandleEntity *pEntity )
{
 return Set( pEntity );
}

inline const CBaseHandle& CBaseHandle::Set( const IHandleEntity *pEntity )
{
 if ( pEntity )
 {
  *this = pEntity->GetRefEHandle();
 }
 else
 {
  m_Index = 0xFFFFFFFF;
 }

 return *this;
}

struct edict_t;
struct model_t;







class CPhysCollide;

struct vcollide_t
{
 unsigned short solidCount : 15;
 unsigned short isPacked : 1;
 unsigned short descSize;

 CPhysCollide **solids;
 char *pKeyValues;
};

struct cmodel_t
{
 Vector mins, maxs;
 Vector origin;
 int headnode;

 vcollide_t vcollisionData;
};

struct csurface_t
{
 const char *name;
 short surfaceProps;
 unsigned short flags;
};




struct Ray_t
{
 VectorAligned m_Start;
 VectorAligned m_Delta;
 VectorAligned m_StartOffset;
 VectorAligned m_Extents;
 const matrix3x4_t *m_pWorldAxisTransform;
 bool m_IsRay;
 bool m_IsSwept;

 Ray_t() : m_pWorldAxisTransform( 
                                 __null 
                                      ) {}

 void Init( Vector const& start, Vector const& end )
 {
  ((void)0);
  VectorSubtract( end, start, m_Delta );

  m_IsSwept = (m_Delta.LengthSqr() != 0);

  VectorClear( m_Extents );
  m_pWorldAxisTransform = 
                         __null
                             ;
  m_IsRay = true;


  VectorClear( m_StartOffset );
  VectorCopy( start, m_Start );
 }

 void Init( Vector const& start, Vector const& end, Vector const& mins, Vector const& maxs )
 {
  ((void)0);
  VectorSubtract( end, start, m_Delta );

  m_pWorldAxisTransform = 
                         __null
                             ;
  m_IsSwept = (m_Delta.LengthSqr() != 0);

  VectorSubtract( maxs, mins, m_Extents );
  m_Extents *= 0.5f;
  m_IsRay = (m_Extents.LengthSqr() < 1e-6);


  VectorAdd( mins, maxs, m_StartOffset );
  m_StartOffset *= 0.5f;
  VectorAdd( start, m_StartOffset, m_Start );
  m_StartOffset *= -1.0f;
 }


 Vector InvDelta() const
 {
  Vector vecInvDelta;
  for ( int iAxis = 0; iAxis < 3; ++iAxis )
  {
   if ( m_Delta[iAxis] != 0.0f )
   {
    vecInvDelta[iAxis] = 1.0f / m_Delta[iAxis];
   }
   else
   {
    vecInvDelta[iAxis] = 3.40282346638528859812e+38F;
   }
  }
  return vecInvDelta;
 }

private:
};











class Vector;
struct Ray_t;
class IHandleEntity;
enum
{
 PARTITION_ENGINE_SOLID_EDICTS = (1 << 0),
 PARTITION_ENGINE_TRIGGER_EDICTS = (1 << 1),
 PARTITION_CLIENT_SOLID_EDICTS = (1 << 2),
 PARTITION_CLIENT_RESPONSIVE_EDICTS = (1 << 3),
 PARTITION_ENGINE_NON_STATIC_EDICTS = (1 << 4),
 PARTITION_CLIENT_STATIC_PROPS = (1 << 5),
 PARTITION_ENGINE_STATIC_PROPS = (1 << 6),
 PARTITION_CLIENT_NON_STATIC_EDICTS = (1 << 7),
};
enum IterationRetval_t
{
 ITERATION_CONTINUE = 0,
 ITERATION_STOP,
};


typedef unsigned short SpatialPartitionHandle_t;


typedef int SpatialPartitionListMask_t;

typedef int SpatialTempHandle_t;
class IPartitionEnumerator
{
public:
 virtual IterationRetval_t EnumElement( IHandleEntity *pHandleEntity ) = 0;
};





class IPartitionQueryCallback
{
public:
 virtual void OnPreQuery_V1() = 0;
 virtual void OnPreQuery( SpatialPartitionListMask_t listMask ) = 0;
 virtual void OnPostQuery( SpatialPartitionListMask_t listMask ) = 0;
};





enum
{
 PARTITION_INVALID_HANDLE = (SpatialPartitionHandle_t)~0
};


class ISpatialPartition
{
public:


 virtual SpatialPartitionHandle_t CreateHandle( IHandleEntity *pHandleEntity ) = 0;


 virtual SpatialPartitionHandle_t CreateHandle( IHandleEntity *pHandleEntity,
  SpatialPartitionListMask_t listMask, const Vector& mins, const Vector& maxs ) = 0;

 virtual void DestroyHandle( SpatialPartitionHandle_t handle ) = 0;



 virtual void Insert( SpatialPartitionListMask_t listMask,
  SpatialPartitionHandle_t handle ) = 0;
 virtual void Remove( SpatialPartitionListMask_t listMask,
  SpatialPartitionHandle_t handle ) = 0;


 virtual void RemoveAndInsert( SpatialPartitionListMask_t removeMask, SpatialPartitionListMask_t insertMask,
  SpatialPartitionHandle_t handle ) = 0;


 virtual void Remove( SpatialPartitionHandle_t handle ) = 0;


 virtual void ElementMoved( SpatialPartitionHandle_t handle,
  const Vector& mins, const Vector& maxs ) = 0;



 virtual SpatialTempHandle_t HideElement( SpatialPartitionHandle_t handle ) = 0;
 virtual void UnhideElement( SpatialPartitionHandle_t handle, SpatialTempHandle_t tempHandle ) = 0;


 virtual void InstallQueryCallback_V1( IPartitionQueryCallback *pCallback ) = 0;
 virtual void RemoveQueryCallback( IPartitionQueryCallback *pCallback ) = 0;





 virtual void EnumerateElementsInBox(
  SpatialPartitionListMask_t listMask,
  const Vector& mins,
  const Vector& maxs,
  bool coarseTest,
  IPartitionEnumerator* pIterator
  ) = 0;

 virtual void EnumerateElementsInSphere(
  SpatialPartitionListMask_t listMask,
  const Vector& origin,
  float radius,
  bool coarseTest,
  IPartitionEnumerator* pIterator
  ) = 0;

 virtual void EnumerateElementsAlongRay(
  SpatialPartitionListMask_t listMask,
  const Ray_t& ray,
  bool coarseTest,
  IPartitionEnumerator* pIterator
  ) = 0;

 virtual void EnumerateElementsAtPoint(
  SpatialPartitionListMask_t listMask,
  const Vector& pt,
  bool coarseTest,
  IPartitionEnumerator* pIterator
  ) = 0;


 virtual void SuppressLists( SpatialPartitionListMask_t nListMask, bool bSuppress ) = 0;
 virtual SpatialPartitionListMask_t GetSuppressedLists() = 0;

 virtual void RenderAllObjectsInTree( float flTime ) = 0;
 virtual void RenderObjectsInPlayerLeafs( const Vector &vecPlayerMin, const Vector &vecPlayerMax, float flTime ) = 0;
 virtual void RenderLeafsForRayTraceStart( float flTime ) = 0;
 virtual void RenderLeafsForRayTraceEnd( void ) = 0;
 virtual void RenderLeafsForHullTraceStart( float flTime ) = 0;
 virtual void RenderLeafsForHullTraceEnd( void ) = 0;
 virtual void RenderLeafsForBoxStart( float flTime ) = 0;
 virtual void RenderLeafsForBoxEnd( void ) = 0;
 virtual void RenderLeafsForSphereStart( float flTime ) = 0;
 virtual void RenderLeafsForSphereEnd( void ) = 0;

 virtual void RenderObjectsInBox( const Vector &vecMin, const Vector &vecMax, float flTime ) = 0;
 virtual void RenderObjectsInSphere( const Vector &vecCenter, float flRadius, float flTime ) = 0;
 virtual void RenderObjectsAlongRay( const Ray_t& ray, float flTime ) = 0;

 virtual void ReportStats( const char *pFileName ) = 0;

 virtual void InstallQueryCallback( IPartitionQueryCallback *pCallback ) = 0;
};




 class CBaseEntity;







class CGameTrace : public CBaseTrace
{
public:



 bool DidHitWorld() const;


 bool DidHitNonWorldEntity() const;



 int GetEntityIndex() const;


 bool DidHit() const;
public:

 float fractionleftsolid;
 csurface_t surface;

 int hitgroup;
 short physicsbone;




  CBaseEntity *m_pEnt;





 int hitbox;

 CGameTrace() {}

private:

 CGameTrace(const CGameTrace& vOther);
};





inline bool CGameTrace::DidHit() const
{
 return fraction < 1 || allsolid || startsolid;
}


typedef CGameTrace trace_t;



class ITraceListData
{
public:
 virtual ~ITraceListData() {}

 virtual void Reset() = 0;
 virtual bool IsEmpty() = 0;



 virtual bool CanTraceRay( const Ray_t &ray ) = 0;
};




class CTraceListData : public IPartitionEnumerator
{
public:

 CTraceListData( int nLeafMax = 256, int nEntityMax = 1024 )
 {
  ((void)0);
  m_nLeafCount = 0;
  m_aLeafList.SetSize( nLeafMax );

  m_nEntityCount = 0;
  m_aEntityList.SetSize( nEntityMax );
 }

 ~CTraceListData()
 {
  m_nLeafCount = 0;
  m_aLeafList.RemoveAll();

  m_nEntityCount = 0;
  m_aEntityList.RemoveAll();
 }

 void Reset( void )
 {
  m_nLeafCount = 0;
  m_nEntityCount = 0;
 }

 bool IsEmpty( void ) const { return ( m_nLeafCount == 0 && m_nEntityCount == 0 ); }

 int LeafCount( void ) const { return m_nLeafCount; }
 int LeafCountMax( void ) const { return m_aLeafList.Count(); }
 void LeafCountReset( void ) { m_nLeafCount = 0; }

 int EntityCount( void ) const { return m_nEntityCount; }
 int EntityCountMax( void ) const { return m_aEntityList.Count(); }
 void EntityCountReset( void ) { m_nEntityCount = 0; }


 void AddLeaf( int iLeaf )
 {
  if ( m_nLeafCount >= m_aLeafList.Count() )
  {
   DevMsg( "CTraceListData: Max leaf count along ray exceeded!\n" );
   m_aLeafList.AddMultipleToTail( m_aLeafList.Count() );
  }

  m_aLeafList[m_nLeafCount] = iLeaf;
  m_nLeafCount++;
 }


 IterationRetval_t EnumElement( IHandleEntity *pHandleEntity )
 {
  if ( m_nEntityCount >= m_aEntityList.Count() )
  {
   DevMsg( "CTraceListData: Max entity count along ray exceeded!\n" );
   m_aEntityList.AddMultipleToTail( m_aEntityList.Count() );
  }

  m_aEntityList[m_nEntityCount] = pHandleEntity;
  m_nEntityCount++;

  return ITERATION_CONTINUE;
 }

public:

 int m_nLeafCount;
 CUtlVector<int> m_aLeafList;

 int m_nEntityCount;
 CUtlVector<IHandleEntity*> m_aEntityList;
};

class ICollideable;
class IServerNetworkable;
class CBaseEntity;




class IServerUnknown : public IHandleEntity
{
public:

 virtual ICollideable* GetCollideable() = 0;
 virtual IServerNetworkable* GetNetworkable() = 0;
 virtual CBaseEntity* GetBaseEntity() = 0;
};
struct string_t
{
public:
 bool operator!() const { return ( pszValue == 
                                                    __null 
                                                         ); }
 bool operator==( const string_t &rhs ) const { return ( pszValue == rhs.pszValue ); }
 bool operator!=( const string_t &rhs ) const { return ( pszValue != rhs.pszValue ); }
 bool operator<( const string_t &rhs ) const { return ((void *)pszValue < (void *)rhs.pszValue ); }

 const char *ToCStr() const { return ( pszValue ) ? pszValue : ""; }

protected:
 const char *pszValue;
};



struct castable_string_t : public string_t
{
 castable_string_t() { pszValue = 
                                       __null
                                           ; }
 castable_string_t( const char *pszFrom ) { pszValue = (pszFrom && *pszFrom) ? pszFrom : 0; }
};



struct Ray_t;
class ServerClass;
class ICollideable;
class IServerNetworkable;
class Vector;
class QAngle;



class IServerEntity : public IServerUnknown
{
public:
 virtual ~IServerEntity() {}


 virtual int GetModelIndex( void ) const = 0;
  virtual string_t GetModelName( void ) const = 0;

 virtual void SetModelIndex( int index ) = 0;
};
class CSaveRestoreData;




class CGlobalVarsBase
{
public:

 CGlobalVarsBase( bool bIsClient );


 bool IsClient() const;


 int GetNetworkBase( int nTick, int nEntity );

public:



 float realtime;

 int framecount;

 float absoluteframetime;
 float curtime;


 float frametime;

 int maxClients;


 int tickcount;


 float interval_per_tick;


 float interpolation_amount;
 int simTicksThisFrame;

 int network_protocol;


 CSaveRestoreData *pSaveData;

private:

 bool m_bClient;


 int nTimestampNetworkingBase;


 int nTimestampRandomizeWindow;

};

inline int CGlobalVarsBase::GetNetworkBase( int nTick, int nEntity )
{
 int nEntityMod = nEntity % nTimestampRandomizeWindow;
 int nBaseTick = nTimestampNetworkingBase * (int)( ( nTick - nEntityMod ) / nTimestampNetworkingBase );
 return nBaseTick;
}

inline CGlobalVarsBase::CGlobalVarsBase( bool bIsClient ) :
 m_bClient( bIsClient ),
 nTimestampNetworkingBase( 100 ),
 nTimestampRandomizeWindow( 32 )
{
}

inline bool CGlobalVarsBase::IsClient() const
{
 return m_bClient;
}
enum SolidType_t;
class IHandleEntity;
struct Ray_t;
struct model_t;
class Vector;
class QAngle;
class CGameTrace;
typedef CGameTrace trace_t;
class IClientUnknown;


class ICollideable
{
public:

 virtual IHandleEntity *GetEntityHandle() = 0;




 virtual const Vector& OBBMins( ) const = 0;
 virtual const Vector& OBBMaxs( ) const = 0;




 virtual void WorldSpaceTriggerBounds( Vector *pVecWorldMins, Vector *pVecWorldMaxs ) const = 0;


 virtual bool TestCollision( const Ray_t &ray, unsigned int fContentsMask, trace_t& tr ) = 0;


 virtual bool TestHitboxes( const Ray_t &ray, unsigned int fContentsMask, trace_t& tr ) = 0;


 virtual int GetCollisionModelIndex() = 0;


 virtual const model_t* GetCollisionModel() = 0;


 virtual const Vector& GetCollisionOrigin() const = 0;
 virtual const QAngle& GetCollisionAngles() const = 0;
 virtual const matrix3x4_t& CollisionToWorldTransform() const = 0;


 virtual SolidType_t GetSolid() const = 0;
 virtual int GetSolidFlags() const = 0;


 virtual IClientUnknown* GetIClientUnknown() = 0;


 virtual int GetCollisionGroup() const = 0;




 virtual void WorldSpaceSurroundingBounds( Vector *pVecMins, Vector *pVecMaxs ) = 0;

 virtual bool ShouldTouchTrigger( int triggerSolidFlags ) const = 0;


 virtual const matrix3x4_t *GetRootParentToWorldTransform() const = 0;
};



class CBitVecAccessor
{
public:
    CBitVecAccessor(uint32 *pDWords, int iBit);

 void operator=(int val);
    operator uint32();

private:
 uint32 *m_pDWords;
 int m_iBit;
};
inline int FirstBitInWord( unsigned int elem, int offset )
{
 static unsigned firstBitLUT[256] =
 {
  0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,
  3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
  4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,
  3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
  5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,
  3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
  4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
 };
 unsigned elemByte;

 elemByte = (elem & 0xFF);
 if ( elemByte )
  return offset + firstBitLUT[elemByte];

 elem >>= 8;
 offset += 8;
 elemByte = (elem & 0xFF);
 if ( elemByte )
  return offset + firstBitLUT[elemByte];

 elem >>= 8;
 offset += 8;
 elemByte = (elem & 0xFF);
 if ( elemByte )
  return offset + firstBitLUT[elemByte];

 elem >>= 8;
 offset += 8;
 elemByte = (elem & 0xFF);
 if ( elemByte )
  return offset + firstBitLUT[elemByte];

 return -1;

}



inline unsigned GetEndMask( int numBits )
{
 static unsigned bitStringEndMasks[] =
 {
  0xffffffff,
  0x00000001,
  0x00000003,
  0x00000007,
  0x0000000f,
  0x0000001f,
  0x0000003f,
  0x0000007f,
  0x000000ff,
  0x000001ff,
  0x000003ff,
  0x000007ff,
  0x00000fff,
  0x00001fff,
  0x00003fff,
  0x00007fff,
  0x0000ffff,
  0x0001ffff,
  0x0003ffff,
  0x0007ffff,
  0x000fffff,
  0x001fffff,
  0x003fffff,
  0x007fffff,
  0x00ffffff,
  0x01ffffff,
  0x03ffffff,
  0x07ffffff,
  0x0fffffff,
  0x1fffffff,
  0x3fffffff,
  0x7fffffff,
 };

 return bitStringEndMasks[numBits % 32];
}


inline int GetBitForBitnum( int bitNum )
{
 static int bitsForBitnum[] =
 {
  ( 1 << 0 ),
  ( 1 << 1 ),
  ( 1 << 2 ),
  ( 1 << 3 ),
  ( 1 << 4 ),
  ( 1 << 5 ),
  ( 1 << 6 ),
  ( 1 << 7 ),
  ( 1 << 8 ),
  ( 1 << 9 ),
  ( 1 << 10 ),
  ( 1 << 11 ),
  ( 1 << 12 ),
  ( 1 << 13 ),
  ( 1 << 14 ),
  ( 1 << 15 ),
  ( 1 << 16 ),
  ( 1 << 17 ),
  ( 1 << 18 ),
  ( 1 << 19 ),
  ( 1 << 20 ),
  ( 1 << 21 ),
  ( 1 << 22 ),
  ( 1 << 23 ),
  ( 1 << 24 ),
  ( 1 << 25 ),
  ( 1 << 26 ),
  ( 1 << 27 ),
  ( 1 << 28 ),
  ( 1 << 29 ),
  ( 1 << 30 ),
  ( 1 << 31 ),
 };

 return bitsForBitnum[ (bitNum) & (32 -1) ];
}

inline int GetBitForBitnumByte( int bitNum )
{
 static int bitsForBitnum[] =
 {
  ( 1 << 0 ),
  ( 1 << 1 ),
  ( 1 << 2 ),
  ( 1 << 3 ),
  ( 1 << 4 ),
  ( 1 << 5 ),
  ( 1 << 6 ),
  ( 1 << 7 ),
 };

 return bitsForBitnum[ bitNum & 7 ];
}

inline int CalcNumIntsForBits( int numBits ) { return (numBits + (32 -1)) / 32; }
template <class BASE_OPS>
class CBitVecT : public BASE_OPS
{
public:
 CBitVecT();
 CBitVecT(int numBits);

 void Init(int val = 0);


 CBitVecAccessor operator[](int i);


 void And(const CBitVecT &andStr, CBitVecT *out) const;
 void Or(const CBitVecT &orStr, CBitVecT *out) const;
 void Xor(const CBitVecT &orStr, CBitVecT *out) const;

 void Not(CBitVecT *out) const;

 void CopyTo(CBitVecT *out) const;
 void Copy( const CBitVecT<BASE_OPS> &other, int nBits=-1 );
 bool Compare( const CBitVecT<BASE_OPS> &other, int nBits=-1 ) const;

 bool IsAllClear(void) const;
 bool IsAllSet(void) const;

 uint32 Get( uint32 bitNum ) const;
 bool IsBitSet( int bitNum ) const;
 void Set( int bitNum );
 void Set( int bitNum, bool bNewVal );
 void Clear(int bitNum);

 bool TestAndSet(int bitNum);

 void Set( uint32 offset, uint32 mask );
 void Clear( uint32 offset, uint32 mask );
 uint32 Get( uint32 offset, uint32 mask );

 void SetAll(void);
 void ClearAll(void);

 uint32 GetDWord(int i) const;
 void SetDWord(int i, uint32 val);

 CBitVecT<BASE_OPS>& operator=(const CBitVecT<BASE_OPS> &other) { other.CopyTo( this ); return *this; }
 bool operator==(const CBitVecT<BASE_OPS> &other) { return Compare( other ); }
 bool operator!=(const CBitVecT<BASE_OPS> &other) { return !operator==( other ); }

 static void GetOffsetMaskForBit( uint32 bitNum, uint32 *pOffset, uint32 *pMask ) { *pOffset = ( (bitNum) >> 5 ); *pMask = ( 1 << ( (bitNum) & (32 -1) ) ); }
};






class CVarBitVecBase
{
public:
 bool IsFixedSize() const { return false; }
 int GetNumBits(void) const { return m_numBits; }
 void Resize( int numBits, bool bClearAll = false );

 int GetNumDWords() const { return m_numInts; }
 uint32 *Base() { return m_pInt; }
 const uint32 *Base() const { return m_pInt; }

 void Attach( uint32 *pBits, int numBits );
 bool Detach( uint32 **ppBits, int *pNumBits );

 int FindNextSetBit(int iStartBit) const;

protected:
 CVarBitVecBase();
 CVarBitVecBase(int numBits);
 CVarBitVecBase( const CVarBitVecBase &from );
 CVarBitVecBase &operator=( const CVarBitVecBase &from );
 ~CVarBitVecBase(void);

 void ValidateOperand( const CVarBitVecBase &operand ) const { ((void)0); }

 unsigned GetEndMask() const { return ::GetEndMask( GetNumBits() ); }

private:

 unsigned short m_numBits;
 unsigned short m_numInts;
 uint32 m_iBitStringStorage;
 uint32 * m_pInt;

 void AllocInts( int numInts );
 void ReallocInts( int numInts );
 void FreeInts( void );
};







template <int bits> struct BitCountToEndMask_t { };
template <> struct BitCountToEndMask_t< 0> { enum { MASK = 0xffffffff }; };
template <> struct BitCountToEndMask_t< 1> { enum { MASK = 0x00000001 }; };
template <> struct BitCountToEndMask_t< 2> { enum { MASK = 0x00000003 }; };
template <> struct BitCountToEndMask_t< 3> { enum { MASK = 0x00000007 }; };
template <> struct BitCountToEndMask_t< 4> { enum { MASK = 0x0000000f }; };
template <> struct BitCountToEndMask_t< 5> { enum { MASK = 0x0000001f }; };
template <> struct BitCountToEndMask_t< 6> { enum { MASK = 0x0000003f }; };
template <> struct BitCountToEndMask_t< 7> { enum { MASK = 0x0000007f }; };
template <> struct BitCountToEndMask_t< 8> { enum { MASK = 0x000000ff }; };
template <> struct BitCountToEndMask_t< 9> { enum { MASK = 0x000001ff }; };
template <> struct BitCountToEndMask_t<10> { enum { MASK = 0x000003ff }; };
template <> struct BitCountToEndMask_t<11> { enum { MASK = 0x000007ff }; };
template <> struct BitCountToEndMask_t<12> { enum { MASK = 0x00000fff }; };
template <> struct BitCountToEndMask_t<13> { enum { MASK = 0x00001fff }; };
template <> struct BitCountToEndMask_t<14> { enum { MASK = 0x00003fff }; };
template <> struct BitCountToEndMask_t<15> { enum { MASK = 0x00007fff }; };
template <> struct BitCountToEndMask_t<16> { enum { MASK = 0x0000ffff }; };
template <> struct BitCountToEndMask_t<17> { enum { MASK = 0x0001ffff }; };
template <> struct BitCountToEndMask_t<18> { enum { MASK = 0x0003ffff }; };
template <> struct BitCountToEndMask_t<19> { enum { MASK = 0x0007ffff }; };
template <> struct BitCountToEndMask_t<20> { enum { MASK = 0x000fffff }; };
template <> struct BitCountToEndMask_t<21> { enum { MASK = 0x001fffff }; };
template <> struct BitCountToEndMask_t<22> { enum { MASK = 0x003fffff }; };
template <> struct BitCountToEndMask_t<23> { enum { MASK = 0x007fffff }; };
template <> struct BitCountToEndMask_t<24> { enum { MASK = 0x00ffffff }; };
template <> struct BitCountToEndMask_t<25> { enum { MASK = 0x01ffffff }; };
template <> struct BitCountToEndMask_t<26> { enum { MASK = 0x03ffffff }; };
template <> struct BitCountToEndMask_t<27> { enum { MASK = 0x07ffffff }; };
template <> struct BitCountToEndMask_t<28> { enum { MASK = 0x0fffffff }; };
template <> struct BitCountToEndMask_t<29> { enum { MASK = 0x1fffffff }; };
template <> struct BitCountToEndMask_t<30> { enum { MASK = 0x3fffffff }; };
template <> struct BitCountToEndMask_t<31> { enum { MASK = 0x7fffffff }; };



template <int NUM_BITS>
class CFixedBitVecBase
{
public:
 bool IsFixedSize() const { return true; }
 int GetNumBits(void) const { return NUM_BITS; }
 void Resize( int numBits, bool bClearAll = false ) { ((void)0); if ( bClearAll ) memset( m_Ints, 0, NUM_INTS * sizeof(uint32) ); }

 int GetNumDWords() const { return NUM_INTS; }
 uint32 * Base() { return m_Ints; }
 const uint32 * Base() const { return m_Ints; }

 int FindNextSetBit(int iStartBit) const;

protected:
 CFixedBitVecBase() {}
 CFixedBitVecBase(int numBits) { ((void)0); }

 void ValidateOperand( const CFixedBitVecBase<NUM_BITS> &operand ) const { }

public:
 unsigned GetEndMask() const { return static_cast<unsigned>( BitCountToEndMask_t<NUM_BITS % 32>::MASK ); }

private:
 enum
 {
  NUM_INTS = (NUM_BITS + (32 -1)) / 32
 };

 uint32 m_Ints[(NUM_BITS + (32 -1)) / 32];
};







class CVarBitVec : public CBitVecT<CVarBitVecBase>
{
public:
 CVarBitVec()
 {
 }

 CVarBitVec(int numBits)
  : CBitVecT<CVarBitVecBase>(numBits)
 {
 }
};



template < int NUM_BITS >
class CBitVec : public CBitVecT< CFixedBitVecBase<NUM_BITS> >
{
public:
 CBitVec()
 {
 }

 CBitVec(int numBits)
  : CBitVecT< CFixedBitVecBase<NUM_BITS> >(numBits)
 {
 }
};




typedef CBitVec<32> CDWordBitVec;



inline CVarBitVecBase::CVarBitVecBase()
{
 memset( this, 0, sizeof( *this ) );
}



inline CVarBitVecBase::CVarBitVecBase(int numBits)
{
 ((void)0);
 m_numBits = numBits;


 m_numInts = CalcNumIntsForBits( numBits );
 m_pInt = 
         __null
             ;
 AllocInts( m_numInts );
}



inline CVarBitVecBase::CVarBitVecBase( const CVarBitVecBase &from )
{
 if ( from.m_numInts )
 {
  m_numBits = from.m_numBits;
  m_numInts = from.m_numInts;
  m_pInt = 
          __null
              ;
  AllocInts( m_numInts );
  memcpy( m_pInt, from.m_pInt, m_numInts * sizeof(int) );
 }
 else
  memset( this, 0, sizeof( *this ) );
}



inline CVarBitVecBase &CVarBitVecBase::operator=( const CVarBitVecBase &from )
{
 Resize( from.GetNumBits() );
 if ( m_pInt )
  memcpy( m_pInt, from.m_pInt, m_numInts * sizeof(int) );
 return (*this);
}







inline CVarBitVecBase::~CVarBitVecBase(void)
{
 FreeInts();
}



inline void CVarBitVecBase::Attach( uint32 *pBits, int numBits )
{
 FreeInts();
 m_numBits = numBits;
 m_numInts = CalcNumIntsForBits( numBits );
 if ( m_numInts > 1 )
 {
  m_pInt = pBits;
 }
 else
 {
  m_iBitStringStorage = *pBits;
  m_pInt = &m_iBitStringStorage;
  free( pBits );
 }
}



inline bool CVarBitVecBase::Detach( uint32 **ppBits, int *pNumBits )
{
 if ( !m_numBits )
 {
  return false;
 }

 *pNumBits = m_numBits;
 if ( m_numInts > 1 )
 {
  *ppBits = m_pInt;
 }
 else
 {
  *ppBits = (uint32 *)malloc( sizeof(uint32) );
  **ppBits = m_iBitStringStorage;
  free( m_pInt );
 }

 memset( this, 0, sizeof( *this ) );
 return true;
}



template <class BASE_OPS>
inline CBitVecT<BASE_OPS>::CBitVecT()
{



 ;


 ClearAll();
}


template <class BASE_OPS>
inline CBitVecT<BASE_OPS>::CBitVecT(int numBits)
 : BASE_OPS( numBits )
{



 ;


 ClearAll();
}



template <class BASE_OPS>
inline CBitVecAccessor CBitVecT<BASE_OPS>::operator[](int i)
{
 ((void)0);
 return CBitVecAccessor(this->Base(), i);
}




template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Init( int val )
{
 if ( CBitVecT<BASE_OPS>::Base() )
  memset( CBitVecT<BASE_OPS>::Base(), ( val ) ? 0xff : 0, CBitVecT<BASE_OPS>::GetNumDWords() * sizeof(int) );
}



template <class BASE_OPS>
inline uint32 CBitVecT<BASE_OPS>::Get( uint32 bitNum ) const
{
 ((void)0);
 const uint32 *pInt = this->Base() + ( (bitNum) >> 5 );
 return ( *pInt & ( 1 << ( (bitNum) & (32 -1) ) ) );
}



template <class BASE_OPS>
inline bool CBitVecT<BASE_OPS>::IsBitSet( int bitNum ) const
{
 ((void)0);
 const uint32 *pInt = this->Base() + ( (bitNum) >> 5 );
 return ( ( *pInt & ( 1 << ( (bitNum) & (32 -1) ) ) ) != 0 );
}



template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Set( int bitNum )
{
 ((void)0);
 uint32 *pInt = this->Base() + ( (bitNum) >> 5 );
 *pInt |= ( 1 << ( (bitNum) & (32 -1) ) );
}



template <class BASE_OPS>
inline bool CBitVecT<BASE_OPS>::TestAndSet(int bitNum)
{
 ((void)0);
 uint32 bitVecBit = ( 1 << ( (bitNum) & (32 -1) ) );
 uint32 *pInt = this->Base() + ( (bitNum) >> 5 );
 bool bResult = ( ( *pInt & bitVecBit) != 0 );
 *pInt |= bitVecBit;
 return bResult;
}



template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Clear(int bitNum)
{
 ((void)0);
 uint32 *pInt = this->Base() + ( (bitNum) >> 5 );
 *pInt &= ~( 1 << ( (bitNum) & (32 -1) ) );
}



template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Set( int bitNum, bool bNewVal )
{
 uint32 *pInt = CBitVecT<BASE_OPS>::Base() + ( (bitNum) >> 5 );
 uint32 bitMask = ( 1 << ( (bitNum) & (32 -1) ) );
 if ( bNewVal )
 {
  *pInt |= bitMask;
 }
 else
 {
  *pInt &= ~bitMask;
 }
}



template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Set( uint32 offset, uint32 mask )
{
 uint32 *pInt = CBitVecT<BASE_OPS>::Base() + offset;
 *pInt |= mask;
}



template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Clear( uint32 offset, uint32 mask )
{
 uint32 *pInt = CBitVecT<BASE_OPS>::Base() + offset;
 *pInt &= ~mask;
}



template <class BASE_OPS>
inline uint32 CBitVecT<BASE_OPS>::Get( uint32 offset, uint32 mask )
{
 uint32 *pInt = CBitVecT<BASE_OPS>::Base() + offset;
 return ( *pInt & mask );
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::And(const CBitVecT &addStr, CBitVecT *out) const
{
 ValidateOperand( addStr );
 ValidateOperand( *out );

 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = CBitVecT<BASE_OPS>::Base();
 const uint32 *pOperand2 = addStr.Base();

 for (int i = CBitVecT<BASE_OPS>::GetNumDWords() - 1; i >= 0 ; --i)
 {
  pDest[i] = pOperand1[i] & pOperand2[i];
 }
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Or(const CBitVecT &orStr, CBitVecT *out) const
{
 ValidateOperand( orStr );
 ValidateOperand( *out );

 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = CBitVecT<BASE_OPS>::Base();
 const uint32 *pOperand2 = orStr.Base();

 for (int i = CBitVecT<BASE_OPS>::GetNumDWords() - 1; i >= 0; --i)
 {
  pDest[i] = pOperand1[i] | pOperand2[i];
 }
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Xor(const CBitVecT &xorStr, CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = CBitVecT<BASE_OPS>::Base();
 const uint32 *pOperand2 = xorStr.Base();

 for (int i = CBitVecT<BASE_OPS>::GetNumDWords() - 1; i >= 0; --i)
 {
  pDest[i] = pOperand1[i] ^ pOperand2[i];
 }
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Not(CBitVecT *out) const
{
 ValidateOperand( *out );

 uint32 * pDest = out->Base();
 const uint32 *pOperand = CBitVecT<BASE_OPS>::Base();

 for (int i = CBitVecT<BASE_OPS>::GetNumDWords() - 1; i >= 0; --i)
 {
  pDest[i] = ~(pOperand[i]);
 }
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::CopyTo(CBitVecT *out) const
{
 out->Resize( CBitVecT<BASE_OPS>::GetNumBits() );

 ValidateOperand( *out );
 ((void)0);

 memcpy( out->Base(), CBitVecT<BASE_OPS>::Base(), CBitVecT<BASE_OPS>::GetNumDWords() * sizeof( int ) );
}






template <class BASE_OPS>
inline bool CBitVecT<BASE_OPS>::IsAllClear(void) const
{



 (const_cast<CBitVecT *>(this))->Base()[CBitVecT<BASE_OPS>::GetNumDWords()-1] &= CBitVecT<BASE_OPS>::GetEndMask();

 for (int i = CBitVecT<BASE_OPS>::GetNumDWords() - 1; i >= 0; --i)
 {
  if ( CBitVecT<BASE_OPS>::Base()[i] !=0 )
  {
   return false;
  }
 }
 return true;
}






template <class BASE_OPS>
inline bool CBitVecT<BASE_OPS>::IsAllSet(void) const
{



 (const_cast<CBitVecT *>(this))->Base()[CBitVecT<BASE_OPS>::GetNumDWords()-1] |= ~CBitVecT<BASE_OPS>::GetEndMask();

 for (int i = CBitVecT<BASE_OPS>::GetNumDWords() - 1; i >= 0; --i)
 {
  if ( CBitVecT<BASE_OPS>::Base()[i] != ~0 )
  {
   return false;
  }
 }
 return true;
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::SetAll(void)
{
 if ( CBitVecT<BASE_OPS>::Base() )
  memset( CBitVecT<BASE_OPS>::Base(), 0xff, CBitVecT<BASE_OPS>::GetNumDWords() * sizeof(int) );
}






template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::ClearAll(void)
{
 if ( CBitVecT<BASE_OPS>::Base() )
  memset( CBitVecT<BASE_OPS>::Base(), 0, CBitVecT<BASE_OPS>::GetNumDWords() * sizeof(int) );
}


template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::Copy( const CBitVecT<BASE_OPS> &other, int nBits )
{
 if ( nBits == - 1 )
 {
  nBits = other.GetNumBits();
 }

 CBitVecT<BASE_OPS>::Resize( nBits );

 ValidateOperand( other );
 ((void)0);

 memcpy( CBitVecT<BASE_OPS>::Base(), other.Base(), CBitVecT<BASE_OPS>::GetNumDWords() * sizeof( uint32 ) );
}


template <class BASE_OPS>
inline bool CBitVecT<BASE_OPS>::Compare( const CBitVecT<BASE_OPS> &other, int nBits ) const
{
 if ( nBits == - 1 )
 {
  if ( other.GetNumBits() != CBitVecT<BASE_OPS>::GetNumBits() )
  {
   return false;
  }

  nBits = other.GetNumBits();
 }

 if ( nBits > other.GetNumBits() || nBits > CBitVecT<BASE_OPS>::GetNumBits() )
 {
  return false;
 }

 (const_cast<CBitVecT *>(this))->Base()[CBitVecT<BASE_OPS>::GetNumDWords()-1] &= CBitVecT<BASE_OPS>::GetEndMask();
 (const_cast<CBitVecT *>(&other))->Base()[CBitVecT<BASE_OPS>::GetNumDWords()-1] &= other.CBitVecT<BASE_OPS>::GetEndMask();

 int nBytes = ( ((nBits) + ((8)-1)) / (8) ) * (8) >> 3;

 return ( memcmp( CBitVecT<BASE_OPS>::Base(), other.Base(), nBytes ) == 0 );
}


template <class BASE_OPS>
inline uint32 CBitVecT<BASE_OPS>::GetDWord(int i) const
{
 ((void)0);
 return CBitVecT<BASE_OPS>::Base()[i];
}


template <class BASE_OPS>
inline void CBitVecT<BASE_OPS>::SetDWord(int i, uint32 val)
{
 ((void)0);
 CBitVecT<BASE_OPS>::Base()[i] = val;
}



inline unsigned GetStartBitMask( int startBit )
{
 static unsigned int g_StartMask[32] =
 {
  0xffffffff,
  0xfffffffe,
  0xfffffffc,
  0xfffffff8,
  0xfffffff0,
  0xffffffe0,
  0xffffffc0,
  0xffffff80,
  0xffffff00,
  0xfffffe00,
  0xfffffc00,
  0xfffff800,
  0xfffff000,
  0xffffe000,
  0xffffc000,
  0xffff8000,
  0xffff0000,
  0xfffe0000,
  0xfffc0000,
  0xfff80000,
  0xfff00000,
  0xffe00000,
  0xffc00000,
  0xff800000,
  0xff000000,
  0xfe000000,
  0xfc000000,
  0xf8000000,
  0xf0000000,
  0xe0000000,
  0xc0000000,
  0x80000000,
 };

 return g_StartMask[ startBit & 31 ];
}

inline int CVarBitVecBase::FindNextSetBit( int startBit ) const
{
 if ( startBit < GetNumBits() )
 {
  int wordIndex = ( (startBit) >> 5 );
  unsigned int startMask = GetStartBitMask( startBit );
  int lastWord = GetNumDWords()-1;


  if ( (GetNumBits() % 32) != 0 )
  {
   unsigned int elem = Base()[wordIndex];
   elem &= startMask;
   if ( wordIndex == lastWord)
   {
    elem &= (GetEndMask());

    if ( elem )
     return FirstBitInWord(elem, wordIndex << 5);
   }
   else
   {

    if ( elem )
     return FirstBitInWord(elem, wordIndex << 5);


    for ( int i = wordIndex+1; i < lastWord; i++ )
    {
     elem = Base()[i];
     if ( elem )
      return FirstBitInWord(elem, i << 5);
    }
    elem = Base()[lastWord] & GetEndMask();
    if ( elem )
     return FirstBitInWord(elem, lastWord << 5);
   }
  }
  else
  {
   const uint32 * pCurElem = Base() + wordIndex;
   unsigned int elem = *pCurElem;
   elem &= startMask;
   do
   {
    if ( elem )
     return FirstBitInWord(elem, wordIndex << 5);
    ++pCurElem;
    elem = *pCurElem;
    ++wordIndex;
   } while( wordIndex <= lastWord );
  }

 }

 return -1;
}

template <int NUM_BITS>
inline int CFixedBitVecBase<NUM_BITS>::FindNextSetBit( int startBit ) const
{
 if ( startBit < NUM_BITS )
 {
  int wordIndex = ( (startBit) >> 5 );
  unsigned int startMask = GetStartBitMask( startBit );


  if ( (NUM_BITS % 32) != 0 )
  {
   unsigned int elem = Base()[wordIndex];
   elem &= startMask;
   if ( wordIndex == NUM_INTS-1)
   {
    elem &= (GetEndMask());

    if ( elem )
     return FirstBitInWord(elem, wordIndex << 5);
   }
   else
   {

    if ( elem )
     return FirstBitInWord(elem, wordIndex << 5);


    for ( int i = wordIndex+1; i < NUM_INTS-1; i++ )
    {
     elem = Base()[i];
     if ( elem )
      return FirstBitInWord(elem, i << 5);
    }
    elem = Base()[NUM_INTS-1] & GetEndMask();
    if ( elem )
     return FirstBitInWord(elem, (NUM_INTS-1) << 5);
   }
  }
  else
  {
   const uint32 * pCurElem = Base() + wordIndex;
   unsigned int elem = *pCurElem;
   elem &= startMask;
   do
   {
    if ( elem )
     return FirstBitInWord(elem, wordIndex << 5);
    ++pCurElem;
    elem = *pCurElem;
    ++wordIndex;
   } while( wordIndex <= NUM_INTS-1);
  }

 }

 return -1;
}




template<>
inline void CBitVecT< CFixedBitVecBase<256> >::And(const CBitVecT &addStr, CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = Base();
 const uint32 *pOperand2 = addStr.Base();

 pDest[0] = pOperand1[0] & pOperand2[0];
 pDest[1] = pOperand1[1] & pOperand2[1];
 pDest[2] = pOperand1[2] & pOperand2[2];
 pDest[3] = pOperand1[3] & pOperand2[3];
 pDest[4] = pOperand1[4] & pOperand2[4];
 pDest[5] = pOperand1[5] & pOperand2[5];
 pDest[6] = pOperand1[6] & pOperand2[6];
 pDest[7] = pOperand1[7] & pOperand2[7];
}

template<>
inline bool CBitVecT< CFixedBitVecBase<256> >::IsAllClear(void) const
{
 const uint32 *pInts = Base();
 return ( pInts[0] == 0 && pInts[1] == 0 && pInts[2] == 0 && pInts[3] == 0 && pInts[4] == 0 && pInts[5] == 0 && pInts[6] == 0 && pInts[7] == 0 );
}

template<>
inline void CBitVecT< CFixedBitVecBase<256> >::CopyTo(CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pInts = Base();

 pDest[0] = pInts[0];
 pDest[1] = pInts[1];
 pDest[2] = pInts[2];
 pDest[3] = pInts[3];
 pDest[4] = pInts[4];
 pDest[5] = pInts[5];
 pDest[6] = pInts[6];
 pDest[7] = pInts[7];
}

template<>
inline void CBitVecT< CFixedBitVecBase<128> >::And(const CBitVecT &addStr, CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = Base();
 const uint32 *pOperand2 = addStr.Base();

 pDest[0] = pOperand1[0] & pOperand2[0];
 pDest[1] = pOperand1[1] & pOperand2[1];
 pDest[2] = pOperand1[2] & pOperand2[2];
 pDest[3] = pOperand1[3] & pOperand2[3];
}

template<>
inline bool CBitVecT< CFixedBitVecBase<128> >::IsAllClear(void) const
{
 const uint32 *pInts = Base();
 return ( pInts[0] == 0 && pInts[1] == 0 && pInts[2] == 0 && pInts[3] == 0 );
}

template<>
inline void CBitVecT< CFixedBitVecBase<128> >::CopyTo(CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pInts = Base();

 pDest[0] = pInts[0];
 pDest[1] = pInts[1];
 pDest[2] = pInts[2];
 pDest[3] = pInts[3];
}

template<>
inline void CBitVecT< CFixedBitVecBase<96> >::And(const CBitVecT &addStr, CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = Base();
 const uint32 *pOperand2 = addStr.Base();

 pDest[0] = pOperand1[0] & pOperand2[0];
 pDest[1] = pOperand1[1] & pOperand2[1];
 pDest[2] = pOperand1[2] & pOperand2[2];
}

template<>
inline bool CBitVecT< CFixedBitVecBase<96> >::IsAllClear(void) const
{
 const uint32 *pInts = Base();
 return ( pInts[0] == 0 && pInts[1] == 0 && pInts[2] == 0 );
}

template<>
inline void CBitVecT< CFixedBitVecBase<96> >::CopyTo(CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pInts = Base();

 pDest[0] = pInts[0];
 pDest[1] = pInts[1];
 pDest[2] = pInts[2];
}

template<>
inline void CBitVecT< CFixedBitVecBase<64> >::And(const CBitVecT &addStr, CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = Base();
 const uint32 *pOperand2 = addStr.Base();

 pDest[0] = pOperand1[0] & pOperand2[0];
 pDest[1] = pOperand1[1] & pOperand2[1];
}

template<>
inline bool CBitVecT< CFixedBitVecBase<64> >::IsAllClear(void) const
{
 const uint32 *pInts = Base();
 return ( pInts[0] == 0 && pInts[1] == 0 );
}

template<>
inline void CBitVecT< CFixedBitVecBase<64> >::CopyTo(CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pInts = Base();

 pDest[0] = pInts[0];
 pDest[1] = pInts[1];
}

template<>
inline void CBitVecT< CFixedBitVecBase<32> >::And(const CBitVecT &addStr, CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pOperand1 = Base();
 const uint32 *pOperand2 = addStr.Base();

 pDest[0] = pOperand1[0] & pOperand2[0];
}

template<>
inline bool CBitVecT< CFixedBitVecBase<32> >::IsAllClear(void) const
{
 const uint32 *pInts = Base();

 return ( pInts[0] == 0 );
}

template<>
inline void CBitVecT< CFixedBitVecBase<32> >::CopyTo(CBitVecT *out) const
{
 uint32 * pDest = out->Base();
 const uint32 *pInts = Base();

 pDest[0] = pInts[0];
}



template <>
inline uint32 CBitVecT< CFixedBitVecBase<32> >::Get( uint32 bitNum ) const
{
 return ( *Base() & ( 1 << ( (bitNum) & (32 -1) ) ) );
}



template <>
inline bool CBitVecT< CFixedBitVecBase<32> >::IsBitSet( int bitNum ) const
{
 return ( ( *Base() & ( 1 << ( (bitNum) & (32 -1) ) ) ) != 0 );
}



template <>
inline void CBitVecT< CFixedBitVecBase<32> >::Set( int bitNum )
{
 *Base() |= ( 1 << ( (bitNum) & (32 -1) ) );
}



template <>
inline void CBitVecT< CFixedBitVecBase<32> >::Clear(int bitNum)
{
 *Base() &= ~( 1 << ( (bitNum) & (32 -1) ) );
}



template <>
inline void CBitVecT< CFixedBitVecBase<32> >::Set( int bitNum, bool bNewVal )
{
 uint32 bitMask = ( 1 << ( (bitNum) & (32 -1) ) );
 if ( bNewVal )
 {
  *Base() |= bitMask;
 }
 else
 {
  *Base() &= ~bitMask;
 }
}









inline void CVarBitVecBase::Resize( int resizeNumBits, bool bClearAll )
{
 ((void)0);

 int newIntCount = CalcNumIntsForBits( resizeNumBits );
 if ( newIntCount != GetNumDWords() )
 {
  if ( Base() )
  {
   ReallocInts( newIntCount );
   if ( !bClearAll && resizeNumBits >= GetNumBits() )
   {
    Base()[GetNumDWords() - 1] &= GetEndMask();
    memset( Base() + GetNumDWords(), 0, (newIntCount - GetNumDWords()) * sizeof(int) );
   }
  }
  else
  {

   AllocInts( newIntCount );

   bClearAll = true;
  }

  m_numInts = newIntCount;
 }
 else if ( !bClearAll && resizeNumBits >= GetNumBits() && Base() )
 {
  Base()[GetNumDWords() - 1] &= GetEndMask();
 }

 if ( bClearAll && Base() )
 {
  memset( Base(), 0, newIntCount * sizeof(int) );
 }


 m_numBits = resizeNumBits;
}





inline void CVarBitVecBase::AllocInts( int numInts )
{
 ((void)0);

 if ( numInts == 0 )
  return;

 if ( numInts == 1 )
 {
  m_pInt = &m_iBitStringStorage;
  return;
 }

 m_pInt = (uint32 *)malloc( numInts * sizeof(int) );
}






inline void CVarBitVecBase::ReallocInts( int numInts )
{
 ((void)0);
 if ( numInts == 0)
 {
  FreeInts();
  return;
 }

 if ( m_pInt == &m_iBitStringStorage )
 {
  if ( numInts != 1 )
  {
   m_pInt = ((uint32 *)malloc( numInts * sizeof(int) ));
   *m_pInt = m_iBitStringStorage;
  }

  return;
 }

 if ( numInts == 1 )
 {
  m_iBitStringStorage = *m_pInt;
  free( m_pInt );
  m_pInt = &m_iBitStringStorage;
  return;
 }

 m_pInt = (uint32 *)realloc( m_pInt, numInts * sizeof(int) );
}





inline void CVarBitVecBase::FreeInts( void )
{
 if ( m_numInts > 1 )
 {
  free( m_pInt );
 }
 m_pInt = 
         __null
             ;
}






inline CBitVecAccessor::CBitVecAccessor(uint32 *pDWords, int iBit)
{
 m_pDWords = pDWords;
 m_iBit = iBit;
}


inline void CBitVecAccessor::operator=(int val)
{
 if(val)
  m_pDWords[m_iBit >> 5] |= (1 << (m_iBit & 31));
 else
  m_pDWords[m_iBit >> 5] &= ~(unsigned long)(1 << (m_iBit & 31));
}

inline CBitVecAccessor::operator uint32()
{
 return m_pDWords[m_iBit >> 5] & (1 << (m_iBit & 31));
}

       








class CBaseEntity;
struct inputdata_t;



typedef enum _fieldtypes
{
 FIELD_VOID = 0,
 FIELD_FLOAT,
 FIELD_STRING,
 FIELD_VECTOR,
 FIELD_QUATERNION,
 FIELD_INTEGER,
 FIELD_BOOLEAN,
 FIELD_SHORT,
 FIELD_CHARACTER,
 FIELD_COLOR32,
 FIELD_EMBEDDED,
 FIELD_CUSTOM,

 FIELD_CLASSPTR,
 FIELD_EHANDLE,
 FIELD_EDICT,

 FIELD_POSITION_VECTOR,
 FIELD_TIME,
 FIELD_TICK,
 FIELD_MODELNAME,
 FIELD_SOUNDNAME,

 FIELD_INPUT,
 FIELD_FUNCTION,

 FIELD_VMATRIX,


 FIELD_VMATRIX_WORLDSPACE,
 FIELD_MATRIX3X4_WORLDSPACE,

 FIELD_INTERVAL,
 FIELD_MODELINDEX,
 FIELD_MATERIALINDEX,

 FIELD_VECTOR2D,
 FIELD_INTEGER64,


 FIELD_TYPECOUNT,
} fieldtype_t;





template <int FIELD_TYPE>
class CDatamapFieldSizeDeducer
{
public:
 enum
 {
  SIZE = 0
 };

 static int FieldSize( )
 {
  return 0;
 }
};






template< > class CDatamapFieldSizeDeducer<FIELD_FLOAT> { public: enum { SIZE = sizeof(float) }; static int FieldSize() { return sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_STRING> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_VECTOR> { public: enum { SIZE = 3 * sizeof(float) }; static int FieldSize() { return 3 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_VECTOR2D> { public: enum { SIZE = 2 * sizeof(float) }; static int FieldSize() { return 2 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_QUATERNION> { public: enum { SIZE = 4 * sizeof(float) }; static int FieldSize() { return 4 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_INTEGER> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_INTEGER64> { public: enum { SIZE = sizeof(int64) }; static int FieldSize() { return sizeof(int64); } };
template< > class CDatamapFieldSizeDeducer<FIELD_BOOLEAN> { public: enum { SIZE = sizeof(char) }; static int FieldSize() { return sizeof(char); } };
template< > class CDatamapFieldSizeDeducer<FIELD_SHORT> { public: enum { SIZE = sizeof(short) }; static int FieldSize() { return sizeof(short); } };
template< > class CDatamapFieldSizeDeducer<FIELD_CHARACTER> { public: enum { SIZE = sizeof(char) }; static int FieldSize() { return sizeof(char); } };
template< > class CDatamapFieldSizeDeducer<FIELD_COLOR32> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_CLASSPTR> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_EHANDLE> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_EDICT> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_POSITION_VECTOR> { public: enum { SIZE = 3 * sizeof(float) }; static int FieldSize() { return 3 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_TIME> { public: enum { SIZE = sizeof(float) }; static int FieldSize() { return sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_TICK> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_MODELNAME> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_SOUNDNAME> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_INPUT> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_FUNCTION> { public: enum { SIZE = sizeof(int *) }; static int FieldSize() { return sizeof(int *); } };
template< > class CDatamapFieldSizeDeducer<FIELD_VMATRIX> { public: enum { SIZE = 16 * sizeof(float) }; static int FieldSize() { return 16 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_VMATRIX_WORLDSPACE> { public: enum { SIZE = 16 * sizeof(float) }; static int FieldSize() { return 16 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_MATRIX3X4_WORLDSPACE> { public: enum { SIZE = 12 * sizeof(float) }; static int FieldSize() { return 12 * sizeof(float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_INTERVAL> { public: enum { SIZE = 2 * sizeof( float) }; static int FieldSize() { return 2 * sizeof( float); } };
template< > class CDatamapFieldSizeDeducer<FIELD_MODELINDEX> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
template< > class CDatamapFieldSizeDeducer<FIELD_MATERIALINDEX> { public: enum { SIZE = sizeof(int) }; static int FieldSize() { return sizeof(int); } };
class ISaveRestoreOps;
extern ISaveRestoreOps *eventFuncs;
struct typedescription_t;


class ISaveRestoreOps;




typedef void (CBaseEntity::*inputfunc_t)(inputdata_t &data);

struct datamap_t;
struct typedescription_t;

enum
{
 PC_NON_NETWORKED_ONLY = 0,
 PC_NETWORKED_ONLY,

 PC_COPYTYPE_COUNT,
 PC_EVERYTHING = PC_COPYTYPE_COUNT,
};

enum
{
 TD_OFFSET_NORMAL = 0,
 TD_OFFSET_PACKED = 1,


 TD_OFFSET_COUNT,
};

struct typedescription_t
{
 fieldtype_t fieldType;
 const char *fieldName;
 int fieldOffset;
 unsigned short fieldSize;
 short flags;

 const char *externalName;

 ISaveRestoreOps *pSaveRestoreOps;

 inputfunc_t inputFunc;

 datamap_t *td;


 int fieldSizeInBytes;


 struct typedescription_t *override_field;


 int override_count;


 float fieldTolerance;


 int flatOffset[ TD_OFFSET_COUNT ];
 unsigned short flatGroup;
};


struct optimized_datamap_t;





struct datamap_t
{
 typedescription_t *dataDesc;
 int dataNumFields;
 char const *dataClassName;
 datamap_t *baseMap;

 int m_nPackedSize;
 optimized_datamap_t *m_pOptimizedDataMap;




};
template <typename T>
inline void DataMapAccess(T *ignored, datamap_t **p)
{
 *p = &T::m_DataMap;
}



class CDatadescGeneratedNameHolder
{
public:
 CDatadescGeneratedNameHolder( const char *pszBase )
  : m_pszBase(pszBase)
 {
  m_nLenBase = strlen( m_pszBase );
 }

 ~CDatadescGeneratedNameHolder()
 {
  for ( int i = 0; i < m_Names.Count(); i++ )
  {
   delete m_Names[i];
  }
 }

 const char *GenerateName( const char *pszIdentifier )
 {
  char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];
  strcpy( pBuf, m_pszBase );
  strcat( pBuf, pszIdentifier );
  m_Names.AddToTail( pBuf );
  return pBuf;
 }

private:
 const char *m_pszBase;
 size_t m_nLenBase;
 CUtlVector<char *> m_Names;
};



const TableVector g_localBumpBasis[3] =
{
 { 0.81649661064147949f, 0.0f, 0.57735025882720947f },
 { -0.40824821591377258f, 0.70710676908493042f, 0.57735025882720947f },
 { -0.40824821591377258f, -0.70710676908493042f, 0.57735025882720947f }
};

void GetBumpNormals( const Vector& sVect, const Vector& tVect, const Vector& flatNormal,
      const Vector& phongNormal, Vector bumpNormals[3] );
struct CompressedLightCube
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 ColorRGBExp32 m_Color[6];
};
enum
{
 CHILDNODE_UPPER_RIGHT=0,
 CHILDNODE_UPPER_LEFT=1,
 CHILDNODE_LOWER_LEFT=2,
 CHILDNODE_LOWER_RIGHT=3
};



enum
{
 CORNER_LOWER_LEFT=0,
 CORNER_UPPER_LEFT=1,
 CORNER_UPPER_RIGHT=2,
 CORNER_LOWER_RIGHT=3
};



enum
{
 NEIGHBOREDGE_LEFT=0,
 NEIGHBOREDGE_TOP=1,
 NEIGHBOREDGE_RIGHT=2,
 NEIGHBOREDGE_BOTTOM=3
};





typedef enum
{
 CORNER_TO_CORNER=0,
 CORNER_TO_MIDPOINT=1,
 MIDPOINT_TO_CORNER=2
} NeighborSpan;



typedef enum
{
 ORIENTATION_CCW_0=0,
 ORIENTATION_CCW_90=1,
 ORIENTATION_CCW_180=2,
 ORIENTATION_CCW_270=3
} NeighborOrientation;




enum
{
 LUMP_ENTITIES = 0,
 LUMP_PLANES = 1,
 LUMP_TEXDATA = 2,
 LUMP_VERTEXES = 3,
 LUMP_VISIBILITY = 4,
 LUMP_NODES = 5,
 LUMP_TEXINFO = 6,
 LUMP_FACES = 7,
 LUMP_LIGHTING = 8,
 LUMP_OCCLUSION = 9,
 LUMP_LEAFS = 10,
 LUMP_FACEIDS = 11,
 LUMP_EDGES = 12,
 LUMP_SURFEDGES = 13,
 LUMP_MODELS = 14,
 LUMP_WORLDLIGHTS = 15,
 LUMP_LEAFFACES = 16,
 LUMP_LEAFBRUSHES = 17,
 LUMP_BRUSHES = 18,
 LUMP_BRUSHSIDES = 19,
 LUMP_AREAS = 20,
 LUMP_AREAPORTALS = 21,
 LUMP_UNUSED0 = 22,
 LUMP_UNUSED1 = 23,
 LUMP_UNUSED2 = 24,
 LUMP_UNUSED3 = 25,
 LUMP_DISPINFO = 26,
 LUMP_ORIGINALFACES = 27,
 LUMP_PHYSDISP = 28,
 LUMP_PHYSCOLLIDE = 29,
 LUMP_VERTNORMALS = 30,
 LUMP_VERTNORMALINDICES = 31,
 LUMP_DISP_LIGHTMAP_ALPHAS = 32,
 LUMP_DISP_VERTS = 33,
 LUMP_DISP_LIGHTMAP_SAMPLE_POSITIONS = 34,






 LUMP_GAME_LUMP = 35,
 LUMP_LEAFWATERDATA = 36,
 LUMP_PRIMITIVES = 37,
 LUMP_PRIMVERTS = 38,
 LUMP_PRIMINDICES = 39,



 LUMP_PAKFILE = 40,
 LUMP_CLIPPORTALVERTS = 41,


 LUMP_CUBEMAPS = 42,
 LUMP_TEXDATA_STRING_DATA = 43,
 LUMP_TEXDATA_STRING_TABLE = 44,
 LUMP_OVERLAYS = 45,
 LUMP_LEAFMINDISTTOWATER = 46,
 LUMP_FACE_MACRO_TEXTURE_INFO = 47,
 LUMP_DISP_TRIS = 48,
 LUMP_PHYSCOLLIDESURFACE = 49,
 LUMP_WATEROVERLAYS = 50,
 LUMP_LEAF_AMBIENT_INDEX_HDR = 51,
 LUMP_LEAF_AMBIENT_INDEX = 52,


 LUMP_LIGHTING_HDR = 53,
 LUMP_WORLDLIGHTS_HDR = 54,
 LUMP_LEAF_AMBIENT_LIGHTING_HDR = 55,
 LUMP_LEAF_AMBIENT_LIGHTING = 56,

 LUMP_XZIPPAKFILE = 57,
 LUMP_FACES_HDR = 58,
 LUMP_MAP_FLAGS = 59,
 LUMP_OVERLAY_FADES = 60,
};



enum
{
 LUMP_LIGHTING_VERSION = 1,
 LUMP_FACES_VERSION = 1,
 LUMP_OCCLUSION_VERSION = 2,
 LUMP_LEAFS_VERSION = 1,
 LUMP_LEAF_AMBIENT_LIGHTING_VERSION = 1,
};




#pragma pack(1)

struct ZIP_EndOfCentralDirRecord
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned int signature;
 unsigned short numberOfThisDisk;
 unsigned short numberOfTheDiskWithStartOfCentralDirectory;
 unsigned short nCentralDirectoryEntries_ThisDisk;
 unsigned short nCentralDirectoryEntries_Total;
 unsigned int centralDirectorySize;
 unsigned int startOfCentralDirOffset;
 unsigned short commentLength;

};

struct ZIP_FileHeader
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned int signature;
 unsigned short versionMadeBy;
 unsigned short versionNeededToExtract;
 unsigned short flags;
 unsigned short compressionMethod;
 unsigned short lastModifiedTime;
 unsigned short lastModifiedDate;
 unsigned int crc32;
 unsigned int compressedSize;
 unsigned int uncompressedSize;
 unsigned short fileNameLength;
 unsigned short extraFieldLength;
 unsigned short fileCommentLength;
 unsigned short diskNumberStart;
 unsigned short internalFileAttribs;
 unsigned int externalFileAttribs;
 unsigned int relativeOffsetOfLocalHeader;



};

struct ZIP_LocalFileHeader
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned int signature;
 unsigned short versionNeededToExtract;
 unsigned short flags;
 unsigned short compressionMethod;
 unsigned short lastModifiedTime;
 unsigned short lastModifiedDate;
 unsigned int crc32;
 unsigned int compressedSize;
 unsigned int uncompressedSize;
 unsigned short fileNameLength;
 unsigned short extraFieldLength;


};
struct ZIP_PreloadHeader
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned int Version;
 unsigned int DirectoryEntries;
 unsigned int PreloadDirectoryEntries;
 unsigned int Alignment;
};

struct ZIP_PreloadDirectoryEntry
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
    unsigned int Length;
    unsigned int DataOffset;
};

struct ZIP_PreloadRemapTable
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short PreloadIndex;
};

#pragma pack()

struct lump_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int fileofs, filelen;
 int version;
 char fourCC[4];
};


struct dheader_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int ident;
 int version;
 lump_t lumps[64];
 int mapRevision;
};





struct dflagslump_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 uint32 m_LevelFlags;
};

struct lumpfileheader_t
{
 int lumpOffset;
 int lumpID;
 int lumpVersion;
 int lumpLength;
 int mapRevision;
};

struct dgamelumpheader_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int lumpCount;


};


typedef int GameLumpId_t;






struct dgamelump_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 GameLumpId_t id;
 unsigned short flags;
 unsigned short version;
 int fileofs;
 int filelen;
};

extern int g_MapRevision;

struct dmodel_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector mins, maxs;
 Vector origin;
 int headnode;
 int firstface, numfaces;
};

struct dphysmodel_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);
 int modelIndex;
 int dataSize;
 int keydataSize;
 int solidCount;
};


struct dphysdisp_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);
 unsigned short numDisplacements;

};

struct dvertex_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector point;
};


struct dplane_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector normal;
 float dist;
 int type;
};





struct dnode_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int planenum;
 int children[2];
 short mins[3];
 short maxs[3];
 unsigned short firstface;
 unsigned short numfaces;
 short area;

};

typedef struct texinfo_s
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 float textureVecsTexelsPerWorldUnits[2][4];
 float lightmapVecsLuxelsPerWorldUnits[2][4];
 int flags;
 int texdata;
} texinfo_t;



struct dtexdata_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector reflectivity;
 int nameStringTableID;
 int width, height;
 int view_width, view_height;
};






enum
{
 OCCLUDER_FLAGS_INACTIVE = 0x1,
};

struct doccluderdata_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int flags;
 int firstpoly;
 int polycount;
 Vector mins;
 Vector maxs;
 int area;
};

struct doccluderdataV1_t
{
 int flags;
 int firstpoly;
 int polycount;
 Vector mins;
 Vector maxs;
};

struct doccluderpolydata_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int firstvertexindex;
 int vertexcount;
 int planenum;
};



struct CDispSubNeighbor
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short GetNeighborIndex() const { return m_iNeighbor; }
 NeighborSpan GetSpan() const { return (NeighborSpan)m_Span; }
 NeighborSpan GetNeighborSpan() const { return (NeighborSpan)m_NeighborSpan; }
 NeighborOrientation GetNeighborOrientation() const { return (NeighborOrientation)m_NeighborOrientation; }

 bool IsValid() const { return m_iNeighbor != 0xFFFF; }
 void SetInvalid() { m_iNeighbor = 0xFFFF; }


public:
 unsigned short m_iNeighbor;


 unsigned char m_NeighborOrientation;


 unsigned char m_Span;
 unsigned char m_NeighborSpan;
};



class CDispNeighbor
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 void SetInvalid() { m_SubNeighbors[0].SetInvalid(); m_SubNeighbors[1].SetInvalid(); }


 bool IsValid() { return m_SubNeighbors[0].IsValid() || m_SubNeighbors[1].IsValid(); }


public:


 CDispSubNeighbor m_SubNeighbors[2];
};


class CDispCornerNeighbors
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 void SetInvalid() { m_nNeighbors = 0; }


public:
 unsigned short m_Neighbors[4];
 unsigned char m_nNeighbors;
};


class CDispVert
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector m_vVector;
 float m_flDist;
 float m_flAlpha;
};







class CDispTri
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short m_uiTags;
};

class ddispinfo_t
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int NumVerts() const { return ( ((1 << (power)) + 1) * ((1 << (power)) + 1) ); }
 int NumTris() const { return ( (1 << (power)) * (1 << (power)) * 2 ); }

public:
 Vector startPosition;
 int m_iDispVertStart;
 int m_iDispTriStart;

    int power;
    int minTess;
    float smoothingAngle;
    int contents;

 unsigned short m_iMapFace;

 int m_iLightmapAlphaStart;


 int m_iLightmapSamplePositionStart;

 CDispNeighbor m_EdgeNeighbors[4];
 CDispCornerNeighbors m_CornerNeighbors[4];

 enum unnamed { ALLOWEDVERTS_SIZE = ( ((( ((1 << (4)) + 1) * ((1 << (4)) + 1) )) + ((32)-1)) / (32) ) * (32) / 32 };
 unsigned long m_AllowedVerts[ALLOWEDVERTS_SIZE];

};




struct dedge_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short v[2];
};



enum dprimitive_type
{
 PRIM_TRILIST=0,
 PRIM_TRISTRIP=1,
};

struct dprimitive_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned char type;
 unsigned short firstIndex;
 unsigned short indexCount;
 unsigned short firstVert;
 unsigned short vertCount;
};

struct dprimvert_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector pos;
};

struct dface_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short planenum;
 byte side;
 byte onNode;

 int firstedge;
 short numedges;
 short texinfo;






     short dispinfo;




  short surfaceFogVolumeID;



 byte styles[4];
 int lightofs;
    float area;


 int m_LightmapTextureMinsInLuxels[2];
 int m_LightmapTextureSizeInLuxels[2];

 int origFace;


public:

 unsigned short GetNumPrims() const;
 void SetNumPrims( unsigned short nPrims );
 bool AreDynamicShadowsEnabled();
 void SetDynamicShadowsEnabled( bool bEnabled );


private:
 unsigned short m_NumPrims;

public:
 unsigned short firstPrimID;

 unsigned int smoothingGroups;
};


inline unsigned short dface_t::GetNumPrims() const
{
 return m_NumPrims & 0x7FFF;
}

inline void dface_t::SetNumPrims( unsigned short nPrims )
{
 ((void)0);
 m_NumPrims &= ~0x7FFF;
 m_NumPrims |= (nPrims & 0x7FFF);
}

inline bool dface_t::AreDynamicShadowsEnabled()
{
 return (m_NumPrims & 0x8000) == 0;
}

inline void dface_t::SetDynamicShadowsEnabled( bool bEnabled )
{
 if ( bEnabled )
  m_NumPrims &= ~0x8000;
 else
  m_NumPrims |= 0x8000;
}

struct dfaceid_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short hammerfaceid;
};
struct dleaf_version_0_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int contents;

 short cluster;

 union { char bf; struct {;
 short area:9;
 short flags:7;
 }; };;

 short mins[3];
 short maxs[3];

 unsigned short firstleafface;
 unsigned short numleaffaces;

 unsigned short firstleafbrush;
 unsigned short numleafbrushes;
 short leafWaterDataID;


 CompressedLightCube m_AmbientLighting;
};


struct dleaf_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int contents;

 short cluster;

 union { char bf; struct {;
 short area:9;
 short flags:7;
 }; };;

 short mins[3];
 short maxs[3];

 unsigned short firstleafface;
 unsigned short numleaffaces;

 unsigned short firstleafbrush;
 unsigned short numleafbrushes;
 short leafWaterDataID;




};
struct dleafambientlighting_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 CompressedLightCube cube;
 byte x;
 byte y;
 byte z;
 byte pad;
};

struct dleafambientindex_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;

 unsigned short ambientSampleCount;
 unsigned short firstAmbientSample;
};

struct dbrushside_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short planenum;
 short texinfo;
 short dispinfo;
 short bevel;
};

struct dbrush_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int firstside;
 int numsides;
 int contents;
};
struct dvis_t
{
 int numclusters;
 int bitofs[8][2];
};




struct dareaportal_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 unsigned short m_PortalKey;



 unsigned short otherarea;

 unsigned short m_FirstClipPortalVert;
 unsigned short m_nClipPortalVerts;

 int planenum;
};


struct darea_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int numareaportals;
 int firstareaportal;
};

struct dleafwaterdata_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 float surfaceZ;
 float minZ;
 short surfaceTexInfoID;
};

class CFaceMacroTextureInfo
{
public:
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;


 unsigned short m_MacroTextureNameID;
};


enum emittype_t
{
 emit_surface,
 emit_point,
 emit_spotlight,
 emit_skylight,
 emit_quakelight,
 emit_skyambient,
};






struct dworldlight_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 Vector origin;
 Vector intensity;
 Vector normal;
 int cluster;
 emittype_t type;
    int style;
 float stopdot;
 float stopdot2;
 float exponent;
 float radius;


 float constant_attn;
 float linear_attn;
 float quadratic_attn;
 int flags;
 int texinfo;
 int owner;
};

struct dcubemapsample_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int origin[3];

 unsigned char size;

};







struct doverlay_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int nId;
 short nTexInfo;


 void SetFaceCount( unsigned short count );
 unsigned short GetFaceCount() const;

 void SetRenderOrder( unsigned short order );
 unsigned short GetRenderOrder() const;

private:
 unsigned short m_nFaceCountAndRenderOrder;

public:
 int aFaces[64];
 float flU[2];
 float flV[2];
 Vector vecUVPoints[4];
 Vector vecOrigin;
 Vector vecBasisNormal;
};


inline void doverlay_t::SetFaceCount( unsigned short count )
{
 ((void)0);
 m_nFaceCountAndRenderOrder &= 0xC000;
 m_nFaceCountAndRenderOrder |= (count & ~0xC000);
}

inline unsigned short doverlay_t::GetFaceCount() const
{
 return m_nFaceCountAndRenderOrder & ~0xC000;
}

inline void doverlay_t::SetRenderOrder( unsigned short order )
{
 ((void)0);
 m_nFaceCountAndRenderOrder &= ~0xC000;
 m_nFaceCountAndRenderOrder |= (order << (16 - 2));
}

inline unsigned short doverlay_t::GetRenderOrder() const
{
 return (m_nFaceCountAndRenderOrder >> (16 - 2));
}


struct doverlayfade_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;

 float flFadeDistMinSq;
 float flFadeDistMaxSq;
};






struct dwateroverlay_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 int nId;
 short nTexInfo;


 void SetFaceCount( unsigned short count );
 unsigned short GetFaceCount() const;
 void SetRenderOrder( unsigned short order );
 unsigned short GetRenderOrder() const;

private:

 unsigned short m_nFaceCountAndRenderOrder;

public:

 int aFaces[256];
 float flU[2];
 float flV[2];
 Vector vecUVPoints[4];
 Vector vecOrigin;
 Vector vecBasisNormal;
};

inline void dwateroverlay_t::SetFaceCount( unsigned short count )
{
 ((void)0);
 m_nFaceCountAndRenderOrder &= 0xC000;
 m_nFaceCountAndRenderOrder |= (count & ~0xC000);
}

inline unsigned short dwateroverlay_t::GetFaceCount() const
{
 return m_nFaceCountAndRenderOrder & ~0xC000;
}

inline void dwateroverlay_t::SetRenderOrder( unsigned short order )
{
 ((void)0);
 m_nFaceCountAndRenderOrder &= ~0xC000;
 m_nFaceCountAndRenderOrder |= ( order << ( 16 - 2 ) );
}

inline unsigned short dwateroverlay_t::GetRenderOrder() const
{
 return ( m_nFaceCountAndRenderOrder >> ( 16 - 2 ) );
}



typedef unsigned char byte;
typedef unsigned short word;
struct epair_t
{
 epair_t *next;
 char *key;
 char *value;
};




typedef struct nameForDatadesc_dlightmappage_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 byte data[256*128];
 byte palette[256*4];
} dlightmappage_t;

typedef struct nameForDatadesc_dlightmappageinfo_t
{
 static datamap_t m_DataMap; static datamap_t *GetBaseMap(); template <typename T> friend void DataMapAccess(T *, datamap_t **p); template <typename T> friend datamap_t *DataMapInit(T *);;
 byte page;
 byte offset[2];
 byte pad;
 ColorRGBExp32 avgColor;
} dlightmappageinfo_t;
class ServerClass;
class SendTable;
struct edict_t;
class CBaseEntity;
class CSerialEntity;
class CBaseNetworkable;


class CCheckTransmitInfo
{
public:
 edict_t *m_pClientEnt;
 byte m_PVS[( ((65536) + ((8)-1)) / (8) ) * (8) / 8];
 int m_nPVSSize;

 CBitVec<(1<<11)> *m_pTransmitEdict;
 CBitVec<(1<<11)> *m_pTransmitAlways;

 int m_AreasNetworked;
 int m_Areas[8];




 byte m_AreaFloodNums[256];
 int m_nMapAreas;
};




struct PVSInfo_t
{

 short m_nHeadNode;


 short m_nClusterCount;


 unsigned short *m_pClusters;


 short m_nAreaNum;
 short m_nAreaNum2;


 float m_vCenter[3];

private:
 unsigned short m_pClustersInline[4];

 friend class CVEngineServer;
};



class IServerNetworkable
{

public:

 virtual IHandleEntity *GetEntityHandle() = 0;


 virtual ServerClass* GetServerClass() = 0;

 virtual edict_t *GetEdict() const = 0;

 virtual const char* GetClassName() const = 0;
 virtual void Release() = 0;

 virtual int AreaNum() const = 0;


 virtual CBaseNetworkable* GetBaseNetworkable() = 0;
 virtual CBaseEntity* GetBaseEntity() = 0;
 virtual PVSInfo_t* GetPVSInfo() = 0;

protected:

 virtual ~IServerNetworkable() {}
};


struct edict_t;





enum MapLoadType_t
{
 MapLoad_NewGame = 0,
 MapLoad_LoadGame,
 MapLoad_Transition,
 MapLoad_Background,
};





class CGlobalVars : public CGlobalVarsBase
{
public:

 CGlobalVars( bool bIsClient );

public:


 string_t mapname;
 int mapversion;
 string_t startspot;
 MapLoadType_t eLoadType;
 bool bMapLoadFailed;


 bool deathmatch;
 bool coop;
 bool teamplay;

 int maxEntities;

 int serverCount;
 edict_t *pEdicts;
};

inline CGlobalVars::CGlobalVars( bool bIsClient ) :
 CGlobalVarsBase( bIsClient )
{
 serverCount = 0;
}


class CPlayerState;
class IServerNetworkable;
class IServerEntity;
class CEdictChangeInfo
{
public:

 unsigned short m_ChangeOffsets[19];
 unsigned short m_nChangeOffsets;
};


class CSharedEdictChangeInfo
{
public:
 CSharedEdictChangeInfo()
 {
  m_iSerialNumber = 1;
 }



 unsigned short m_iSerialNumber;





};
extern CSharedEdictChangeInfo *g_pSharedChangeInfo;

class IChangeInfoAccessor
{
public:
 inline void SetChangeInfo( unsigned short info )
 {
  m_iChangeInfo = info;
 }

 inline void SetChangeInfoSerialNumber( unsigned short sn )
 {
  m_iChangeInfoSerialNumber = sn;
 }

 inline unsigned short GetChangeInfo() const
 {
  return m_iChangeInfo;
 }

 inline unsigned short GetChangeInfoSerialNumber() const
 {
  return m_iChangeInfoSerialNumber;
 }

private:
 unsigned short m_iChangeInfo;
 unsigned short m_iChangeInfoSerialNumber;
};





class CBaseEdict
{
public:



 IServerEntity* GetIServerEntity();
 const IServerEntity* GetIServerEntity() const;

 IServerNetworkable* GetNetworkable();
 IServerUnknown* GetUnknown();


 void SetEdict( IServerUnknown *pUnk, bool bFullEdict );

 int AreaNum() const;
 const char * GetClassName() const;

 bool IsFree() const;
 void SetFree();
 void ClearFree();

 bool HasStateChanged() const;
 void ClearStateChanged();
 void StateChanged();
 void StateChanged( unsigned short offset );

 void ClearTransmitState();

 void SetChangeInfo( unsigned short info );
 void SetChangeInfoSerialNumber( unsigned short sn );
 unsigned short GetChangeInfo() const;
 unsigned short GetChangeInfoSerialNumber() const;

public:






 int m_fStateFlags;



 int m_NetworkSerialNumber;


 IServerNetworkable *m_pNetworkable;

protected:
 IServerUnknown *m_pUnk;


public:

 IChangeInfoAccessor *GetChangeAccessor();
 const IChangeInfoAccessor *GetChangeAccessor() const;
 friend void InitializeEntityDLLFields( edict_t *pEdict );
};





inline IServerEntity* CBaseEdict::GetIServerEntity()
{
 if ( m_fStateFlags & (1<<2) )
  return (IServerEntity*)m_pUnk;
 else
  return 0;
}

inline bool CBaseEdict::IsFree() const
{
 return (m_fStateFlags & (1<<1)) != 0;
}



inline bool CBaseEdict::HasStateChanged() const
{
 return (m_fStateFlags & (1<<0)) != 0;
}

inline void CBaseEdict::ClearStateChanged()
{
 m_fStateFlags &= ~((1<<0) | (1<<8));
 SetChangeInfoSerialNumber( 0 );
}

inline void CBaseEdict::StateChanged()
{


 m_fStateFlags |= ((1<<0) | (1<<8));
 SetChangeInfoSerialNumber( 0 );
}

inline void CBaseEdict::StateChanged( unsigned short offset )
{
 StateChanged();

}



inline void CBaseEdict::SetFree()
{
 m_fStateFlags |= (1<<1);
}

inline void CBaseEdict::ClearFree()
{
 m_fStateFlags &= ~(1<<1);
}

inline void CBaseEdict::ClearTransmitState()
{
 m_fStateFlags &= ~((1<<3)|(1<<5)|(1<<4));
}

inline const IServerEntity* CBaseEdict::GetIServerEntity() const
{
 if ( m_fStateFlags & (1<<2) )
  return (IServerEntity*)m_pUnk;
 else
  return 0;
}

inline IServerUnknown* CBaseEdict::GetUnknown()
{
 return m_pUnk;
}

inline IServerNetworkable* CBaseEdict::GetNetworkable()
{
 return m_pNetworkable;
}

inline void CBaseEdict::SetEdict( IServerUnknown *pUnk, bool bFullEdict )
{
 m_pUnk = pUnk;
 if ( (pUnk != 
              __null
                  ) && bFullEdict )
 {
  m_fStateFlags = (1<<2);
 }
 else
 {
  m_fStateFlags = 0;
 }
}

inline int CBaseEdict::AreaNum() const
{
 if ( !m_pUnk )
  return 0;

 return m_pNetworkable->AreaNum();
}

inline const char * CBaseEdict::GetClassName() const
{
 if ( !m_pUnk )
  return "";
 return m_pNetworkable->GetClassName();
}

inline void CBaseEdict::SetChangeInfo( unsigned short info )
{
 GetChangeAccessor()->SetChangeInfo( info );
}

inline void CBaseEdict::SetChangeInfoSerialNumber( unsigned short sn )
{
 GetChangeAccessor()->SetChangeInfoSerialNumber( sn );
}

inline unsigned short CBaseEdict::GetChangeInfo() const
{
 return GetChangeAccessor()->GetChangeInfo();
}

inline unsigned short CBaseEdict::GetChangeInfoSerialNumber() const
{
 return GetChangeAccessor()->GetChangeInfoSerialNumber();
}






struct edict_t : public CBaseEdict
{
public:
 ICollideable *GetCollideable();
};

inline ICollideable *edict_t::GetCollideable()
{
 IServerEntity *pEnt = GetIServerEntity();
 if ( pEnt )
  return pEnt->GetCollideable();
 else
  return 
        __null
            ;
}
typedef int SideType;
class VPlane
{
public:
    VPlane();
    VPlane(const Vector &vNormal, vec_t dist);

 void Init(const Vector &vNormal, vec_t dist);


 vec_t DistTo(const Vector &vVec) const;


 VPlane& operator=(const VPlane &thePlane);



 SideType GetPointSide(const Vector &vPoint, vec_t sideEpsilon=0.01f) const;


 SideType GetPointSideExact(const Vector &vPoint) const;



 SideType BoxOnPlaneSide(const Vector &vMin, const Vector &vMax) const;



 VPlane Flip();


 Vector GetPointOnPlane() const;


 Vector SnapPointToPlane(const Vector &vPoint) const;


public:
 Vector m_Normal;
 vec_t m_Dist;






};





inline VPlane::VPlane()
{
}

inline VPlane::VPlane(const Vector &vNormal, vec_t dist)
{
 m_Normal = vNormal;
 m_Dist = dist;
}

inline void VPlane::Init(const Vector &vNormal, vec_t dist)
{
 m_Normal = vNormal;
 m_Dist = dist;
}

inline vec_t VPlane::DistTo(const Vector &vVec) const
{
 return vVec.Dot(m_Normal) - m_Dist;
}

inline VPlane& VPlane::operator=(const VPlane &thePlane)
{
 m_Normal = thePlane.m_Normal;
 m_Dist = thePlane.m_Dist;
 return *this;
}



inline VPlane VPlane::Flip()
{
 return VPlane(-m_Normal, -m_Dist);
}

inline Vector VPlane::GetPointOnPlane() const
{
 return m_Normal * m_Dist;
}

inline Vector VPlane::SnapPointToPlane(const Vector &vPoint) const
{
 return vPoint - m_Normal * DistTo(vPoint);
}



inline SideType VPlane::GetPointSide(const Vector &vPoint, vec_t sideEpsilon) const
{
 vec_t fDist;

 fDist = DistTo(vPoint);
 if(fDist >= sideEpsilon)
  return 0;
 else if(fDist <= -sideEpsilon)
  return 1;
 else
  return 2;
}

inline SideType VPlane::GetPointSideExact(const Vector &vPoint) const
{
 return DistTo(vPoint) > 0.0f ? 0 : 1;
}





inline SideType VPlane::BoxOnPlaneSide(const Vector &vMin, const Vector &vMax) const
{
 int i, firstSide, side;
 TableVector vPoints[8] =
 {
  { vMin.x, vMin.y, vMin.z },
  { vMin.x, vMin.y, vMax.z },
  { vMin.x, vMax.y, vMax.z },
  { vMin.x, vMax.y, vMin.z },

  { vMax.x, vMin.y, vMin.z },
  { vMax.x, vMin.y, vMax.z },
  { vMax.x, vMax.y, vMax.z },
  { vMax.x, vMax.y, vMin.z },
 };

 firstSide = GetPointSideExact(vPoints[0]);
 for(i=1; i < 8; i++)
 {
  side = GetPointSideExact(vPoints[i]);


  if(side != firstSide)
   return 2;
 }


 return firstSide;
}

class IMaterial;
class KeyValues;
struct vcollide_t;
struct model_t;
class Vector;
class QAngle;
class CGameTrace;
struct cplane_t;
typedef CGameTrace trace_t;
struct studiohdr_t;
struct virtualmodel_t;
typedef unsigned char byte;
struct virtualterrainparams_t;
class CPhysCollide;
typedef unsigned short MDLHandle_t;
class CUtlBuffer;
class IClientRenderable;





enum RenderableTranslucencyType_t
{
 RENDERABLE_IS_OPAQUE = 0,
 RENDERABLE_IS_TRANSLUCENT,
 RENDERABLE_IS_TWO_PASS,
};
class IVModelInfo
{
public:
 virtual ~IVModelInfo( void ) { }

 virtual const model_t *GetModel( int modelindex ) const = 0;

 virtual int GetModelIndex( const char *name ) const = 0;


 virtual const char *GetModelName( const model_t *model ) const = 0;
 virtual vcollide_t *GetVCollide( const model_t *model ) const = 0;
 virtual vcollide_t *GetVCollide( int modelindex ) const = 0;
 virtual void GetModelBounds( const model_t *model, Vector& mins, Vector& maxs ) const = 0;
 virtual void GetModelRenderBounds( const model_t *model, Vector& mins, Vector& maxs ) const = 0;
 virtual int GetModelFrameCount( const model_t *model ) const = 0;
 virtual int GetModelType( const model_t *model ) const = 0;
 virtual void *GetModelExtraData( const model_t *model ) = 0;
 virtual bool ModelHasMaterialProxy( const model_t *model ) const = 0;
 virtual bool IsTranslucent( model_t const* model ) const = 0;
 virtual bool IsTranslucentTwoPass( const model_t *model ) const = 0;
 virtual void Unused0() {};
 virtual RenderableTranslucencyType_t ComputeTranslucencyType( const model_t *model, int nSkin, int nBody ) = 0;
 virtual int GetModelMaterialCount( const model_t* model ) const = 0;
 virtual void GetModelMaterials( const model_t *model, int count, IMaterial** ppMaterial ) = 0;
 virtual bool IsModelVertexLit( const model_t *model ) const = 0;
 virtual const char *GetModelKeyValueText( const model_t *model ) = 0;
 virtual bool GetModelKeyValue( const model_t *model, CUtlBuffer &buf ) = 0;
 virtual float GetModelRadius( const model_t *model ) = 0;

 virtual const studiohdr_t *FindModel( const studiohdr_t *pStudioHdr, void **cache, const char *modelname ) const = 0;
 virtual const studiohdr_t *FindModel( void *cache ) const = 0;
 virtual virtualmodel_t *GetVirtualModel( const studiohdr_t *pStudioHdr ) const = 0;
 virtual byte *GetAnimBlock( const studiohdr_t *pStudioHdr, int iBlock ) const = 0;


 virtual void GetModelMaterialColorAndLighting( const model_t *model, Vector const& origin,
          QAngle const& angles, trace_t* pTrace,
          Vector& lighting, Vector& matColor ) = 0;
 virtual void GetIlluminationPoint( const model_t *model, IClientRenderable *pRenderable, Vector const& origin,
          QAngle const& angles, Vector* pLightingCenter ) = 0;

 virtual int GetModelContents( int modelIndex ) const = 0;
 virtual studiohdr_t *GetStudiomodel( const model_t *mod ) = 0;
 virtual int GetModelSpriteWidth( const model_t *model ) const = 0;
 virtual int GetModelSpriteHeight( const model_t *model ) const = 0;


 virtual void SetLevelScreenFadeRange( float flMinSize, float flMaxSize ) = 0;
 virtual void GetLevelScreenFadeRange( float *pMinArea, float *pMaxArea ) const = 0;


 virtual void SetViewScreenFadeRange( float flMinSize, float flMaxSize ) = 0;


 virtual unsigned char ComputeLevelScreenFade( const Vector &vecAbsOrigin, float flRadius, float flFadeScale ) const = 0;
 virtual unsigned char ComputeViewScreenFade( const Vector &vecAbsOrigin, float flRadius, float flFadeScale ) const = 0;


 virtual int GetAutoplayList( const studiohdr_t *pStudioHdr, unsigned short **pAutoplayList ) const = 0;



 virtual CPhysCollide *GetCollideForVirtualTerrain( int index ) = 0;

 virtual bool IsUsingFBTexture( const model_t *model, int nSkin, int nBody, void *pClientRenderable ) const = 0;

 virtual const model_t *FindOrLoadModel( const char *name ) const = 0;

 virtual MDLHandle_t GetCacheHandle( const model_t *model ) const = 0;


 virtual int GetBrushModelPlaneCount( const model_t *model ) const = 0;
 virtual void GetBrushModelPlane( const model_t *model, int nIndex, cplane_t &plane, Vector *pOrigin ) const = 0;
 virtual int GetSurfacepropsForVirtualTerrain( int index ) = 0;
 virtual bool UsesEnvCubemap( const model_t *model ) const = 0;
 virtual bool UsesStaticLighting( const model_t *model ) const = 0;
};


class IVModelInfoClient : public IVModelInfo
{
public:
};


struct virtualterrainparams_t
{

 int index;
};
enum
{
 CHAN_REPLACE = -1,
 CHAN_AUTO = 0,
 CHAN_WEAPON = 1,
 CHAN_VOICE = 2,
 CHAN_ITEM = 3,
 CHAN_BODY = 4,
 CHAN_STREAM = 5,
 CHAN_STATIC = 6,
 CHAN_VOICE_BASE = 7,
 CHAN_USER_BASE = (CHAN_VOICE_BASE+128)
};
enum soundlevel_t
{
 SNDLVL_NONE = 0,

 SNDLVL_20dB = 20,
 SNDLVL_25dB = 25,
 SNDLVL_30dB = 30,
 SNDLVL_35dB = 35,
 SNDLVL_40dB = 40,
 SNDLVL_45dB = 45,

 SNDLVL_50dB = 50,
 SNDLVL_55dB = 55,

 SNDLVL_IDLE = 60,
 SNDLVL_60dB = 60,

 SNDLVL_65dB = 65,
 SNDLVL_STATIC = 66,

 SNDLVL_70dB = 70,

 SNDLVL_NORM = 75,
 SNDLVL_75dB = 75,

 SNDLVL_80dB = 80,
 SNDLVL_TALKING = 80,
 SNDLVL_85dB = 85,
 SNDLVL_90dB = 90,
 SNDLVL_95dB = 95,
 SNDLVL_100dB = 100,
 SNDLVL_105dB = 105,
 SNDLVL_110dB = 110,
 SNDLVL_120dB = 120,
 SNDLVL_130dB = 130,

 SNDLVL_GUNFIRE = 140,
 SNDLVL_140dB = 140,

 SNDLVL_150dB = 150,

 SNDLVL_180dB = 180,



};
enum SoundFlags_t
{
 SND_NOFLAGS = 0,
 SND_CHANGE_VOL = (1<<0),
 SND_CHANGE_PITCH = (1<<1),
 SND_STOP = (1<<2),
 SND_SPAWNING = (1<<3),

 SND_DELAY = (1<<4),
 SND_STOP_LOOPING = (1<<5),
 SND_SPEAKER = (1<<6),

 SND_SHOULDPAUSE = (1<<7),
 SND_IGNORE_PHONEMES = (1<<8),
 SND_IGNORE_NAME = (1<<9),
};




class IBaseFileSystem;
class CUtlBuffer;
class Color;
typedef void * FileHandle_t;
class KeyValues
{
public:
 KeyValues( const char *setName );
 class AutoDelete
 {
 public:
  explicit inline AutoDelete( KeyValues *pKeyValues ) : m_pKeyValues( pKeyValues ) {}
  inline ~AutoDelete( void ) { if( m_pKeyValues ) m_pKeyValues->deleteThis(); }
  inline void Assign( KeyValues *pKeyValues ) { m_pKeyValues = pKeyValues; }
 private:
  AutoDelete( AutoDelete const &x );
  AutoDelete & operator= ( AutoDelete const &x );
  KeyValues *m_pKeyValues;
 };


 KeyValues( const char *setName, const char *firstKey, const char *firstValue );
 KeyValues( const char *setName, const char *firstKey, const wchar_t *firstValue );
 KeyValues( const char *setName, const char *firstKey, int firstValue );
 KeyValues( const char *setName, const char *firstKey, const char *firstValue, const char *secondKey, const char *secondValue );
 KeyValues( const char *setName, const char *firstKey, int firstValue, const char *secondKey, int secondValue );


 const char *GetName() const;
 void SetName( const char *setName);


 int GetNameSymbol() const;


 void UsesEscapeSequences(bool state);
 bool LoadFromFile( IBaseFileSystem *filesystem, const char *resourceName, const char *pathID = 
                                                                                               __null 
                                                                                                    );
 bool SaveToFile( IBaseFileSystem *filesystem, const char *resourceName, const char *pathID = 
                                                                                             __null
                                                                                                 );


 bool LoadFromBuffer( char const *resourceName, const char *pBuffer, IBaseFileSystem* pFileSystem = 
                                                                                                   __null
                                                                                                       , const char *pPathID = 
                                                                                                                               __null 
                                                                                                                                    );


 bool LoadFromBuffer( char const *resourceName, CUtlBuffer &buf, IBaseFileSystem* pFileSystem = 
                                                                                               __null
                                                                                                   , const char *pPathID = 
                                                                                                                           __null 
                                                                                                                                );



 KeyValues *FindKey(const char *keyName, bool bCreate = false);
 KeyValues *FindKey(int keySymbol) const;
 KeyValues *CreateNewKey();
 void AddSubKey( KeyValues *pSubkey );
 void RemoveSubKey(KeyValues *subKey);






 KeyValues *GetFirstSubKey();
 KeyValues *GetNextKey();
 void SetNextKey( KeyValues * pDat);
 KeyValues* GetFirstTrueSubKey();
 KeyValues* GetNextTrueSubKey();

 KeyValues* GetFirstValue();
 KeyValues* GetNextValue();



 int GetInt( const char *keyName = 
                                    __null
                                        , int defaultValue = 0 );
 uint64 GetUint64( const char *keyName = 
                                        __null
                                            , uint64 defaultValue = 0 );
 float GetFloat( const char *keyName = 
                                      __null
                                          , float defaultValue = 0.0f );
 const char *GetString( const char *keyName = 
                                             __null
                                                 , const char *defaultValue = "" );
 const wchar_t *GetWString( const char *keyName = 
                                                 __null
                                                     , const wchar_t *defaultValue = L"" );
 void *GetPtr( const char *keyName = 
                                    __null
                                        , void *defaultValue = (void*)0 );
 Color GetColor( const char *keyName = 
                                      __null 
                                                                           );
 bool IsEmpty(const char *keyName = 
                                    __null
                                        );


 int GetInt( int keySymbol, int defaultValue = 0 );
 float GetFloat( int keySymbol, float defaultValue = 0.0f );
 const char *GetString( int keySymbol, const char *defaultValue = "" );
 const wchar_t *GetWString( int keySymbol, const wchar_t *defaultValue = L"" );
 void *GetPtr( int keySymbol, void *defaultValue = (void*)0 );
 Color GetColor( int keySymbol );
 bool IsEmpty( int keySymbol );


 void SetWString( const char *keyName, const wchar_t *value );
 void SetString( const char *keyName, const char *value );
 void SetInt( const char *keyName, int value );
 void SetUint64( const char *keyName, uint64 value );
 void SetFloat( const char *keyName, float value );
 void SetPtr( const char *keyName, void *value );
 void SetColor( const char *keyName, Color value);


 void *operator new( size_t iAllocSize );
 void *operator new( size_t iAllocSize, int nBlockUse, const char *pFileName, int nLine );
 void operator delete( void *pMem );
 void operator delete( void *pMem, int nBlockUse, const char *pFileName, int nLine );

 KeyValues& operator=( KeyValues& src );



 void ChainKeyValue( KeyValues* pChain );

 void RecursiveSaveToFile( CUtlBuffer& buf, int indentLevel );

 bool WriteAsBinary( CUtlBuffer &buffer );
 bool ReadAsBinary( CUtlBuffer &buffer );


 KeyValues *MakeCopy( void ) const;


 void CopySubkeys( KeyValues *pParent ) const;


 void Clear( void );


 enum types_t
 {
  TYPE_NONE = 0,
  TYPE_STRING,
  TYPE_INT,
  TYPE_FLOAT,
  TYPE_PTR,
  TYPE_WSTRING,
  TYPE_COLOR,
  TYPE_UINT64,
  TYPE_NUMTYPES,
 };
 types_t GetDataType(const char *keyName = 
                                          __null
                                              );


 void deleteThis();

 void SetStringValue( char const *strValue );


 void UnpackIntoStructure( struct KeyValuesUnpackStructure const *pUnpackTable, void *pDest );


 bool ProcessResolutionKeys( const char *pResString );

private:
 KeyValues( KeyValues& );


 ~KeyValues();

 KeyValues* CreateKey( const char *keyName );

 void RecursiveCopyKeyValues( KeyValues& src );
 void RemoveEverything();





 void RecursiveSaveToFile( IBaseFileSystem *filesystem, FileHandle_t f, CUtlBuffer *pBuf, int indentLevel );
 void WriteConvertedString( IBaseFileSystem *filesystem, FileHandle_t f, CUtlBuffer *pBuf, const char *pszString );

 void RecursiveLoadFromBuffer( char const *resourceName, CUtlBuffer &buf );


 void AppendIncludedKeys( CUtlVector< KeyValues * >& includedKeys );
 void ParseIncludedKeys( char const *resourceName, const char *filetoinclude,
  IBaseFileSystem* pFileSystem, const char *pPathID, CUtlVector< KeyValues * >& includedKeys );


 void MergeBaseKeys( CUtlVector< KeyValues * >& baseKeys );
 void RecursiveMergeKeyValues( KeyValues *baseKV );



 void InternalWrite( IBaseFileSystem *filesystem, FileHandle_t f, CUtlBuffer *pBuf, const void *pData, int len );

 void Init();
 const char * ReadToken( CUtlBuffer &buf, bool &wasQuoted, bool &wasConditional );
 void WriteIndents( IBaseFileSystem *filesystem, FileHandle_t f, CUtlBuffer *pBuf, int indentLevel );

 void FreeAllocatedValue();
 void AllocateValueBlock(int size);

 int m_iKeyName;


 char *m_sValue;
 wchar_t *m_wsValue;


 union
 {
  int m_iValue;
  float m_flValue;
  void *m_pValue;
  unsigned char m_Color[4];
 };

 char m_iDataType;
 char m_bHasEscapeSequences;
 char unused[2];

 KeyValues *m_pPeer;
 KeyValues *m_pSub;
 KeyValues *m_pChain;
};

enum KeyValuesUnpackDestinationTypes_t
{
 UNPACK_TYPE_FLOAT,
 UNPACK_TYPE_VECTOR,
 UNPACK_TYPE_VECTOR_COLOR,
 UNPACK_TYPE_STRING,
 UNPACK_TYPE_INT,
 UNPACK_TYPE_FOUR_FLOATS,
 UNPACK_TYPE_TWO_FLOATS,
};





struct KeyValuesUnpackStructure
{
 char const *m_pKeyName;
 char const *m_pKeyDefault;
 KeyValuesUnpackDestinationTypes_t m_eDataType;
 size_t m_nFieldOffset;
 size_t m_nFieldSize;
};




inline int KeyValues::GetInt( int keySymbol, int defaultValue )
{
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->GetInt( (const char *)
                                        __null
                                            , defaultValue ) : defaultValue;
}

inline float KeyValues::GetFloat( int keySymbol, float defaultValue )
{
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->GetFloat( (const char *)
                                          __null
                                              , defaultValue ) : defaultValue;
}

inline const char *KeyValues::GetString( int keySymbol, const char *defaultValue )
{
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->GetString( (const char *)
                                           __null
                                               , defaultValue ) : defaultValue;
}

inline const wchar_t *KeyValues::GetWString( int keySymbol, const wchar_t *defaultValue )
{
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->GetWString( (const char *)
                                            __null
                                                , defaultValue ) : defaultValue;
}

inline void *KeyValues::GetPtr( int keySymbol, void *defaultValue )
{
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->GetPtr( (const char *)
                                        __null
                                            , defaultValue ) : defaultValue;
}

inline Color KeyValues::GetColor( int keySymbol )
{
 Color defaultValue( 0, 0, 0, 0 );
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->GetColor( ) : defaultValue;
}

inline bool KeyValues::IsEmpty( int keySymbol )
{
 KeyValues *dat = FindKey( keySymbol );
 return dat ? dat->IsEmpty( ) : true;
}

bool EvaluateConditional( const char *str );

class CCommand;





typedef enum
{
 PLUGIN_CONTINUE = 0,
 PLUGIN_OVERRIDE,
 PLUGIN_STOP,
} PLUGIN_RESULT;


typedef enum
{
 eQueryCvarValueStatus_ValueIntact=0,
 eQueryCvarValueStatus_CvarNotFound=1,
 eQueryCvarValueStatus_NotACvar=2,
 eQueryCvarValueStatus_CvarProtected=3
} EQueryCvarValueStatus;


typedef int QueryCvarCookie_t;
class IServerPluginCallbacks
{
public:


 virtual bool Load( CreateInterfaceFn interfaceFactory, CreateInterfaceFn gameServerFactory ) = 0;


 virtual void Unload( void ) = 0;


 virtual void Pause( void ) = 0;


 virtual void UnPause( void ) = 0;


 virtual const char *GetPluginDescription( void ) = 0;


 virtual void LevelInit( char const *pMapName ) = 0;


 virtual void ServerActivate( edict_t *pEdictList, int edictCount, int clientMax ) = 0;


 virtual void GameFrame( bool simulating ) = 0;


 virtual void LevelShutdown( void ) = 0;


 virtual void ClientActive( edict_t *pEntity ) = 0;


 virtual void ClientDisconnect( edict_t *pEntity ) = 0;


 virtual void ClientPutInServer( edict_t *pEntity, char const *playername ) = 0;


 virtual void SetCommandClient( int index ) = 0;


 virtual void ClientSettingsChanged( edict_t *pEdict ) = 0;



 virtual PLUGIN_RESULT ClientConnect( bool *bAllowConnect, edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen ) = 0;


 virtual PLUGIN_RESULT ClientCommand( edict_t *pEntity, const CCommand &args ) = 0;


 virtual PLUGIN_RESULT NetworkIDValidated( const char *pszUserName, const char *pszNetworkID ) = 0;




 virtual void OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue ) = 0;

};




typedef enum
{
 DIALOG_MSG = 0,
 DIALOG_MENU,
 DIALOG_TEXT,
 DIALOG_ENTRY,
 DIALOG_ASKCONNECT
} DIALOG_TYPE;




class IServerPluginHelpers
{
public:
 virtual void CreateMessage( edict_t *pEntity, DIALOG_TYPE type, KeyValues *data, IServerPluginCallbacks *plugin ) = 0;
 virtual void ClientCommand( edict_t *pEntity, const char *cmd ) = 0;
 virtual QueryCvarCookie_t StartQueryCvarValue( edict_t *pEntity, const char *pName ) = 0;
};
class Vector;
class QAngle;
typedef enum
{
 BITBUFERROR_VALUE_OUT_OF_RANGE=0,
 BITBUFERROR_BUFFER_OVERRUN,

 BITBUFERROR_NUM_ERRORS
} BitBufErrorType;


typedef void (*BitBufErrorHandler)( BitBufErrorType errorType, const char *pDebugName );
void SetBitBufErrorHandler( BitBufErrorHandler fn );






inline int BitByte( int bits )
{

 return (bits + 7) >> 3;
}





class old_bf_write
{
public:
 old_bf_write();



 old_bf_write( void *pData, int nBytes, int nMaxBits = -1 );
 old_bf_write( const char *pDebugName, void *pData, int nBytes, int nMaxBits = -1 );




 void StartWriting( void *pData, int nBytes, int iStartBit = 0, int nMaxBits = -1 );


 void Reset();


 unsigned char* GetBasePointer() { return m_pData; }



 void SetAssertOnOverflow( bool bAssert );


 const char* GetDebugName();
 void SetDebugName( const char *pDebugName );



public:

 void SeekToBit( int bitPos );



public:

 void WriteOneBit(int nValue);
 void WriteOneBitNoCheck(int nValue);
 void WriteOneBitAt( int iBit, int nValue );


 void WriteUBitLong( unsigned int data, int numbits, bool bCheckRange=true );
 void WriteSBitLong( int data, int numbits );



 void WriteBitLong(unsigned int data, int numbits, bool bSigned);


 bool WriteBits(const void *pIn, int nBits);


 void WriteUBitVar( unsigned int data );



 bool WriteBitsFromBuffer( class bf_read *pIn, int nBits );

 void WriteBitAngle( float fAngle, int numbits );
 void WriteBitCoord (const float f);
 void WriteBitCoordMP( const float f, bool bIntegral, bool bLowPrecision );
 void WriteBitFloat(float val);
 void WriteBitVec3Coord( const Vector& fa );
 void WriteBitNormal( float f );
 void WriteBitVec3Normal( const Vector& fa );
 void WriteBitAngles( const QAngle& fa );



public:

 void WriteChar(int val);
 void WriteByte(int val);
 void WriteShort(int val);
 void WriteWord(int val);
 void WriteLong(long val);
 void WriteLongLong(int64 val);
 void WriteFloat(float val);
 bool WriteBytes( const void *pBuf, int nBytes );


 bool WriteString(const char *pStr);



public:


 int GetNumBytesWritten();
 int GetNumBitsWritten();
 int GetMaxNumBits();
 int GetNumBitsLeft();
 int GetNumBytesLeft();
 unsigned char* GetData();


 bool CheckForOverflow(int nBits);
 inline bool IsOverflowed() const {return m_bOverflow;}

 inline void SetOverflowFlag();


public:

 unsigned char* m_pData;
 int m_nDataBytes;
 int m_nDataBits;


 int m_iCurBit;

private:


 bool m_bOverflow;

 bool m_bAssertOnOverflow;
 const char *m_pDebugName;
};







inline int old_bf_write::GetNumBytesWritten()
{
 return BitByte(m_iCurBit);
}

inline int old_bf_write::GetNumBitsWritten()
{
 return m_iCurBit;
}

inline int old_bf_write::GetMaxNumBits()
{
 return m_nDataBits;
}

inline int old_bf_write::GetNumBitsLeft()
{
 return m_nDataBits - m_iCurBit;
}

inline int old_bf_write::GetNumBytesLeft()
{
 return GetNumBitsLeft() >> 3;
}

inline unsigned char* old_bf_write::GetData()
{
 return m_pData;
}

inline bool old_bf_write::CheckForOverflow(int nBits)
{
 if ( m_iCurBit + nBits > m_nDataBits )
 {
  SetOverflowFlag();
  ;
 }

 return m_bOverflow;
}

inline void old_bf_write::SetOverflowFlag()
{
 if ( m_bAssertOnOverflow )
 {
  ((void)0);
 }

 m_bOverflow = true;
}

inline void old_bf_write::WriteOneBitNoCheck(int nValue)
{
 if(nValue)
  m_pData[m_iCurBit >> 3] |= (1 << (m_iCurBit & 7));
 else
  m_pData[m_iCurBit >> 3] &= ~(1 << (m_iCurBit & 7));

 ++m_iCurBit;
}

inline void old_bf_write::WriteOneBit(int nValue)
{
 if( !CheckForOverflow(1) )
  WriteOneBitNoCheck( nValue );
}


inline void old_bf_write::WriteOneBitAt( int iBit, int nValue )
{
 if( iBit+1 > m_nDataBits )
 {
  SetOverflowFlag();
  ;
  return;
 }

 if( nValue )
  m_pData[iBit >> 3] |= (1 << (iBit & 7));
 else
  m_pData[iBit >> 3] &= ~(1 << (iBit & 7));
}


inline void old_bf_write::WriteUBitLong( unsigned int curData, int numbits, bool bCheckRange )
{
 extern unsigned long g_BitWriteMasks[32][33];


 if ((m_iCurBit+numbits) > m_nDataBits)
 {
  m_iCurBit = m_nDataBits;
  SetOverflowFlag();
  ;
  return;
 }

 int nBitsLeft = numbits;
 int iCurBit = m_iCurBit;


 unsigned int iDWord = iCurBit >> 5;
 ((void)0);

 unsigned long iCurBitMasked = iCurBit & 31;

 unsigned long dword = LoadLittleDWord( (unsigned long*)m_pData, iDWord );

 dword &= g_BitWriteMasks[iCurBitMasked][nBitsLeft];
 dword |= curData << iCurBitMasked;


 StoreLittleDWord( (unsigned long*)m_pData, iDWord, dword );


 int nBitsWritten = 32 - iCurBitMasked;
 if ( nBitsWritten < nBitsLeft )
 {
  nBitsLeft -= nBitsWritten;
  curData >>= nBitsWritten;


  dword = LoadLittleDWord( (unsigned long*)m_pData, iDWord+1 );

  dword &= g_BitWriteMasks[0][nBitsLeft];
  dword |= curData;


  StoreLittleDWord( (unsigned long*)m_pData, iDWord+1, dword );
 }

 m_iCurBit += numbits;
}






template<int SIZE>
class old_bf_write_static : public old_bf_write
{
public:
 inline old_bf_write_static() : old_bf_write(m_StaticData, SIZE) {}

 char m_StaticData[SIZE];
};







class old_bf_read
{
public:
 old_bf_read();



 old_bf_read( const void *pData, int nBytes, int nBits = -1 );
 old_bf_read( const char *pDebugName, const void *pData, int nBytes, int nBits = -1 );





 void StartReading( const void *pData, int nBytes, int iStartBit = 0, int nBits = -1 );


 void Reset();



 void SetAssertOnOverflow( bool bAssert );


 const char* GetDebugName();
 void SetDebugName( const char *pName );

 void ExciseBits( int startbit, int bitstoremove );



public:


 int ReadOneBit();


protected:

 unsigned int CheckReadUBitLong(int numbits);
 int ReadOneBitNoCheck();
 bool CheckForOverflow(int nBits);


public:


 const unsigned char* GetBasePointer() { return m_pData; }

 inline int TotalBytesAvailable( void ) const
 {
  return m_nDataBytes;
 }


 void ReadBits(void *pOut, int nBits);

 float ReadBitAngle( int numbits );

 unsigned int ReadUBitLong( int numbits );
 unsigned int PeekUBitLong( int numbits );
 int ReadSBitLong( int numbits );


 unsigned int ReadUBitVar();



 unsigned int ReadBitLong(int numbits, bool bSigned);

 float ReadBitCoord();
 float ReadBitCoordMP( bool bIntegral, bool bLowPrecision );
 float ReadBitFloat();
 float ReadBitNormal();
 void ReadBitVec3Coord( Vector& fa );
 void ReadBitVec3Normal( Vector& fa );
 void ReadBitAngles( QAngle& fa );



public:

 int ReadChar();
 int ReadByte();
 int ReadShort();
 int ReadWord();
 long ReadLong();
 int64 ReadLongLong();
 float ReadFloat();
 bool ReadBytes(void *pOut, int nBytes);
 bool ReadString( char *pStr, int bufLen, bool bLine=false, int *pOutNumChars=
                                                                               __null 
                                                                                    );



 char* ReadAndAllocateString( bool *pOverflow = 0 );


public:
 int GetNumBytesLeft();
 int GetNumBytesRead();
 int GetNumBitsLeft();
 int GetNumBitsRead() const;


 inline bool IsOverflowed() const {return m_bOverflow;}

 inline bool Seek(int iBit);
 inline bool SeekRelative(int iBitDelta);


 inline void SetOverflowFlag();


public:


 const unsigned char* m_pData;
 int m_nDataBytes;
 int m_nDataBits;


 int m_iCurBit;


private:

 inline int CountRunOfZeros();


 bool m_bOverflow;


 bool m_bAssertOnOverflow;

 const char *m_pDebugName;
};





inline int old_bf_read::GetNumBytesRead()
{
 return BitByte(m_iCurBit);
}

inline int old_bf_read::GetNumBitsLeft()
{
 return m_nDataBits - m_iCurBit;
}

inline int old_bf_read::GetNumBytesLeft()
{
 return GetNumBitsLeft() >> 3;
}

inline int old_bf_read::GetNumBitsRead() const
{
 return m_iCurBit;
}

inline void old_bf_read::SetOverflowFlag()
{
 if ( m_bAssertOnOverflow )
 {
  ((void)0);
 }

 m_bOverflow = true;
}

inline bool old_bf_read::Seek(int iBit)
{
 if(iBit < 0 || iBit > m_nDataBits)
 {
  SetOverflowFlag();
  m_iCurBit = m_nDataBits;
  return false;
 }
 else
 {
  m_iCurBit = iBit;
  return true;
 }
}


inline bool old_bf_read::SeekRelative(int iBitDelta)
{
 return Seek(m_iCurBit+iBitDelta);
}

inline bool old_bf_read::CheckForOverflow(int nBits)
{
 if( m_iCurBit + nBits > m_nDataBits )
 {
  SetOverflowFlag();
  ;
 }

 return m_bOverflow;
}

inline int old_bf_read::ReadOneBitNoCheck()
{
 int value = m_pData[m_iCurBit >> 3] & (1 << (m_iCurBit & 7));
 ++m_iCurBit;
 return !!value;
}

inline int old_bf_read::ReadOneBit()
{
 return (!CheckForOverflow(1)) ? ReadOneBitNoCheck() : 0;
}

inline float old_bf_read::ReadBitFloat()
{
 long val;

 ((void)0);
 ((void)0);

 if(CheckForOverflow(32))
  return 0.0f;

 int bit = m_iCurBit & 0x7;
 int byte = m_iCurBit >> 3;
 val = m_pData[byte] >> bit;
 val |= ((int)m_pData[byte + 1]) << (8 - bit);
 val |= ((int)m_pData[byte + 2]) << (16 - bit);
 val |= ((int)m_pData[byte + 3]) << (24 - bit);
 if (bit != 0)
  val |= ((int)m_pData[byte + 4]) << (32 - bit);
 m_iCurBit += 32;
 return *((float*)&val);
}


inline unsigned int old_bf_read::ReadUBitLong( int numbits )
{
 extern unsigned long g_ExtraMasks[32];

 if ( (m_iCurBit+numbits) > m_nDataBits )
 {
  m_iCurBit = m_nDataBits;
  SetOverflowFlag();
  return 0;
 }

 ((void)0);


 int idword1 = m_iCurBit >> 5;
 unsigned int dword1 = LoadLittleDWord( (unsigned long*)m_pData, idword1 );

 dword1 >>= (m_iCurBit & 31);

 m_iCurBit += numbits;
 unsigned int ret = dword1;


 if ( (m_iCurBit-1) >> 5 == idword1 )
 {
  if (numbits != 32)
   ret &= g_ExtraMasks[numbits];
 }
 else
 {
  int nExtraBits = m_iCurBit & 31;
  unsigned int dword2 = LoadLittleDWord( (unsigned long*)m_pData, idword1+1 );

  dword2 &= g_ExtraMasks[nExtraBits];



  ret |= (dword2 << (numbits - nExtraBits));
 }

 return ret;
}


class CBitBuffer
{
public:
 char const * m_pDebugName;
 bool m_bOverflow;
 int m_nDataBits;
 size_t m_nDataBytes;

 void SetDebugName( char const *pName )
 {
  m_pDebugName = pName;
 }

 CBitBuffer( void )
 {
  m_bOverflow = false;
  m_pDebugName = 
                __null
                    ;
  m_nDataBits = -1;
  m_nDataBytes = 0;
 }

 inline void SetOverflowFlag( void )
 {
  m_bOverflow = true;
 }

 inline bool IsOverflowed( void ) const
 {
  return m_bOverflow;
 }

 static const uint32 s_nMaskTable[33];

};


class CBitWrite : public CBitBuffer
{
 uint32 m_nOutBufWord;
 int m_nOutBitsAvail;
 uint32 *m_pDataOut;
 uint32 *m_pBufferEnd;
 uint32 *m_pData;
 bool m_bFlushed;

public:
 void StartWriting( void *pData, int nBytes, int iStartBit = 0, int nMaxBits = -1 );


 CBitWrite( void *pData, int nBytes, int nBits = -1 )
 {
  m_bFlushed = false;
  StartWriting( pData, nBytes, 0, nBits );
 }

 CBitWrite( const char *pDebugName, void *pData, int nBytes, int nBits = -1 )
 {
  m_bFlushed = false;
  SetDebugName( pDebugName );
  StartWriting( pData, nBytes, 0, nBits );
 }

 CBitWrite( void )
 {
  m_bFlushed = false;
 }

 ~CBitWrite( void )
 {
  TempFlush();
  ((void)0);
 }
 inline int GetNumBitsLeft( void ) const
 {
  return m_nOutBitsAvail + ( 32 * ( m_pBufferEnd - m_pDataOut -1 ) );
 }

 inline void Reset( void )
 {
  m_bOverflow = false;
  m_nOutBitsAvail = 32;
  m_pDataOut = m_pData;
  m_nOutBufWord = 0;

 }

 inline void TempFlush( void )
 {


  if ( m_nOutBitsAvail != 32 )
  {
   if ( m_pDataOut == m_pBufferEnd )
   {
    SetOverflowFlag();
   }
   else
   {
    *( m_pDataOut ) = (*m_pDataOut & ~s_nMaskTable[ 32 - m_nOutBitsAvail ] ) | m_nOutBufWord;
    m_bFlushed = true;
   }
  }
 }

 inline unsigned char *GetBasePointer()
 {
  TempFlush();
  return reinterpret_cast< unsigned char *>( m_pData );
 }

 inline unsigned char *GetData()
 {
  return GetBasePointer();
 }

 inline void Finish();
 inline void Flush();
 inline void FlushNoCheck();
 inline void WriteOneBit(int nValue);
 inline void WriteOneBitNoCheck(int nValue);
 inline void WriteUBitLong( unsigned int data, int numbits, bool bCheckRange=true );
 inline void WriteSBitLong( int data, int numbits );
 inline void WriteUBitVar( unsigned int data );
 inline void WriteBitFloat( float flValue );
 inline void WriteFloat( float flValue );
 bool WriteBits(const void *pInData, int nBits);
 void WriteBytes( const void *pBuf, int nBytes );
 void SeekToBit( int nSeekPos );

 inline int GetNumBitsWritten( void ) const
 {
  return ( 32 - m_nOutBitsAvail ) + ( 32 * ( m_pDataOut - m_pData ) );
 }

 inline int GetNumBytesWritten( void ) const
 {
  return ( GetNumBitsWritten() + 7 ) >> 3;
 }


 inline void WriteLong(long val)
 {
  WriteSBitLong( val, 32 );
 }



 inline void WriteChar( int val )
 {
  WriteSBitLong(val, sizeof(char) << 3 );
 }

 inline void WriteByte( int val )
 {
  WriteUBitLong(val, sizeof(unsigned char) << 3, false );
 }

 inline void WriteShort(int val)
 {
  WriteSBitLong(val, sizeof(short) << 3);
 }

 inline void WriteWord(int val)
 {
  WriteUBitLong(val, sizeof(unsigned short) << 3);
 }

 bool WriteString( const char *pStr );

 void WriteLongLong( int64 val );

 void WriteBitAngle( float fAngle, int numbits );
 void WriteBitCoord (const float f);
 void WriteBitCoordMP( const float f, bool bIntegral, bool bLowPrecision );
 void WriteBitVec3Coord( const Vector& fa );
 void WriteBitNormal( float f );
 void WriteBitVec3Normal( const Vector& fa );
 void WriteBitAngles( const QAngle& fa );



 bool WriteBitsFromBuffer( class bf_read *pIn, int nBits );

};

void CBitWrite::Finish( void )
{
 if ( m_nOutBitsAvail != 32 )
 {
  if ( m_pDataOut == m_pBufferEnd )
  {
   SetOverflowFlag();
  }
  *( m_pDataOut ) = m_nOutBufWord;
 }
}

void CBitWrite::FlushNoCheck( void )
{
 *( m_pDataOut++ ) = m_nOutBufWord;
 m_nOutBitsAvail = 32;
 m_nOutBufWord = 0;

}
void CBitWrite::Flush( void )
{
 if ( m_pDataOut == m_pBufferEnd )
 {
  SetOverflowFlag();
 }
 else
  *( m_pDataOut++ ) = m_nOutBufWord;
 m_nOutBufWord = 0;
 m_nOutBitsAvail = 32;

}
void CBitWrite::WriteOneBitNoCheck( int nValue )
{
 m_nOutBufWord |= ( nValue & 1 ) << ( 32 - m_nOutBitsAvail );
 if ( --m_nOutBitsAvail == 0 )
 {
  FlushNoCheck();
 }
}

void CBitWrite::WriteOneBit( int nValue )
{
 m_nOutBufWord |= ( nValue & 1 ) << ( 32 - m_nOutBitsAvail );
 if ( --m_nOutBitsAvail == 0 )
 {
  Flush();
 }
}

inline void CBitWrite::WriteUBitLong( unsigned int nData, int nNumBits, bool bCheckRange )
{
 if ( nNumBits <= m_nOutBitsAvail )
 {
  if ( bCheckRange )
   m_nOutBufWord |= ( nData ) << ( 32 - m_nOutBitsAvail );
  else
   m_nOutBufWord |= ( nData & s_nMaskTable[ nNumBits] ) << ( 32 - m_nOutBitsAvail );
  m_nOutBitsAvail -= nNumBits;
  if ( m_nOutBitsAvail == 0 )
  {
   Flush();
  }
 }
 else
 {

  int nOverflowBits = ( nNumBits - m_nOutBitsAvail );
  m_nOutBufWord |= ( nData & s_nMaskTable[m_nOutBitsAvail] ) << ( 32 - m_nOutBitsAvail );
  Flush();
  m_nOutBufWord = ( nData >> ( nNumBits - nOverflowBits ) );
  m_nOutBitsAvail = 32 - nOverflowBits;
 }
}

inline void CBitWrite::WriteSBitLong( int nData, int nNumBits )
{
 WriteUBitLong( ( uint32 ) nData, nNumBits, false );
}

inline void CBitWrite::WriteUBitVar( unsigned int data )
{
 if ( ( data &0xf ) == data )
 {
  WriteUBitLong( 0, 2 );
  WriteUBitLong( data, 4 );
 }
 else
 {
  if ( ( data & 0xff ) == data )
  {
   WriteUBitLong( 1, 2 );
   WriteUBitLong( data, 8 );
  }
  else
  {
   if ( ( data & 0xfff ) == data )
   {
    WriteUBitLong( 2, 2 );
    WriteUBitLong( data, 12 );
   }
   else
   {
    WriteUBitLong( 0x3, 2 );
    WriteUBitLong( data, 32 );
   }
  }
 }
}

inline void CBitWrite::WriteBitFloat( float flValue )
{
 WriteUBitLong( *((uint32 *) &flValue ), 32 );
}

inline void CBitWrite::WriteFloat( float flValue )
{

 ( *&flValue = *&flValue );
 WriteUBitLong( *((uint32 *) &flValue ), 32 );
}

class CBitRead : public CBitBuffer
{
 uint32 m_nInBufWord;
 int m_nBitsAvail;
 uint32 const *m_pDataIn;
 uint32 const *m_pBufferEnd;
 uint32 const *m_pData;

public:
 CBitRead( const void *pData, int nBytes, int nBits = -1 )
 {
  StartReading( pData, nBytes, 0, nBits );
 }

 CBitRead( const char *pDebugName, const void *pData, int nBytes, int nBits = -1 )
 {
  SetDebugName( pDebugName );
  StartReading( pData, nBytes, 0, nBits );
 }

 CBitRead( void ) : CBitBuffer()
 {
 }

 inline int Tell( void ) const
 {
  return GetNumBitsRead();
 }

 inline size_t TotalBytesAvailable( void ) const
 {
  return m_nDataBytes;
 }

 inline int GetNumBitsLeft() const
 {
  return m_nDataBits - Tell();
 }

 inline int GetNumBytesLeft() const
 {
  return GetNumBitsLeft() >> 3;
 }

 bool Seek( int nPosition );

 inline bool SeekRelative( int nOffset )
 {
  return Seek( GetNumBitsRead() + nOffset );
 }

 inline unsigned char const * GetBasePointer()
 {
  return reinterpret_cast< unsigned char const *>( m_pData );
 }

 void StartReading( const void *pData, int nBytes, int iStartBit = 0, int nBits = -1 );

 inline int GetNumBitsRead( void ) const;

 inline void GrabNextDWord( bool bOverFlowImmediately = false );
 inline void FetchNext( void );
 inline unsigned int ReadUBitLong( int numbits );
 inline int ReadSBitLong( int numbits );
 inline unsigned int ReadUBitVar( void );
 inline unsigned int PeekUBitLong( int numbits );
 inline float ReadBitFloat( void );
 float ReadBitCoord();
 float ReadBitCoordMP( bool bIntegral, bool bLowPrecision );
 float ReadBitNormal();
 void ReadBitVec3Coord( Vector& fa );
 void ReadBitVec3Normal( Vector& fa );
 void ReadBitAngles( QAngle& fa );
 bool ReadBytes(void *pOut, int nBytes);
 float ReadBitAngle( int numbits );


 inline int ReadOneBit( void );
 inline int ReadLong( void );
 inline int ReadChar( void );
 inline int ReadByte( void );
 inline int ReadShort( void );
 inline int ReadWord( void );
 inline float ReadFloat( void );
 void ReadBits(void *pOut, int nBits);
 bool ReadString( char *pStr, int bufLen, bool bLine=false, int *pOutNumChars=
                                                                             __null 
                                                                                  );
 char* ReadAndAllocateString( bool *pOverflow = 0 );

 int64 ReadLongLong( void );

};


inline int CBitRead::GetNumBitsRead( void ) const
{
 if ( ! m_pData )
  return 0;
 int nCurOfs = ( 32 - m_nBitsAvail ) + ( 8 * sizeof( m_pData[0] ) * ( m_pDataIn - m_pData -1 ) );
 int nAdjust = 8 * ( m_nDataBytes & 3 );
 return ( ( ( nCurOfs + nAdjust ) < ( m_nDataBits ) ) ? ( nCurOfs + nAdjust ) : ( m_nDataBits ) );

}

inline void CBitRead::GrabNextDWord( bool bOverFlowImmediately )
{
 if ( m_pDataIn == m_pBufferEnd )
 {
  m_nBitsAvail = 1;
  m_nInBufWord = 0;
  m_pDataIn++;
  if ( bOverFlowImmediately )
   SetOverflowFlag();
 }
 else
  if ( m_pDataIn > m_pBufferEnd )
  {
   SetOverflowFlag();
   m_nInBufWord = 0;
  }
  else
  {
   ((void)0);
   m_nInBufWord = ( *( m_pDataIn++ ) );
  }
}

inline void CBitRead::FetchNext( void )
{
 m_nBitsAvail = 32;
 GrabNextDWord( false );
}

int CBitRead::ReadOneBit( void )
{
 int nRet = m_nInBufWord & 1;
 if ( --m_nBitsAvail == 0 )
 {
  FetchNext();
 }
 else
  m_nInBufWord >>= 1;
 return nRet;
}


unsigned int CBitRead::ReadUBitLong( int numbits )
{
 if ( m_nBitsAvail >= numbits )
 {
  unsigned int nRet = m_nInBufWord & s_nMaskTable[ numbits ];
  m_nBitsAvail -= numbits;
  if ( m_nBitsAvail )
  {
   m_nInBufWord >>= numbits;
  }
  else
  {
   FetchNext();
  }
  return nRet;
 }
 else
 {

  unsigned int nRet = m_nInBufWord;
  numbits -= m_nBitsAvail;
  GrabNextDWord( true );
  if ( m_bOverflow )
   return 0;
  nRet |= ( ( m_nInBufWord & s_nMaskTable[numbits] ) << m_nBitsAvail );
  m_nBitsAvail = 32 - numbits;
  m_nInBufWord >>= numbits;
  return nRet;
 }
}

inline unsigned int CBitRead::PeekUBitLong( int numbits )
{
 int nSaveBA = m_nBitsAvail;
 int nSaveW = m_nInBufWord;
 uint32 const *pSaveP = m_pDataIn;
 unsigned int nRet = ReadUBitLong( numbits );
 m_nBitsAvail = nSaveBA;
 m_nInBufWord = nSaveW;
 m_pDataIn = pSaveP;
 return nRet;
}

inline int CBitRead::ReadSBitLong( int numbits )
{
 int nRet = ReadUBitLong( numbits );

 return ( nRet << ( 32 - numbits ) ) >> ( 32 - numbits );
}

inline int CBitRead::ReadLong( void )
{
 return ( int ) ReadUBitLong( sizeof(long) << 3 );
}

inline float CBitRead::ReadFloat( void )
{
 uint32 nUval = ReadUBitLong( sizeof(long) << 3 );
 return * ( ( float * ) &nUval );
}
inline unsigned int CBitRead::ReadUBitVar( void )
{
 unsigned int ret = ReadUBitLong( 2 );
 switch( ret )
 {
  case 0:
   ret = ReadUBitLong( 4 );
   break;

  case 1:
   ret = ReadUBitLong( 8 );
   break;

  case 2:
   ret = ReadUBitLong( 12 );
   break;

  case 3:
   ret = ReadUBitLong( 32 );
   break;
 }
 return ret;
}




inline float CBitRead::ReadBitFloat( void )
{
 uint32 nvalue = ReadUBitLong( 32 );
 return *( ( float * ) &nvalue );
}

int CBitRead::ReadChar( void )
{
 return ReadSBitLong(sizeof(char) << 3);
}

int CBitRead::ReadByte( void )
{
 return ReadUBitLong(sizeof(unsigned char) << 3);
}

int CBitRead::ReadShort( void )
{
 return ReadSBitLong(sizeof(short) << 3);
}

int CBitRead::ReadWord( void )
{
 return ReadUBitLong(sizeof(unsigned short) << 3);
}
class bf_read : public old_bf_read { public: inline bf_read( void ) : old_bf_read( ) { } inline bf_read( const void *pData, int nBytes, int nBits = -1 ) : old_bf_read( pData, nBytes, nBits ) { } inline bf_read( const char *pDebugName, const void *pData, int nBytes, int nBits = -1 ) : old_bf_read( pDebugName, pData, nBytes, nBits ) { } };;



class bf_write : public old_bf_write { public: inline bf_write(void) : old_bf_write() { } inline bf_write( void *pData, int nBytes, int nMaxBits = -1 ) : old_bf_write( pData, nBytes, nMaxBits ) { } inline bf_write( const char *pDebugName, void *pData, int nBytes, int nMaxBits = -1 ) : old_bf_write( pDebugName, pData, nBytes, nMaxBits ) { } };;




class SendTable;
class ServerClass;
class IMoveHelper;
struct Ray_t;
class CGameTrace;
typedef CGameTrace trace_t;
struct typedescription_t;
class CSaveRestoreData;
struct datamap_t;
class SendTable;
class ServerClass;
class IMoveHelper;
struct Ray_t;
struct studiohdr_t;
class CBaseEntity;
class CRestore;
class CSave;
class variant_t;
struct vcollide_t;
class IRecipientFilter;
class CBaseEntity;
class ITraceFilter;
struct client_textmessage_t;
class INetChannelInfo;
class ISpatialPartition;
class IScratchPad3D;
class CStandardSendProxies;
class IAchievementMgr;
class CGamestatsData;
class CSteamID;
class ISPSharedMemory;
class CGamestatsData;

typedef struct player_info_s player_info_t;
struct bbox_t
{
 Vector mins;
 Vector maxs;
};




class IVEngineServer
{
public:

 virtual void ChangeLevel( const char *s1, const char *s2 ) = 0;


 virtual int IsMapValid( const char *filename ) = 0;


 virtual bool IsDedicatedServer( void ) = 0;


 virtual int IsInEditMode( void ) = 0;


 virtual KeyValues* GetLaunchOptions( void ) = 0;







 virtual int PrecacheModel( const char *s, bool preload = false ) = 0;
 virtual int PrecacheSentenceFile( const char *s, bool preload = false ) = 0;
 virtual int PrecacheDecal( const char *name, bool preload = false ) = 0;
 virtual int PrecacheGeneric( const char *s, bool preload = false ) = 0;


 virtual bool IsModelPrecached( char const *s ) const = 0;
 virtual bool IsDecalPrecached( char const *s ) const = 0;
 virtual bool IsGenericPrecached( char const *s ) const = 0;





 virtual int GetClusterForOrigin( const Vector &org ) = 0;

 virtual int GetPVSForCluster( int cluster, int outputpvslength, unsigned char *outputpvs ) = 0;

 virtual bool CheckOriginInPVS( const Vector &org, const unsigned char *checkpvs, int checkpvssize ) = 0;

 virtual bool CheckBoxInPVS( const Vector &mins, const Vector &maxs, const unsigned char *checkpvs, int checkpvssize ) = 0;



 virtual int GetPlayerUserId( const edict_t *e ) = 0;
 virtual const char *GetPlayerNetworkIDString( const edict_t *e ) = 0;
 virtual bool IsUserIDInUse( int userID ) = 0;
 virtual int GetLoadingProgressForUserID( int userID ) = 0;


 virtual int GetEntityCount( void ) = 0;


 virtual INetChannelInfo* GetPlayerNetInfo( int playerIndex ) = 0;




 virtual edict_t *CreateEdict( int iForceEdictIndex = -1 ) = 0;

 virtual void RemoveEdict( edict_t *e ) = 0;


 virtual void *PvAllocEntPrivateData( long cb ) = 0;
 virtual void FreeEntPrivateData( void *pEntity ) = 0;


 virtual void *SaveAllocMemory( size_t num, size_t size ) = 0;
 virtual void SaveFreeMemory( void *pSaveMem ) = 0;


 virtual void EmitAmbientSound( int entindex, const Vector &pos, const char *samp, float vol, soundlevel_t soundlevel, int fFlags, int pitch, float delay = 0.0f ) = 0;


 virtual void FadeClientVolume( const edict_t *pEdict, float fadePercent, float fadeOutSeconds, float holdTime, float fadeInSeconds ) = 0;


 virtual int SentenceGroupPick( int groupIndex, char *name, int nameBufLen ) = 0;
 virtual int SentenceGroupPickSequential( int groupIndex, char *name, int nameBufLen, int sentenceIndex, int reset ) = 0;
 virtual int SentenceIndexFromName( const char *pSentenceName ) = 0;
 virtual const char *SentenceNameFromIndex( int sentenceIndex ) = 0;
 virtual int SentenceGroupIndexFromName( const char *pGroupName ) = 0;
 virtual const char *SentenceGroupNameFromIndex( int groupIndex ) = 0;
 virtual float SentenceLength( int sentenceIndex ) = 0;


 virtual void ServerCommand( const char *str ) = 0;

 virtual void ServerExecute( void ) = 0;

 virtual void ClientCommand( edict_t *pEdict, const char *szFmt, ... ) = 0;



 virtual void LightStyle( int style, const char *val ) = 0;


 virtual void StaticDecal( const Vector &originInEntitySpace, int decalIndex, int entityIndex, int modelIndex, bool lowpriority ) = 0;


 virtual void Message_DetermineMulticastRecipients( bool usepas, const Vector& origin, CBitVec< 255 >& playerbits ) = 0;


 virtual bf_write *EntityMessageBegin( int ent_index, ServerClass * ent_class, bool reliable ) = 0;

 virtual bf_write *UserMessageBegin( IRecipientFilter *filter, int msg_type, char const *pchMsgName ) = 0;

 virtual void MessageEnd( void ) = 0;


 virtual void ClientPrintf( edict_t *pEdict, const char *szMsg ) = 0;




 virtual void Con_NPrintf( int pos, const char *fmt, ... ) = 0;


 virtual void Con_NXPrintf( const struct con_nprint_s *info, const char *fmt, ... ) = 0;


 virtual void SetView( const edict_t *pClient, const edict_t *pViewent ) = 0;


 virtual float OBSOLETE_Time( void ) = 0;


 virtual void CrosshairAngle( const edict_t *pClient, float pitch, float yaw ) = 0;


 virtual void GetGameDir( char *szGetGameDir, int maxlength ) = 0;


 virtual int CompareFileTime( const char *filename1, const char *filename2, int *iCompare ) = 0;



 virtual bool LockNetworkStringTables( bool lock ) = 0;


 virtual edict_t *CreateFakeClient( const char *netname ) = 0;


 virtual const char *GetClientConVarValue( int clientIndex, const char *name ) = 0;


 virtual const char *ParseFile( const char *data, char *token, int maxlen ) = 0;

 virtual bool CopyFile( const char *source, const char *destination ) = 0;



 virtual void ResetPVS( byte *pvs, int pvssize ) = 0;

 virtual void AddOriginToPVS( const Vector &origin ) = 0;



 virtual void SetAreaPortalState( int portalNumber, int isOpen ) = 0;


 virtual void PlaybackTempEntity( IRecipientFilter& filter, float delay, const void *pSender, const SendTable *pST, int classID ) = 0;

 virtual int CheckHeadnodeVisible( int nodenum, const byte *pvs, int vissize ) = 0;

 virtual int CheckAreasConnected( int area1, int area2 ) = 0;

 virtual int GetArea( const Vector &origin ) = 0;

 virtual void GetAreaBits( int area, unsigned char *bits, int buflen ) = 0;


 virtual bool GetAreaPortalPlane( Vector const &vViewOrigin, int portalKey, VPlane *pPlane ) = 0;


 virtual bool LoadGameState( char const *pMapName, bool createPlayers ) = 0;
 virtual void LoadAdjacentEnts( const char *pOldLevel, const char *pLandmarkName ) = 0;
 virtual void ClearSaveDir() = 0;


 virtual const char* GetMapEntitiesString() = 0;


 virtual client_textmessage_t *TextMessageGet( const char *pName ) = 0;


 virtual void LogPrint( const char *msg ) = 0;
 virtual bool IsLogEnabled() = 0;

 virtual void BuildEntityClusterList( edict_t *pEdict, PVSInfo_t *pPVSInfo ) = 0;


 virtual void SolidMoved( edict_t *pSolidEnt, ICollideable *pSolidCollide, const Vector* pPrevAbsOrigin, bool testSurroundingBoundsOnly ) = 0;

 virtual void TriggerMoved( edict_t *pTriggerEnt, bool testSurroundingBoundsOnly ) = 0;


 virtual ISpatialPartition *CreateSpatialPartition( const Vector& worldmin, const Vector& worldmax ) = 0;
 virtual void DestroySpatialPartition( ISpatialPartition * ) = 0;



 virtual void DrawMapToScratchPad( IScratchPad3D *pPad, unsigned long iFlags ) = 0;
 virtual const CBitVec<(1<<11)>* GetEntityTransmitBitsForClient( int iClientIndex ) = 0;


 virtual bool IsPaused() = 0;


 virtual float GetTimescale( void ) const = 0;


 virtual void ForceExactFile( const char *s ) = 0;
 virtual void ForceModelBounds( const char *s, const Vector &mins, const Vector &maxs ) = 0;
 virtual void ClearSaveDirAfterClientLoad() = 0;


 virtual void SetFakeClientConVarValue( edict_t *pEntity, const char *cvar, const char *value ) = 0;




 virtual void ForceSimpleMaterial( const char *s ) = 0;


 virtual int IsInCommentaryMode( void ) = 0;


 virtual bool IsLevelMainMenuBackground( void ) = 0;



 virtual void SetAreaPortalStates( const int *portalNumbers, const int *isOpen, int nPortals ) = 0;


 virtual void NotifyEdictFlagsChange( int iEdict ) = 0;



 virtual const CCheckTransmitInfo* GetPrevCheckTransmitInfo( edict_t *pPlayerEdict ) = 0;

 virtual CSharedEdictChangeInfo* GetSharedEdictChangeInfo() = 0;



 virtual void AllowImmediateEdictReuse( ) = 0;


 virtual bool IsInternalBuild( void ) = 0;

 virtual IChangeInfoAccessor *GetChangeAccessor( const edict_t *pEdict ) = 0;


 virtual char const *GetMostRecentlyLoadedFileName() = 0;
 virtual char const *GetSaveFileName() = 0;
 virtual void WriteSavegameScreenshot( const char *filename ) = 0;

 virtual int GetLightForPointListenServerOnly(const Vector &, bool, Vector *) = 0;
 virtual int TraceLightingListenServerOnly(const Vector &, const Vector &, Vector *, Vector *) = 0;


 virtual void CleanUpEntityClusterList( PVSInfo_t *pPVSInfo ) = 0;

 virtual void SetAchievementMgr( IAchievementMgr *pAchievementMgr ) =0;
 virtual IAchievementMgr *GetAchievementMgr() = 0;

 virtual int GetAppID() = 0;

 virtual bool IsLowViolence() = 0;

 virtual bool IsAnyClientLowViolence() = 0;
 virtual QueryCvarCookie_t StartQueryCvarValue( edict_t *pPlayerEntity, const char *pName ) = 0;

 virtual void InsertServerCommand( const char *str ) = 0;


 virtual bool GetPlayerInfo( int ent_num, player_info_t *pinfo ) = 0;


 virtual bool IsClientFullyAuthenticated( edict_t *pEdict ) = 0;



 virtual void SetDedicatedServerBenchmarkMode( bool bBenchmarkMode ) = 0;

 virtual bool IsSplitScreenPlayer( int ent_num ) = 0;
 virtual edict_t *GetSplitScreenPlayerAttachToEdict( int ent_num ) = 0;
 virtual int GetNumSplitScreenUsersAttachedToEdict( int ent_num ) = 0;
 virtual edict_t *GetSplitScreenPlayerForEdict( int ent_num, int nSlot ) = 0;


 virtual bool IsOverrideLoadGameEntsOn() = 0;


 virtual void ForceFlushEntity( int iEntity ) = 0;


 virtual ISPSharedMemory *GetSinglePlayerSharedMemorySpace( const char *szName, int ent_num = (1<<11) ) = 0;


 virtual void *AllocLevelStaticData( size_t bytes ) = 0;


 virtual int GetClusterCount() = 0;
 virtual int GetAllClusterBounds( bbox_t *pBBoxList, int maxBBox ) = 0;

 virtual bool IsCreatingReslist() = 0;
 virtual bool IsCreatingXboxReslist() = 0;
 virtual bool IsDedicatedServerForXbox() = 0;

 virtual void Pause( bool bPause, bool bForce = false ) = 0;

 virtual void SetTimescale( float flTimescale ) = 0;


 virtual void SetGamestatsData( CGamestatsData *pGamestatsData ) = 0;
 virtual CGamestatsData *GetGamestatsData() = 0;


 virtual const CSteamID *GetClientSteamID( edict_t *pPlayerEdict ) = 0;


 virtual void HostValidateSession() = 0;


 virtual void RefreshScreenIfNecessary() = 0;

 virtual void *AllocLevelStaticDataName( unsigned int, const char * ) = 0;



 virtual void ClientCommandKeyValues( edict_t *pEdict, KeyValues *pCommand ) = 0;


 virtual uint64 GetClientXUID( edict_t *pPlayerEdict ) = 0;
};






class IServerGameDLL
{
public:


 virtual bool DLLInit( CreateInterfaceFn engineFactory,
          CreateInterfaceFn physicsFactory,
          CreateInterfaceFn fileSystemFactory,
          CGlobalVars *pGlobals) = 0;


 virtual bool GameInit( void ) = 0;


 virtual bool LevelInit( char const *pMapName,
         char const *pMapEntities, char const *pOldLevel,
         char const *pLandmarkName, bool loadGame, bool background ) = 0;


 virtual void ServerActivate( edict_t *pEdictList, int edictCount, int clientMax ) = 0;


 virtual void GameFrame( bool simulating ) = 0;


 virtual void PreClientUpdate( bool simulating ) = 0;


 virtual void LevelShutdown( void ) = 0;


 virtual void GameShutdown( void ) = 0;


 virtual void DLLShutdown( void ) = 0;



 virtual float GetTickInterval( void ) const = 0;



 virtual ServerClass* GetAllServerClasses( void ) = 0;



 virtual const char *GetGameDescription( void ) = 0;


 virtual void CreateNetworkStringTables( void ) = 0;


 virtual CSaveRestoreData *SaveInit( int size ) = 0;
 virtual void SaveWriteFields( CSaveRestoreData *, const char *, void *, datamap_t *, typedescription_t *, int ) = 0;
 virtual void SaveReadFields( CSaveRestoreData *, const char *, void *, datamap_t *, typedescription_t *, int ) = 0;
 virtual void SaveGlobalState( CSaveRestoreData * ) = 0;
 virtual void RestoreGlobalState( CSaveRestoreData * ) = 0;
 virtual void PreSave( CSaveRestoreData * ) = 0;
 virtual void Save( CSaveRestoreData * ) = 0;
 virtual void GetSaveComment( char *comment, int maxlength, float flMinutes, float flSeconds, bool bNoTime = false ) = 0;
 virtual void WriteSaveHeaders( CSaveRestoreData * ) = 0;
 virtual void ReadRestoreHeaders( CSaveRestoreData * ) = 0;
 virtual void Restore( CSaveRestoreData *, bool ) = 0;
 virtual bool IsRestoring() = 0;
 virtual bool SupportsSaveRestore() = 0;


 virtual int CreateEntityTransitionList( CSaveRestoreData *, int ) = 0;

 virtual void BuildAdjacentMapList( void ) = 0;


 virtual bool GetUserMessageInfo( int msg_type, char *name, int maxnamelength, int& size ) = 0;


 virtual CStandardSendProxies* GetStandardSendProxies() = 0;


 virtual void PostInit() = 0;

 virtual void Think( bool finalTick ) = 0;





 virtual void PreSaveGameLoaded( char const *pSaveName, bool bCurrentlyInGame ) = 0;



 virtual bool ShouldHideServer( void ) = 0;

 virtual void InvalidateMdlCache() = 0;






 virtual void OnQueryCvarValueFinished( QueryCvarCookie_t iCookie, edict_t *pPlayerEntity, EQueryCvarValueStatus eStatus, const char *pCvarName, const char *pCvarValue ) = 0;


 virtual void PostToolsInit() = 0;


 virtual void ApplyGameSettings( KeyValues *pKV ) = 0;

 virtual void GetMatchmakingTags( char *buf, size_t bufSize ) = 0;

 virtual void ServerHibernationUpdate( bool bHibernating ) = 0;

 virtual void GenerateLumpFileName( const char *, char *, int, int ) = 0;

 virtual void GetMatchmakingGameData( char *buf, size_t bufSize ) = 0;
};
class IServerGameEnts
{
public:
 virtual ~IServerGameEnts() {}


 virtual void MarkEntitiesAsTouching( edict_t *e1, edict_t *e2 ) = 0;


 virtual void FreeContainingEntity( edict_t * ) = 0;


 virtual edict_t* BaseEntityToEdict( CBaseEntity *pEnt ) = 0;
 virtual CBaseEntity* EdictToBaseEntity( edict_t *pEdict ) = 0;






 virtual void CheckTransmit( CCheckTransmitInfo *pInfo, const unsigned short *pEdictIndices, int nEdicts ) = 0;


 virtual void PrepareForFullUpdate( edict_t *pEdict ) = 0;
};






class IServerGameClients
{
public:

 virtual void GetPlayerLimits( int& minplayers, int& maxplayers, int &defaultMaxPlayers ) const = 0;



 virtual bool ClientConnect( edict_t *pEntity, const char *pszName, const char *pszAddress, char *reject, int maxrejectlen ) = 0;



 virtual void ClientActive( edict_t *pEntity, bool bLoadGame ) = 0;


 virtual void ClientDisconnect( edict_t *pEntity ) = 0;


 virtual void ClientPutInServer( edict_t *pEntity, char const *playername ) = 0;


 virtual void ClientCommand( edict_t *pEntity, const CCommand &args ) = 0;


 virtual void SetCommandClient( int index ) = 0;


 virtual void ClientSettingsChanged( edict_t *pEdict ) = 0;


 virtual void ClientSetupVisibility( edict_t *pViewEntity, edict_t *pClient, unsigned char *pvs, int pvssize ) = 0;


 virtual float ProcessUsercmds( edict_t *player, bf_read *buf, int numcmds, int totalcmds,
        int dropped_packets, bool ignore, bool paused ) = 0;


 virtual void PostClientMessagesSent( void ) = 0;


 virtual CPlayerState *GetPlayerState( edict_t *player ) = 0;


 virtual void ClientEarPosition( edict_t *pEntity, Vector *pEarOrigin ) = 0;


 virtual int GetReplayDelay( edict_t *player, int& entity ) = 0;



 virtual void GetBugReportInfo( char *buf, int buflen ) = 0;


 virtual void ClientVoice( edict_t *pEdict ) = 0;


 virtual void NetworkIDValidated( const char *pszUserName, const char *pszNetworkID ) = 0;


 virtual int GetMaxSplitscreenPlayers() = 0;


 virtual int GetMaxHumanPlayers() = 0;


 virtual void ClientCommandKeyValues( edict_t *pEntity, KeyValues *pKeyValues ) = 0;
};



class IUploadGameStats
{
public:

 virtual bool UploadGameStats(
  char const *mapname,
  unsigned int blobversion,
  unsigned int blobsize,
  const void *pvBlobData ) = 0;


 virtual void InitConnection( void ) = 0;


 virtual void UpdateConnection( void ) = 0;


 virtual bool IsGameStatsLoggingEnabled() = 0;




 virtual void GetPseudoUniqueId( char *buf, size_t bufsize ) = 0;


 virtual bool IsCyberCafeUser( void ) = 0;


 virtual bool IsHDREnabled( void ) = 0;
};






class IPluginHelpersCheck
{
public:
 virtual bool CreateMessage( const char *plugin, edict_t *pEntity, DIALOG_TYPE type, KeyValues *data ) = 0;
};




class IServerDLLSharedAppSystems
{
public:
 virtual int Count() = 0;
 virtual char const *GetDllName( int idx ) = 0;
 virtual char const *GetInterfaceName( int idx ) = 0;
};
class IServerGameTags
{
public:

 virtual void GetTaggedConVarList( KeyValues *pCvarTagList ) = 0;
};


typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);

namespace SourceMM
{
 class ISmmPlugin;
 class IMetamodListener;




 class ISmmAPI
 {
 public:







  virtual void LogMsg(ISmmPlugin *pl, const char *msg, ...) =0;
  virtual CreateInterfaceFn GetEngineFactory(bool syn=true) =0;
  virtual CreateInterfaceFn GetPhysicsFactory(bool syn=true) =0;
  virtual CreateInterfaceFn GetFileSystemFactory(bool syn=true) =0;







  virtual CreateInterfaceFn GetServerFactory(bool syn=true) =0;






  virtual CGlobalVars *GetCGlobals() =0;
  virtual bool RegisterConCommandBase(ISmmPlugin *plugin, ConCommandBase *pCommand) =0;







  virtual void UnregisterConCommandBase(ISmmPlugin *plugin, ConCommandBase *pCommand) =0;
  virtual void ConPrint(const char *str) =0;
  virtual void ConPrintf(const char *fmt, ...) =0;
  virtual void GetApiVersions(int &major, int &minor, int &plvers, int &plmin) =0;







  virtual void GetShVersions(int &shvers, int &shimpl) =0;







  virtual void AddListener(ISmmPlugin *plugin, IMetamodListener *pListener) =0;
  virtual void *MetaFactory(const char *iface, int *ret, PluginId *id) =0;
  virtual int FormatIface(char iface[], unsigned int maxlength) =0;
  virtual void *InterfaceSearch(CreateInterfaceFn fn,
           const char *iface,
           int max,
           int *ret) =0;







  virtual const char *GetBaseDir() =0;
  virtual size_t PathFormat(char *buffer, size_t len, const char *fmt, ...) =0;
  virtual void ClientConPrintf(edict_t *client, const char *fmt, ...) =0;
  virtual void *VInterfaceMatch(CreateInterfaceFn fn,
           const char *iface,
           int min=-1) =0;
  virtual void EnableVSPListener() =0;







  virtual int GetGameDLLVersion() =0;







  virtual int GetUserMessageCount() =0;
  virtual int FindUserMessage(const char *name, int *size=
                                                         __null
                                                             ) =0;
  virtual const char *GetUserMessage(int index, int *size=
                                                         __null
                                                             ) =0;
  virtual int GetVSPVersion() =0;
  virtual int GetSourceEngineBuild() =0;
  virtual IServerPluginCallbacks *GetVSPInfo(int *pVersion) =0;
  virtual size_t Format(char *buffer,
           size_t maxlength,
           const char *format,
           ...) =0;
  virtual size_t FormatArgs(char *buffer,
          size_t maxlength,
          const char *format,
          va_list ap) =0;
 };
}


using namespace SourceMM;







enum
{
 META_IFACE_OK = 0,
 META_IFACE_FAILED
};

namespace SourceMM
{
 class ISmmAPI;




 class ISmmPlugin
 {
 public:
  virtual int GetApiVersion()
  {
   return 15;
  }




  virtual ~ISmmPlugin()
  {
  }

 public:
  virtual bool Load(PluginId id, ISmmAPI *ismm, char *error, size_t maxlength, bool late) =0;
  virtual void AllPluginsLoaded()
  {
  }
  virtual bool QueryRunning(char *error, size_t maxlen)
  {
   return true;
  }
  virtual bool Unload(char *error, size_t maxlen)
  {
   return true;
  }
  virtual bool Pause(char *error, size_t maxlen)
  {
   return true;
  }
  virtual bool Unpause(char *error, size_t maxlen)
  {
   return true;
  }
 public:

  virtual const char *GetAuthor() =0;


  virtual const char *GetName() =0;


  virtual const char *GetDescription() =0;


  virtual const char *GetURL() =0;


  virtual const char *GetLicense() =0;


  virtual const char *GetVersion() =0;


  virtual const char *GetDate() =0;


  virtual const char *GetLogTag() =0;
 };




 class IMetamodListener
 {
 public:





  virtual void OnPluginLoad(PluginId id)
  {
  }






  virtual void OnPluginUnload(PluginId id)
  {
  }






  virtual void OnPluginPause(PluginId id)
  {
  }






  virtual void OnPluginUnpause(PluginId id)
  {
  }
  virtual void OnLevelInit(char const *pMapName,
         char const *pMapEntities,
         char const *pOldLevel,
         char const *pLandmarkName,
         bool loadGame,
         bool background)
  {
  }





  virtual void OnLevelShutdown()
  {
  }
  virtual void *OnEngineQuery(const char *iface, int *ret)
  {
   if (ret)
   {
    *ret = META_IFACE_FAILED;
   }

   return 
         __null
             ;
  }
  virtual void *OnPhysicsQuery(const char *iface, int *ret)
  {
   if (ret)
   {
    *ret = META_IFACE_FAILED;
   }

   return 
         __null
             ;
  }
  virtual void *OnFileSystemQuery(const char *iface, int *ret)
  {
   if (ret)
   {
    *ret = META_IFACE_FAILED;
   }

   return 
         __null
             ;
  }
  virtual void *OnGameDLLQuery(const char *iface, int *ret)
  {
   if (ret)
   {
    *ret = META_IFACE_FAILED;
   }

   return 
         __null
             ;
  }
  virtual void *OnMetamodQuery(const char *iface, int *ret)
  {
   if (ret)
   {
    *ret = META_IFACE_FAILED;
   }

   return 
         __null
             ;
  }
  virtual void OnVSPListening(IServerPluginCallbacks *iface)
  {
  }
  virtual void OnUnlinkConCommandBase(PluginId id, ConCommandBase *pCommand)
  {
  }
 };
}


using namespace SourceMM;
using namespace SourceMod;
using namespace SourcePawn;

class SDKExtension :

 public ISmmPlugin,

 public IExtensionInterface
{
public:

 SDKExtension();
public:
 virtual bool SDK_OnLoad(char *error, size_t maxlength, bool late);




 virtual void SDK_OnUnload();




 virtual void SDK_OnAllLoaded();




 virtual void SDK_OnPauseChange(bool paused);





 virtual void SDK_OnDependenciesDropped();
 virtual bool SDK_OnMetamodLoad(ISmmAPI *ismm, char *error, size_t maxlength, bool late);
 virtual bool SDK_OnMetamodUnload(char *error, size_t maxlength);
 virtual bool SDK_OnMetamodPauseChange(bool paused, char *error, size_t maxlength);


public:
 virtual bool OnExtensionLoad(IExtension *me, IShareSys *sys, char *error, size_t maxlength, bool late);
 virtual void OnExtensionUnload();
 virtual void OnExtensionsAllLoaded();


 virtual bool IsMetamodExtension();






 virtual void OnExtensionPauseChange(bool state);


 virtual const char *GetExtensionName();

 virtual const char *GetExtensionURL();

 virtual const char *GetExtensionTag();

 virtual const char *GetExtensionAuthor();

 virtual const char *GetExtensionVerString();

 virtual const char *GetExtensionDescription();

 virtual const char *GetExtensionDateString();


 virtual void OnDependenciesDropped();

public:

 virtual bool Load(PluginId id, ISmmAPI *ismm, char *error, size_t maxlength, bool late);

 virtual const char *GetAuthor();

 virtual const char *GetName();

 virtual const char *GetDescription();

 virtual const char *GetURL();

 virtual const char *GetLicense();

 virtual const char *GetVersion();

 virtual const char *GetDate();

 virtual const char *GetLogTag();

 virtual bool Unload(char *error, size_t maxlength);

 virtual bool Pause(char *error, size_t maxlength);

 virtual bool Unpause(char *error, size_t maxlength);
private:
 bool m_SourceMMLoaded;
 bool m_WeAreUnloaded;
 bool m_WeGotPauseChange;

};

extern SDKExtension *g_pExtensionIface;
extern IExtension *myself;

extern IShareSys *g_pShareSys;
extern IShareSys *sharesys;
extern ISourceMod *g_pSM;
extern ISourceMod *smutils;
extern IPlayerManager *playerhelpers;





extern IGameConfigManager *gameconfs;





extern IGameHelpers *gamehelpers;
extern SourceHook::ISourceHook *g_SHPtr; extern ISmmAPI *g_SMAPI; extern ISmmPlugin *g_PLAPI; extern PluginId g_PLID;;

extern IVEngineServer *engine;
extern IServerGameDLL *gamedll;

class CBasePlayer{};




typedef void* ( *tCBaseEntity__SetAbsOrigin)(CBaseEntity*,const Vector*);






class DefibFix : public SDKExtension
{
public:
 virtual bool SDK_OnLoad(char *error, size_t maxlength, bool late);




 virtual void SDK_OnUnload();
public:
 virtual bool SDK_OnMetamodLoad(ISmmAPI *ismm, char *error, size_t maxlength, bool late);
public:
 bool SetupHooks();
 void RemoveHooks();

};
typedef int8_t jit_int8_t;
typedef uint8_t jit_uint8_t;
typedef int32_t jit_int32_t;
typedef uint32_t jit_uint32_t;
typedef int64_t jit_int64_t;
typedef uint64_t jit_uint64_t;
typedef char * jitcode_t;
typedef unsigned int jitoffs_t;
typedef signed int jitrel_t;

class JitWriter
{
public:
 inline cell_t read_cell()
 {
  cell_t val = *(inptr);
  inptr++;
  return val;
 }
 inline cell_t peek_cell()
 {
  return *inptr;
 }
 inline cell_t *read_cellptr()
 {
  cell_t *val = *(cell_t **)(inptr);
  inptr++;
  return val;
 }
 inline void write_ubyte(jit_uint8_t c)
 {
  if (outbase)
  {
   *outptr = c;
  }
  outptr++;
 }
 inline void write_ushort(unsigned short c)
 {
  if (outbase)
  {
   *(unsigned short *)outptr = c;
  }
  outptr += sizeof(unsigned short);
 }
 inline void write_byte(jit_int8_t c)
 {
  if (outbase)
  {
   *outptr = c;
  }
  outptr++;
 }
 inline void write_int32(jit_int32_t c)
 {
  if (outbase)
  {
   *(jit_int32_t *)outptr = c;
  }
  outptr += sizeof(jit_int32_t);
 }
 inline void write_uint32(jit_uint32_t c)
 {
  if (outbase)
  {
   *(jit_uint32_t *)outptr = c;
  }
  outptr += sizeof(jit_uint32_t);
 }
 inline jitoffs_t get_outputpos()
 {
  return (outptr - outbase);
 }
 inline void set_outputpos(jitoffs_t offs)
 {
  outptr = outbase + offs;
 }
 inline jitoffs_t get_inputpos()
 {
  return (jitoffs_t)((char *)inptr - (char *)inbase);
 }
public:
 cell_t *inptr;
 cell_t *inbase;
 jitcode_t outbase;
 jitcode_t outptr;
 SourcePawn::ICompilation *data;
};
const jit_uint8_t kREG_EAX = 0;
const jit_uint8_t kREG_ECX = 1;
const jit_uint8_t kREG_EDX = 2;
const jit_uint8_t kREG_EBX = 3;
const jit_uint8_t kREG_ESP = 4;
const jit_uint8_t kREG_SIB = 4;
const jit_uint8_t kREG_NOIDX = 4;
const jit_uint8_t kREG_IMM_BASE = 5;
const jit_uint8_t kREG_EBP = 5;
const jit_uint8_t kREG_ESI = 6;
const jit_uint8_t kREG_EDI = 7;
inline jit_uint8_t ia32_modrm(jit_uint8_t mode, jit_uint8_t reg, jit_uint8_t rm)
{
 jit_uint8_t modrm = (mode << 6);

 modrm |= (reg << 3);
 modrm |= (rm);

 return modrm;
}




inline jit_uint8_t ia32_sib(jit_uint8_t mode, jit_uint8_t index, jit_uint8_t base)
{
 jit_uint8_t sib = (mode << 6);

 sib |= (index << 3);
 sib |= (base);

 return sib;
}

inline void IA32_Return(JitWriter *jit)
{
 jit->write_ubyte(0xC3);
}

inline void IA32_Mov_Reg_Rm(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_uint8_t mode)
{
 jit->write_ubyte(0x8B);
 jit->write_ubyte(ia32_modrm(mode, dest, src));
}

inline void IA32_Movzx_Reg32_Rm8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_uint8_t mode)
{
 jit->write_ubyte(0x0F);
 jit->write_ubyte(0xB6);
 jit->write_ubyte(ia32_modrm(mode, dest, src));
}

inline void IA32_Movzx_Reg32_Rm8_Disp8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int8_t disp)
{
 jit->write_ubyte(0x0F);
 jit->write_ubyte(0xB6);
 jit->write_ubyte(ia32_modrm(1, dest, src));
 jit->write_byte(disp);
}

inline void IA32_Movzx_Reg32_Rm8_Disp32(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int32_t disp)
{
 jit->write_ubyte(0x0F);
 jit->write_ubyte(0xB6);
 jit->write_ubyte(ia32_modrm(2, dest, src));
 jit->write_int32(disp);
}

inline void IA32_Movzx_Reg32_Rm16(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_uint8_t mode)
{
 jit->write_ubyte(0x0F);
 jit->write_ubyte(0xB7);
 jit->write_ubyte(ia32_modrm(mode, dest, src));
}

inline void IA32_Movzx_Reg32_Rm16_Disp8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int8_t disp)
{
 jit->write_ubyte(0x0F);
 jit->write_ubyte(0xB7);
 jit->write_ubyte(ia32_modrm(1, dest, src));
 jit->write_byte(disp);
}

inline void IA32_Movzx_Reg32_Rm16_Disp32(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int32_t disp)
{
 jit->write_ubyte(0x0F);
 jit->write_ubyte(0xB7);
 jit->write_ubyte(ia32_modrm(2, dest, src));
 jit->write_int32(disp);
}

inline void IA32_Push_Reg(JitWriter *jit, jit_uint8_t reg)
{
 jit->write_ubyte(0x50 +reg);
}

inline void IA32_Pop_Reg(JitWriter *jit, jit_uint8_t reg)
{
 jit->write_ubyte(0x58 +reg);
}

inline void IA32_Lea_DispRegImm8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src_base, jit_int8_t val)
{
 jit->write_ubyte(0x8D);
 jit->write_ubyte(ia32_modrm(1, dest, src_base));
 jit->write_byte(val);
}

inline void IA32_Lea_DispRegImm32(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src_base, jit_int32_t val)
{
 jit->write_ubyte(0x8D);
 jit->write_ubyte(ia32_modrm(2, dest, src_base));
 jit->write_int32(val);
}

inline void IA32_Mov_Reg_Rm_Disp8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int8_t disp)
{
 jit->write_ubyte(0x8B);
 jit->write_ubyte(ia32_modrm(1, dest, src));
 jit->write_byte(disp);
}

inline void IA32_Mov_Reg_Rm_Disp32(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int32_t disp)
{
 jit->write_ubyte(0x8B);
 jit->write_ubyte(ia32_modrm(2, dest, src));
 jit->write_int32(disp);
}

inline void IA32_Sub_Rm_Imm8(JitWriter *jit, jit_uint8_t reg, jit_int8_t val, jit_uint8_t mode)
{
 jit->write_ubyte(0x83);
 jit->write_ubyte(ia32_modrm(mode, 5, reg));
 jit->write_byte(val);
}

inline void IA32_Sub_Rm_Imm32(JitWriter *jit, jit_uint8_t reg, jit_int32_t val, jit_uint8_t mode)
{
 jit->write_ubyte(0x81);
 jit->write_ubyte(ia32_modrm(mode, 5, reg));
 jit->write_int32(val);
}

inline void IA32_Cld(JitWriter *jit)
{
 jit->write_ubyte(0xFC);
}

inline void IA32_Rep(JitWriter *jit)
{
 jit->write_ubyte(0xF3);
}

inline void IA32_Movsd(JitWriter *jit)
{
 jit->write_ubyte(0xA5);
}

inline void IA32_Movsb(JitWriter *jit)
{
 jit->write_ubyte(0xA4);
}

inline jitoffs_t IA32_Call_Imm32(JitWriter *jit, jit_int32_t disp)
{
 jitoffs_t ptr;
 jit->write_ubyte(0xE8);
 ptr = jit->get_outputpos();
 jit->write_int32(disp);
 return ptr;
}

inline void IA32_Mov_Rm8_Reg8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_uint8_t mode)
{
 jit->write_ubyte(0x88);
 jit->write_ubyte(ia32_modrm(mode, src, dest));
}

inline void IA32_Mov_Rm_Reg(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_uint8_t mode)
{
 jit->write_ubyte(0x89);
 jit->write_ubyte(ia32_modrm(mode, src, dest));
}




inline void IA32_Write_Jump32_Abs(JitWriter *jit, jitoffs_t jmp, void *target)
{

 jitcode_t oldptr = jit->outptr;

 long diff = ((long)target - ((long)jit->outbase + jmp + 4));

 jit->outptr = jit->outbase + jmp;
 jit->write_int32(diff);

 jit->outptr = oldptr;
}

inline void IA32_Fstp_Mem32(JitWriter *jit, jit_uint8_t dest)
{
 jit->write_ubyte(0xD9);
 jit->write_ubyte(ia32_modrm(0, 3, dest));
}

inline void IA32_Fstp_Mem64(JitWriter *jit, jit_uint8_t dest)
{
 jit->write_ubyte(0xDD);
 jit->write_ubyte(ia32_modrm(0, 3, dest));
}

inline void IA32_Mov_Rm_Reg_Disp8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int8_t disp)
{
 jit->write_ubyte(0x89);
 jit->write_ubyte(ia32_modrm(1, src, dest));
 jit->write_byte(disp);
}

inline void IA32_Call_Reg(JitWriter *jit, jit_uint8_t reg)
{
 jit->write_ubyte(0xFF);
 jit->write_ubyte(ia32_modrm(3, 2, reg));
}

inline jitoffs_t IA32_Mov_Reg_Imm32(JitWriter *jit, jit_uint8_t dest, jit_int32_t num)
{
 jitoffs_t offs;
 jit->write_ubyte(0xB8 +dest);
 offs = jit->get_outputpos();
 jit->write_int32(num);
 return offs;
}

inline void IA32_Add_Rm_Imm8(JitWriter *jit, jit_uint8_t reg, jit_int8_t value, jit_uint8_t mode)
{
 jit->write_ubyte(0x83);
 jit->write_ubyte(ia32_modrm(mode, 0, reg));
 jit->write_byte(value);
}

inline void IA32_Add_Rm_Imm32(JitWriter *jit, jit_uint8_t reg, jit_int32_t value, jit_uint8_t mode)
{
 jit->write_ubyte(0x81);
 jit->write_ubyte(ia32_modrm(mode, 0, reg));
 jit->write_int32(value);
}

inline void IA32_And_Rm_Imm8(JitWriter *jit, jit_uint8_t reg, jit_uint8_t mode, jit_int8_t value)
{
 jit->write_ubyte(0x83);
 jit->write_ubyte(ia32_modrm(mode, 4, reg));
 jit->write_byte(value);
}

inline void IA32_Lea_Reg_DispRegMultImm8(JitWriter *jit,
         jit_uint8_t dest,
         jit_uint8_t src_base,
         jit_uint8_t src_index,
         jit_uint8_t scale,
         jit_int8_t val)
{
 jit->write_ubyte(0x8D);
 jit->write_ubyte(ia32_modrm(1, dest, kREG_SIB));
 jit->write_ubyte(ia32_sib(scale, src_index, src_base));
 jit->write_byte(val);
}

inline void IA32_Fld_Mem32_Disp8(JitWriter *jit, jit_uint8_t src, jit_int8_t val)
{
 jit->write_ubyte(0xD9);
 jit->write_ubyte(ia32_modrm(1, 0, src));
 jit->write_byte(val);
}

inline void IA32_Fld_Mem64_Disp8(JitWriter *jit, jit_uint8_t src, jit_int8_t val)
{
 jit->write_ubyte(0xDD);
 jit->write_ubyte(ia32_modrm(1, 0, src));
 jit->write_byte(val);
}

inline void IA32_Fld_Mem32(JitWriter *jit, jit_uint8_t src)
{
 jit->write_ubyte(0xD9);
 jit->write_ubyte(ia32_modrm(0, 0, src));
}

inline void IA32_Fld_Mem64(JitWriter *jit, jit_uint8_t src)
{
 jit->write_ubyte(0xDD);
 jit->write_ubyte(ia32_modrm(0, 0, src));
}

inline void IA32_Fld_Mem32_Disp32(JitWriter *jit, jit_uint8_t src, jit_int32_t val)
{
 jit->write_ubyte(0xD9);
 jit->write_ubyte(ia32_modrm(2, 0, src));
 jit->write_int32(val);
}

inline void IA32_Fld_Mem64_Disp32(JitWriter *jit, jit_uint8_t src, jit_int32_t val)
{
 jit->write_ubyte(0xDD);
 jit->write_ubyte(ia32_modrm(2, 0, src));
 jit->write_int32(val);
}

inline void IA32_Fstp_Mem32_ESP(JitWriter *jit)
{
 jit->write_ubyte(0xD9);
 jit->write_ubyte(ia32_modrm(0, 3, kREG_SIB));
 jit->write_ubyte(ia32_sib(0, kREG_NOIDX, kREG_ESP));
}

inline void IA32_Fstp_Mem64_ESP(JitWriter *jit)
{
 jit->write_ubyte(0xDD);
 jit->write_ubyte(ia32_modrm(0, 3, kREG_SIB));
 jit->write_ubyte(ia32_sib(0, kREG_NOIDX, kREG_ESP));
}

inline void IA32_Return_Popstack(JitWriter *jit, unsigned short bytes)
{
 jit->write_ubyte(0xC2);
 jit->write_ushort(bytes);
}

inline void IA32_Push_Imm8(JitWriter *jit, jit_int8_t val)
{
 jit->write_ubyte(0x6A);
 jit->write_byte(val);
}

inline void IA32_Push_Imm32(JitWriter *jit, jit_int32_t val)
{
 jit->write_ubyte(0x68);
 jit->write_int32(val);
}

inline void IA32_Mov_Reg8_Rm8_Disp8(JitWriter *jit, jit_uint8_t dest, jit_uint8_t src, jit_int8_t disp)
{
 jit->write_ubyte(0x8A);
 jit->write_ubyte(ia32_modrm(1, dest, src));
 jit->write_byte(disp);
}

inline jitoffs_t IA32_Jump_Imm32(JitWriter *jit, jit_int32_t disp)
{
 jitoffs_t ptr;
 jit->write_ubyte(0xE9);
 ptr = jit->get_outputpos();
 jit->write_int32(disp);
 return ptr;
}





extern "C" {
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) throw ();
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (const void *__addr, size_t __len) throw ();


extern int munlock (const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);

}








struct patch_t
{
 patch_t()
 {
  patch[0] = 0;
  bytes = 0;
 }
 unsigned char patch[20];
 size_t bytes;
};

inline void ProtectMemory(void *addr, int length, int prot)
{

 void *addr2 = (void *)((long)addr & ~(4096 -1));
 mprotect(addr2, sysconf(
                        _SC_PAGESIZE
                                    ), prot);




}

inline void SetMemPatchable(void *address, size_t size)
{
 ProtectMemory(address, (int)size, 
                                  0x1
                                  |
                                  0x2
                                  |
                                  0x4
                                                        );
}

inline void DoGatePatch(unsigned char *target, void *callback)
{
 SetMemPatchable(target, 20);

 target[0] = 0xFF;
 target[1] = 0x25;
 *(void **)(&target[2]) = callback;
}

inline void ApplyPatch(void *address, int offset, const patch_t *patch, patch_t *restore)
{
 ProtectMemory(address, 20, 
                           0x1
                           |
                           0x2
                           |
                           0x4
                                                 );

 unsigned char *addr = (unsigned char *)address + offset;
 if (restore)
 {
  for (size_t i=0; i<patch->bytes; i++)
  {
   restore->patch[i] = addr[i];
  }
  restore->bytes = patch->bytes;
 }

 for (size_t i=0; i<patch->bytes; i++)
 {
  addr[i] = patch->patch[i];
 }
}
class GenericClass {};
typedef void (GenericClass::*VoidFunc)();

inline void *GetCodeAddr(VoidFunc mfp)
{
 return *(void **)&mfp;
}
class CDetourManager;

class CDetour
{
public:

 bool IsEnabled();




 void EnableDetour();
 void DisableDetour();

 void Destroy();

 friend class CDetourManager;

protected:
 CDetour(void *callbackfunction, void **trampoline, const char *signame);
 CDetour(void*callbackfunction, void **trampoline, void *pAddress);

 bool Init(ISourcePawnEngine *spengine, IGameConfig *gameconf);
private:


 bool CreateDetour();
 void DeleteDetour();

 bool enabled;
 bool detoured;

 patch_t detour_restore;

 void *detour_address;

 void *detour_trampoline;

 void *detour_callback;

 void **trampoline;

 const char *signame;
 ISourcePawnEngine *spengine;
 IGameConfig *gameconf;
};

class CDetourManager
{
public:

 static void Init(ISourcePawnEngine *spengine, IGameConfig *gameconf);
 static CDetour *CreateDetour(void *callbackfunction, void **trampoline, const char *signame);
 static CDetour *CreateDetour(void *callbackfunction, void **trampoline, void *pAddress);

 friend class CBlocker;
 friend class CDetour;

private:
 static ISourcePawnEngine *spengine;
 static IGameConfig *gameconf;
};
extern "C" {


void check_thunks(unsigned char *dest, unsigned char *pc);




int copy_bytes(unsigned char *func, unsigned char* dest, int required_len);


void inject_jmp(void* src, void* dest);


void fill_nop(void* src, unsigned int len);


void* eval_jump(void* src);


}

ISourcePawnEngine *CDetourManager::spengine = 
                                             __null
                                                 ;
IGameConfig *CDetourManager::gameconf = 
                                       __null
                                           ;

void CDetourManager::Init(ISourcePawnEngine *spengine, IGameConfig *gameconf)
{
 CDetourManager::spengine = spengine;
 CDetourManager::gameconf = gameconf;
}

CDetour *CDetourManager::CreateDetour(void *callbackfunction, void **trampoline, const char *signame)
{
 CDetour *detour = new CDetour(callbackfunction, trampoline, signame);
 if (detour)
 {
  if (!detour->Init(spengine, gameconf))
  {
   delete detour;
   return 
         __null
             ;
  }

  return detour;
 }

 return 
       __null
           ;
}

CDetour *CDetourManager::CreateDetour(void *callbackfunction, void **trampoline, void *pAddress)
{
 CDetour *detour = new CDetour(callbackfunction, trampoline, pAddress);
 if (detour)
 {
  if (!detour->Init(spengine, gameconf))
  {
   delete detour;
   return 
         __null
             ;
  }

  return detour;
 }

 return 
       __null
           ;
}

CDetour::CDetour(void *callbackfunction, void **trampoline, const char *signame)
{
 enabled = false;
 detoured = false;
 detour_address = 
                 __null
                     ;
 detour_trampoline = 
                    __null
                        ;
 this->signame = signame;
 this->detour_callback = callbackfunction;
 spengine = 
           __null
               ;
 gameconf = 
           __null
               ;
 this->trampoline = trampoline;
}

CDetour::CDetour(void*callbackfunction, void **trampoline, void *pAddress)
{
 enabled = false;
 detoured = false;
 detour_address = pAddress;
 detour_trampoline = 
                    __null
                        ;
 this->signame = 
                __null
                    ;
 this->detour_callback = callbackfunction;
 spengine = 
           __null
               ;
 gameconf = 
           __null
               ;
 this->trampoline = trampoline;
}

bool CDetour::Init(ISourcePawnEngine *spengine, IGameConfig *gameconf)
{
 this->spengine = spengine;
 this->gameconf = gameconf;

 if (!CreateDetour())
 {
  enabled = false;
  return enabled;
 }

 enabled = true;

 return enabled;
}

void CDetour::Destroy()
{
 DeleteDetour();
 delete this;
}

bool CDetour::IsEnabled()
{
 return enabled;
}

bool CDetour::CreateDetour()
{
 if (signame && !gameconf->GetMemSig(signame, &detour_address))
 {
  g_pSM->LogError(myself, "Could not locate %s - Disabling detour", signame);
  return false;
 }
 else if(!detour_address)
 {
  g_pSM->LogError(myself, "Invalid detour address passed - Disabling detour to prevent crashes");
  return false;
 }

 if (!detour_address)
 {
  g_pSM->LogError(myself, "Sigscan for %s failed - Disabling detour to prevent crashes", signame);
  return false;
 }

 detour_restore.bytes = copy_bytes((unsigned char *)detour_address, 
                                                                   __null
                                                                       , 5 +1);


 for (size_t i=0; i<detour_restore.bytes; i++)
 {
  detour_restore.patch[i] = ((unsigned char *)detour_address)[i];
 }

 JitWriter wr;
 JitWriter *jit = &wr;
 jit_uint32_t CodeSize = 0;

 wr.outbase = 
             __null
                 ;
 wr.outptr = 
            __null
                ;

jit_rewind:


 if (wr.outbase != 
                  __null
                      )
 {
  copy_bytes((unsigned char *)detour_address, (unsigned char*)wr.outptr, detour_restore.bytes);
 }
 wr.outptr += detour_restore.bytes;


 jitoffs_t call = IA32_Jump_Imm32(jit, 0);
 IA32_Write_Jump32_Abs(jit, call, (unsigned char *)detour_address + detour_restore.bytes);

 if (wr.outbase == 
                  __null
                      )
 {
  CodeSize = wr.get_outputpos();
  wr.outbase = (jitcode_t)spengine->AllocatePageMemory(CodeSize);
  spengine->SetReadWrite(wr.outbase);
  wr.outptr = wr.outbase;
  detour_trampoline = wr.outbase;
  goto jit_rewind;
 }

 spengine->SetReadExecute(wr.outbase);

 *trampoline = detour_trampoline;

 return true;
}

void CDetour::DeleteDetour()
{
 if (detoured)
 {
  DisableDetour();
 }

 if (detour_trampoline)
 {

  spengine->FreePageMemory(detour_trampoline);
  detour_trampoline = 
                     __null
                         ;
 }
}

void CDetour::EnableDetour()
{
 if (!detoured)
 {
  DoGatePatch((unsigned char *)detour_address, &detour_callback);
  detoured = true;
 }
}

void CDetour::DisableDetour()
{
 if (detoured)
 {

  ApplyPatch(detour_address, 0, &detour_restore, 
                                                __null
                                                    );
  detoured = false;
 }
}
